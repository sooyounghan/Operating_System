-----
### 신뢰할 수 있는 통신 계층
-----
1. 신뢰할 수 있는 통신 게층을 만들기 위해 패킷 손실에 대응할 수 있는 새로운 메커니즘과 기술 필요
   - 클라이언트가 불안한 연결을 통해 서버로 메세지를 전송하는 간단한 예
<div align="center">
<img src="https://github.com/user-attachments/assets/44edb561-33e1-444f-b9d5-3ea5685f1332">
</div>

   - 발신자는 수신자가 메세지를 수신했다는 것을 알기 위해 확인(Acknowledgement) 또는 짧게 ACK라고 하는 개념을 사용
     + 발신자는 메세지를 수신자에게 보내며, 수신자는 받았다는 것을 알리기 위해 짧은 메세지를 다시 보냄
     + 발신자가 메세지가 잘 도착했다는 ACK를 받으면 수신자가 메세지를 잘 받았다는 것을 확신할 수 있음
     + 못 받을 경우에는 타임아웃(Timeout)이라고 하는 추가적 장치가 필요 : 발신자가 메세지를 보낼 때 발신자는 타이머를 설정하여 일정 시간이 흐른 후에 종료되도록 함
       * 만약 그 시간 안에 ACK를 받지 못한다면, 발신자는 메세지를 잃어버렸다고 판단하며, 발신자는 똑같은 메세지 재전송 재시도
       * 이것이 제대로 동작하려면 발신자는 재전송에 대비하여 메세지의 사본을 갖고 있어야 하며, 타임아웃과 재시도라는 기술이 조합되었으므로 일부는 이 방법을 타임아웃/재시도 방식이라고 부름
<div align="center">
<img src="https://github.com/user-attachments/assets/5e0398b4-8a8c-4039-b5ce-0a48dd919cba">
</div>

2. 현재 상태의 타임아웃 / 재시도로는 충분하지 않음
   - 패킷 손실이 문제를 만들어 내는 경우
<div align="center">
<img src="https://github.com/user-attachments/assets/c45521c0-fe1c-4680-8218-48c53033448c">
</div>

   - 원래 메세지가 손실되는 것이 아니라 ACK 메세지가 손실
   - 발신자 측에서 본다면 ACK를 못 받은 상황과 마찬가지이므로 타임아웃과 재시도 방식이 제대로 동작하는 것 처럼 보임
   - 하지만, 수신자 측에서 보면 상당히 다름 : 같은 메세지를 두 번 받음
   - 신뢰성 있는 메세지 계층을 목표로 한다면, 수신측도 각 메세지를 정확히 한 번만 받는다는 보장이 필요

3. 수신자가 중복된 메세지를 검출할 수 있으려면 발신자가 각 메세지를 구분해서 전송해야 하며, 수신자는 각 메세지를 이전에도 받은 적 있는지 파악할 수 있는 방법 필요
   - 수신자가 메세지를 중복해서 수신할 경우, 메세지에 대해 ACK를 보내지만 응용 프로그램에게는 받은 데이터를 전달하지 않음
   - 발신자는 ACK를 받지만, 메세지는 두 번 받지 않으므로 정확히 한 번씩 처리하는 시맨틱을 따르게 됨

4. 중복된 메세지를 검출하는 많은 방법 존재
   - 예를 들어, 발신자가 각 메시지를 위해 유일한 ID를 생성할 수 있으며, 수신자는 지금까지 받은 모든 ID를 다 추적할 수 있음 : 이 방법은 무한정의 메모리가 필요하므로 비싼 작업
   - 작은 양의 메모리를 사용하면서 문제를 해결하는 좀 더 간단한 방법 : 순서 카운터(Sequence Counter)
     + 순서 카운터를 사용하기 위해 발신자와 수신자가 양쪽에 관리할 어떤 시작 값(예) 1)에 서로 동의
     + 메세지를 보내면서 현재의 카운터 값을 함께 전송
     + 이 카운터 값(N)은 메세지의 ID 역할을 하며, 메세지가 전송된 후 발신자는 값을 (N + 1)로 증가
     + 수신자는 이 카운터 값을 발신자 측으로부터 도착하는 메세지의 예상 ID 값으로 사용
     + 만약 수신한 메세지의 ID (N)이 수신자의 카운터(마찬가지로 N)와 동일하다면 메세지에 대해 ACK를 보내고, 메세지를 응용 프로그램에 전달
     + 이 경우, 수신자는 이 메세지가 처음 받은 것이라고 결론을 내리며, 수신자는 이후 카운터를 (N + 1)로 증가시키고 다음 메세지를 기다림

5. ACK가 손실된 경우에는 발신자는 타임아웃으로 인해 메세지 N을 재전송
   - 이번에는 수신자의 카운터가 (N + 1)로 크기 때문에 발신자는 메세지를 이미 받았었다는 것을 암
   - 그러므로 메세지에 대해 ACK를 전송하지만, 메세지를 응용 프로그램에게 전달하지 않음
   - 이런 간단한 방식의 순서 카운터를 사용해 중복 수신을 피할 수 있음

6. 가장 흔히 사용되는 신뢰할 수 있는 통신 계층은 TCP/IP 또는 짧게 TCP라고 부름
   - TCP는 훨씬 더 정교한 기법으로 이루어져 있으며, 네트워크 혼잡도 관리 기법과 다중 대기 중 요청들을 지원하며 수백 가지의 작은 수정과 최적화 기법들을 포함하고 있음

7. 참고 : 무결성을 위해 체크섬 사용
   - 체크섬은 손상을 빠르게 그리고 효율적으로 검출하기 위해 현대 시스템에서 흔히 사용하는 기법
   - 간단한 체크섬은 덧셈 방식 : 데이터 바이트 청크를 그냥 더하는 것
   - 이 외에도 순환 중복 코드(CRC)와 Fletcher 체크섬이 있으며, 그 외에도 더 존재
   - 네트워크의 체크섬은 한 기계에서 다른 기계로 메세지를 전송하기 전 메세지의 체크섬을 계산하며, 그리고 메세지와 체크섬을 목적지로 전송
     + 목적지에서 수신자는 받은 메세지로 체크섬 계산을 똑같이 하며, 만약 계산된 체크섬이 보낸 체크섬과 일치하다면 수신자는 전송 중 데이터가 손상되지 않았다는 것을 확신할 수 있음
