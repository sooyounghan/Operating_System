-----
### 다른 문제들
-----
1. RPC 런타임이 다뤄야 할 문제
   - 원격 호출이 완료까지 오랜 시간이 걸릴 경우 : 타임아웃 방식을 사용하면 장 시간 동작하는 원격 호출은 클라이언트에게 실패한 것으로 보일 것이므로 재시도를 하게 될 것
     + 그렇기 때문에 이 부분을 수정해야하며, 한 가지 해법은 응답이 즉시 생성되지 않는 경우 ACK를 먼저 보내는 것 (수신자가 발신자에게)
     + 클라이언트는 서버가 요청을 받았다는 것을 알 수 있으며, 어느 정도 시간이 흐른 후, 클라이언트는 주기적으로 서버가 해당 요청을 처리 중인지 확인
     + 그때마다 서버가 작업 중이라고 한다면, 클라이언트는 계속 대기

   - 런타임도 마찬가지로 한 패킷에 담을 수 있는 양보다 더 많은 수의 인자를 갖는 프로시저 호출들을 처리할 수 있어야 함
     + 어떤 하부 게층의 네트워크 프로토콜은 이런 발신자 측 분철(Fragmentation, 큰 패킷을 여러 작은 조각들로 나누는 것)과 수신자측 재조합(Reassembly, 작은 조각들을 전체가 되는 논리적 큰 청크로 만들기) 기법을 제공
     + 그렇지 않다면, RPC 런타임은 이와 같은 기능을 자체적으로 구현해야함

2. 바이트 순서 표시(Byte Ordering)에 관한 것
   - 어떤 기계들은 빅 엔디안(Big Endian) 순으로 값을 저장하고 어떤 기계들은 리틀 엔디안(Little Endian)으로 쓰기도 함
     + 빅 엔디안 : 바이트를 (int형이라고 가정) 최상위 비트부터 최하위 비트까지 아라비아 숫자처럼 표기
     + 리틀 엔디안 : 그 반대로 표현
     + 두 방식 모두 수치를 저장하는 올바른 방식
     + 서로 다른 저장 방식을 사용하는 기계들끼리의 통신 방법 : RPC 패키지는 메세지 포맷에 잘 정의되어 있는 엔디안을 사용하는 것으로 이 문제를 해결
       * Sun사의 RPC 패키지에는 XDR(eXternal Data Representation, 외부 데이터 표현 방식) 계층이 그 역할을 하여 기능을 제공
       * 만약 기계가 XDR의 엔디안을 준수하여 메세지를 발신 또는 수신하면, 기대한 대로 메세지를 발신하고 수신할 수 있음
       * 하지만, 만약 기계가 다른 엔디안을 사용하여 통신하면, 메세지의 각 정보는 변환되어야 하므로, 엔디안의 차이에 대한 약간의 성능 비용을 지불해야 함

  3. 클라이언트에게 비동기적 실행을 허가할 것인지에 대한 문제
     - 그에 따른 성능 개선이 가능
     - 어떤 RPC는 동기적으로 작동 : 즉, 클라이언트가 프로시저 호출을 요청하면 그 결과가 리턴될 때까지 대기 (대기 시간이 길어질 수 있음)
     - 클라이언트가 다른 일을 처리하도록 어떤 RPC 패키지는 RPC를 비동기적으로 호출 : 비동기 RPC가 호출되면 RPC 패키지는 요청을 보내고 즉시 리턴하며, 클라이언트 그 후 다른 RPC를 호출한다거나 유용한 연산을 하는 식 다른 작업을 자유롭게 진행 가능하며, 어느 시점에 가서는 클라이언트가 비동기 RPC에 대한 결과를 원할 때, RPC를 이 때 호출하여 현재 진행 중인 RPC를 대기하도록 하며, 완료되면 리턴된 인자들을 접근 가능
