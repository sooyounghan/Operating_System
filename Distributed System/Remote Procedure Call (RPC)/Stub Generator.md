-----
### 스텁 생성기 (Stub Generator)
-----
1. 함수의 인자들을 묶는 불편함을 없애고 자동적으로 메세지를 만드는 것
2. 장점
   - 수작업으로 코드를 작성할 경우 발생할 수 있는 작은 실수들을 막아주며, 스텁 컴파일러가 그런 코드를 최적화할 수 있으므로 성능 개선도 가능

3. 서버가 클라이언트에게 공지할 프로시저 집합을 컴파일러에게 입력으로 전달
```c
interface {
    int func1(int arg1);
    int func2(int arg1, int arg2);
};
```

4. 스텁 생성기는 이런 종류의 인터페이스를 사용하여 몇 개의 다른 코드를 생성해냄
   - 클라이언트 용으로 인터페이스에 명시된 함수들로 클라이언트 스텁(Client Stub)들을 생성
   - 클라이언트 프로그램이 RPC 서비스를 이용하기 원하면 클라이언트 스텁을 생성하여 호출

5. 클라이언트 스텁의 각 함수들이 원격 프로시저 호출을 위한 일을 처리
   - 클라이언트 코드는 함수 호출처럼 보임 (예) 클라이언트가 func1(x)를 호출)
   - 클라이언트 스텁 func1()의 코드의 역할
     + 메세지 버퍼 생성 : 일반적으로 메세지 버퍼는 특정 크기 배열
     + 메세지 버퍼에 필요 정보 병합 : 함수 식별자나 함수 인자들이 포함 (예) 앞 예제에서는 func1의 int형 하나)하며, 버퍼에 이 정보를 담는 과정을 인자들을 합병하기(Marshaling) 또는 메세지를 직렬화하기(Serialization)라고 표현
     + RPC 서버에 메세지 전송 : RPC 서버와 통신 그리고 동작하는데 필요한 모든 상세 동작은 RPC 런타임 라이브러리가 담당
       * 응답 대기 : 함수 호출은 대부분 동기식(Synchronous)이기 때문에 완료될 때까지 대기
       * 리턴 코드와 인자 풀기 : 함수가 하나의 리턴 코드만 리턴하면 이 프로세스는 단순하지만, 복잡한 함수의 경우 좀 더 복잡한 결과를 리턴할 수 있음(예) 리스트), 그러므로 스텁의 내용들을 다 풀어내야 할 필요가 있는데, 이 과정을 합병 해제하기 또는 역직렬화
       * 호출자에게 리턴하기 : 클라이언트 스텁으로부터 최종적으로 클라이언트 코드 리턴

6. 서버 용 코드도 생성되는데, 서버 측에서 수행되는 과정
   - 메세지 풀기 : 이 단계에서는 도착하는 메세지에서 합병 해제하기 또는 역직렬화를 통해 정보를 추출하며, 함수 식별자와 인자들이 추출
   - 실제 함수를 호출하기 : 원격 함수가 실제로 실행되는 지점에 도달되며, RPC 실행 시간 호출이 ID로 지정되어 있는 함수를 부르며 해당하는 인자를 전달
   - 결과 통합 : 리턴 인자(들)는 응답 버퍼에 다시 합병
   - 응답 전송하기 : 응답이 마침내 호출자에게 전송

7. 고려해야 할 몇 가지 중요 문제
   - 복잡한 구조의 인자나 다수의 인자를 전달하는 문제 : 즉, 복잡한 자료 구조를 어떻게 패키지화하여 전송할 것인가?
     + write() 시스템 콜을 사용할 때는 세 개의 인자를 전달해야 함 : int 형의 파일 디스크럽터와 버퍼의 포인터, 써야 할 바이트를 나타내는 크기(포인터를 시작으로) 전달
     + 만약 RPC 패키지가 포인터를 전달했다면, 그 포인터를 어떻게 해석해야 하는지 알아야 정확한 동작 가능
     + 일반적으로 잘 알려진 데이터 형(예) RPC 컴파일러가 이해할 수 있는 buffer_t라는 자료 구조를 사용해 특정 크기의 데이터 청크를 전달)을 사용하거나 자료 구조를 해석하는 방법에 대한 내용을 추가해 컴파일러가 바이트의 어떤 부분을 직렬화할지 알 수 있도록 함

   - 병행성을 고려하여 서버를 구성하는 것
     + 단순한 서버는 간단한 반복문에서 요청을 대기하며 한 번에 한 요청씩 처리 : 엄청나게 비효율적일 수 있음
     + 만약 RPC 호출이 차단되면(I/O를 기다린다고 한다면), 서버의 자원이 낭비
     + 그러므로 대부분의 서버들은 병행성을 이용하여 구성
     + 흔한 구성 방식은 쓰레드 풀(Thread Pool)을 사용 : 서버를 시작할 때 정해진 수의 쓰레드들을 생성하고, RPC 호출이 도착하면 메인 쓰레드가 워커 쓰레드로 보냄
       * 메인 쓰레드는 계속 RPC 호출을 받기 위해 대기하며, 또 다른 요청이 도착하면, 다시 다른 워커 쓰레드에게 전달
       * 이와 같은 방식으로 서버 내 병행 실행을 활용하여 활용률을 높일 수 있음

   - RPC 서버를 구성하는 필요한 프로그래밍 복잡도가 약간 늘어남 : RPC 호출의 올바른 동작이나 락이나 기타 동기화 기법들을 써야하기 때문임
