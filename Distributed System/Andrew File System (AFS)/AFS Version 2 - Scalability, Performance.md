-----
### AFSv2의 확장성과 성능
-----
1. 새로운 프로토콜을 추가함으로써, AFSv2의 성능이 확장성 측면에서 원래 버전보다 훨씬 더 우수해짐
   - 실제로, 하나의 서버가 약 50개의 클라이언트(단 20개가 아닌)를 지원할 수 있음
   - 더욱 바람직한 성질은 클라이언트 성능이 대부분 경우 로컬 성능에 거의 가깝게 나옴 : 파일들을 로컬에서 접근하기 때문임
   - 특히 대부분 읽기 요청이 로컬 디스크 캐시(실질적으로 많은 경우 로컬 메모리)에서 처리되며, 새로운 파일을 생성하거나 기존의 것에 쓰는 경우에만 서버에 Store 메세지를 전달할 필요가 있고, 서버의 해당 파일이 새로운 버전으로 갱신

2. AFS 성능을 NFS와 비교
<div align="center">
<img src="https://github.com/user-attachments/assets/b387b2fc-bf1e-456d-9696-e00a9fb87b3d">
</div>

   - 다양한 크기의 파일들에 대해 대표적인 읽기와 쓰기 패턴에서의 성능을 분석
   - 작은 파일들은 $N_{s}$개의 블럭들로 이루어져 있으며, 중간 크기 파일들은 $N_{m}$개의 블럭들로 그리고 큰 파일들은 $N_{L}$ 블럭들로 이루어져 있음
   - 작은 파일들과 중간 크기의 파일들은 클라이언트의 메모리에 저장이 가능하다고 가정하고, 큰 파일들은 로컬 디스크에는 저장 가능하지만 클라이언트 메모리에 저장이 안 된다고 가정

3. 분석을 위해 네트워크를 통해 원격 서버의 파일 블럭에 접근하는 것을 $L_{net}$ 단위 시간만큼 소요된다고 가정
   - 로컬 메모리에 접근하는 것은 $L_{mem}$의 시간이 소요되고, 로컬 디스크에 접근하는 것은 $L_{disk}$의 시간이 소요
   - 일반적으로 $L_{net}$ > $L_{disk}$ > $L_{mem}$의 식이 성립

4. 마지막으로, 처음으로 파일에 접근하는 경우 캐시에서 가져올 수 있는 것은 없으며, 캐시에 파일 전체를 저장할 만큼 충분한 공간이 있을 때에만 반복되는 파일 접근(즉, 다시읽기)들이 캐시에서 히트

<div align="center">
<img src="https://github.com/user-attachments/assets/b387b2fc-bf1e-456d-9696-e00a9fb87b3d">
</div>

5. 그림의 각 줄은 특정 작업(예) 작은 파일을 순차 읽기)을 처리할 때 NFS 또는 AFS에서 걸리는 대략적인 시간을 나타냄
   - 가장 우측은 AFS와 NFS의 비율을 나타냄

6. 대부분의 경우 각 시스템 성능은 대체로 비슷
   - 예를 들어, 파일을 처음 읽는 경우(예) 워크로드 1, 3, 5), 원격 서버에서 파일을 가져오는 시간이 대부분을 차지
   - 두 시스템 모두 비슷한 시간이 소요되며, 이 경우 파일을 로컬 디스크에 써야하므로 AFS가 더 느릴 수 있다고 생각할 수 있는데, 해당 쓰기는 로컬(클라이언트 측) 파일 시스템의 캐시에 버퍼가 되기 때문에 그 비용이 감춰지는 경향이 있음
   - 마찬가지로, AFS는 캐시된 사본을 디스크에 저장하기 때문에 로컬에 캐시된 사본을 읽는 것이 느릴 것이다라고 생각할 수 있는데, AFS는 로컬 파일 시스템 캐시의 혜택을 얻어, AFS에서 읽을 때 클라이언트 측 메모리 캐시에서 히트가 발생할 가능성이 많아 NFS와 성능이 비슷하게 될 것

7. 흥미로운 차이점 : 큰 파일을 순차적으로 다시 읽기를 시도할 때 나타남 (워크로드 6)
   - AFS는 큰 로컬 디스크 캐시를 가지므로 파일을 다시 읽을 때에는 디스크에서 파일을 읽을 것
   - 대비적으로 NFS는 클라이언트 메모리에 블럭들만 캐시할 수 있으므로, 그 결과 큰 파일(즉, 로컬 메모리보다 큰 파일)이 다시읽기 되었다면 NFS 클라이언트는 원격 서버로부터 전체 파일을 다시 가져와야함
   - 그러므로 실제 원격 접속이 로컬 디스크보다 느리다고 하면, AFS는 NFS보다 $\frac{L_{disk}}{L_{net}}$배만큼 더 빠름
   - 이 경우 NFS 서버의 오버헤드도 증가하므로, 다수의 클라이언트 서비스하는 데 (확장성) 영향을 줌

8. 순차 쓰기 동작은 (새로운 파일들에 대한) 양 시스템에서 비슷한 성능을 보임 (워크로드 8, 9)
   - AFS는 파일을 로컬의 캐시된 사본에 쓸 것이며, 파일이 닫히면 AFS 클라이언트는 프로토콜에 정의된 바와 같이 해당 파일을 서버로 전송
   - NFS는 쓰기 결과를 클라이언트 메모리 버퍼에 보관하며, 클라이언트 측 메모리가 고갈될 경우 블럭들이 강제로 서버로 보내질 수 있지만, NFS는 닫을-때-내보냄 일관성을 유지하기 위해 분명하게 파일이 닫힐 때에만 서버에 쓰도록 하고 있음
   - 이 부분에서 AFS는 모든 데이터를 디스크에 쓰기 때문에 AFS가 더 느리다고 생각할 수 있지만, 로컬 파일 시스템에 쓴다는 것을 기억해야함
   - 쓰기는 먼저 페이지 캐시에 커밋되고 얼마 후 (백그라운드로) 디스크로 내려감
   - AFS는 클라이언트 측 운영체제의 메모리 캐싱 부분의 도움으로 성능 향상

9. AFS는 파일 순차 덮어쓰기에서 성능이 아주 안좋음 (워크로 10)
    - 새로운 파일을 생성하는 워크로드만을 가정
    - 하지만, 이 경우 이미 존재하는 파일을 갱신하므로, AFS에서는 특히 덮어쓰기 일 경우 안 좋음
    - 이는 클라이언트가 파일 전체를 먼저 가져온 뒤, 덮어 쓰기를 수행하기 때문임
    - 그에 반하여 NFS의 클라이언트는 블럭들을 무조건 덮어쓰므로, 파일을 클라이언트로 읽어올 필요가 없음

10. 마지막으로, 큰 파일의 일부 작은 데이터를 접근하는 워크로드에서는 NFS가 AFS보다 훨씬 더 좋은 성능을 가짐 (워크로드 7, 워크로드 11)
    - AFS 프로토콜은 파일이 열리면 파일 전체를 가져오지만, 불행하게도 작은 크기의 읽기 또는 쓰기만 수행되는 경우
    - 만약 파일이 갱신되었다면, 전체 파일을 서버로 다시 보내야 하므로 오버헤드가 두 배가 되며, 블럭 기반의 프로토콜을 따르는 NFS는 읽기와 쓰기 크기에 비례하여 I/O 수행

11. NFS와 AFS는 서로 다른 목적으로 설계되었으므로, 그 결과 서로 다른 성능 특성을 보임

12. 참고 : 워크로드의 중요성
    - 어떤 시스템이든지 평가할 때 가장 중요한 사항은 워크로드의 선택
    - 컴퓨터 시스템들은 매우 다양하게 사용되므로 선택할 수 있는 워크로드가 너무나 많음
    - AFS 설계자들은 자신들이 관찰한 파일 시스템 사용 패턴을 기반으로 워크로드 특성을 결정 : 구체적으로 대부분 파일들은 공유 빈도가 낮으며 접근이 될 때 그 전체를 순차적 접근하다고 가정
      + 하지만 이는 항상 옳지 않은데, 예를 들어, 응용 프로그램이 정보를 주기적으로 로그에 추가하는 경우
      + AFS에 있어서 이는 매우 골치아픈 문제이며, 그 외에도 일례로, 데이터베이스 트랜잭션이 임의의 위치에 갱신하는 워크로드도 문제 발생
