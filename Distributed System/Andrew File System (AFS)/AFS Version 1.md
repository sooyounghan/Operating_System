-----
### AFS 버전 1
-----
1. 기본적인 기능을 다 갖추고 있지만 확장성이 좋지 않아, 재설계를 통해 최종적인 프로토콜(AFSv2 또는 AFS)이 탄생
2. 모든 버전의 AFS의 기본 원칙 중 하나 : 클라이언트가 파일을 접근하면 로컬 디스크에 파일 전체를 캐싱(Whole-File-Caching)하는 것
   - 파일을 open()하면 전체 파일(존재한다면)을 서버에서 가져와서 로컬 디스크에 파일로 저장하는 것
   - 프로그램이 연이어 read()와 write() 요청을 하면 그 요청은 파일이 저장되어 있는 로컬 파일 시스템에서 서비스됨
   - 그러므로 이 연산들은 네트워크 통신이 발생하지 않으므로 매우 빠름
   - 마지막으로 close()를 호출하면 해당 파일은(변경이 있었으면) 서버로 전송
   - 여기서 NFS와 명백한 차이점에 유의해야 하며, NFS의 캐싱 단위는 블럭이며(전체 파일이 아니기는 하지만 NFS가 파일의 모든 블럭을 캐시할 수 있음), 클라이언트의 메모리(로컬 디스크가 아님)에 해당 블럭을 저장

3. 클라이언트 측 응용 프로그램이 open()을 호출하면, AFS 클라이언트(AFS 설계자들은 비너스(Venus)라고 부름)은 Fetch 프로토콜 메세지를 서버로 전송
   - Fetch 프로토콜 메세지를 통해 파일 전체 경로명(예) /home/remzi/notes.txt)을 파일 서버(바이스(Vice)라고 부름)로 전송
   - 서버는 경로명을 따라가서 파일을 찾은 후 클라이언트에게 전체 파일을 전송하며, 클라이언트의 로컬 디스크에 파일을 캐싱 (로컬 디스크에 씀)
   - AFS는 연이은 read()와 write() 시스템 콜은 엄격하게 로컬에서만 일어남 (서버와의 통신은 발생하지 않음)
   - 해당 호출은 로컬의 파일 사본으로 향하게 될 뿐이며, read()와 write() 호출은 마치 로컬 파일 시스템에 호출하는 것과 같이 동작하므로 접근된 블럭은 클라이언트 메모리에 캐시될 수 있음
   - 그러므로 AFS는 클라이언트의 메모리에 로컬 디스크의 블럭들을 사본에 캐싱
   - 작업이 종료되면, AFS의 클라이언트는 파일의 변경 여부를 검사 (만약 파일을 쓰기 위해 열었다면)
   - 변경되었으면 새로운 버전을 서버로 Store 프로토콜 메세지와 함께 전송하며, 이 때, 전체 파일 경로명이 서버로 전달되어 영속 저장 장치에 기록

4. 그 뒤에 해당 파일이 접근되면 좀 더 효율적 처리 가능
   - 클라이언트는 먼저 서버에 파일의 변경 여부를 확인 (TestAuth 프로토콜 메세지 사용)
   - 변경이 없다면, 클라이언트의 로컬에 캐시된 버전을 사용하면 되므로 네트워크 전송이 불필요해지고 성능을 개선할 수 있음

5. AFSv1 프로토콜 메세지
<div align="center">
<img src="https://github.com/user-attachments/assets/57e6deaf-c052-43bb-b238-50ce596b80c6">
</div>

   - 초기 버전 프로토콜에서는 파일 내용만 캐시했음
   - 디렉터리 등은 서버에 저장

-----
### 버전 1의 문제점
-----
1. 경로명을 따라가는 것은 매우 비싼 작업
   - Fetch 또는 Store 프로토콜에 따라 요청하면 클라이언트는 전체 경로명(예) /home/remzi/notes.txt)을 서버에게 전달
   - 해당 파일을 접근하기 위해 서버는 먼저 루트 디렉토리에서 home을 찾고, home에서 remzi를 찾아 나가는 식으로 원하는 파일을 찾을 때까지 경로명 전체를 따라감
   - 많은 클라이언트들이 서버에 동시에 접근할 경우, 대부분의 서버는 CPU 시간이 단순히 디렉토리 경로명을 따라가는 것에 사용되고 있음

2. 클라이언트가 TestAuth 프로토콜 메세지를 너무 많이 요청
   - GETATTR 프로토콜 메세지가 너무나 많았던 NFS와 비슷하게 AFSv1도 TestAuth 프로토콜 메세지를 사용하여 로컬의 파일(또는 stat 정보)이 유효한지 검사하려고 엄청난 트래픽 생성
   - 그로 인해 서버들이 클라이언트 캐시에 저장되어 있는 파일 사본의 사용 여부를 알려주느라 대부분 시간 낭비
   - 대부분의 경우 그 대답은 파일은 변경되지 않음

3. 서버들 간 오버헤드가 적절히 분산되지 않았으며, 서버는 클라이언트마다 각기 다른 프로세스를 할당하여 사용하였으므로 문맥 교환 비용 등의 다른 오버헤드 유발
   - 관리자가 오버헤드의 불균형 문제를 해결할 수 있도록 여기저기로 이동할 수 있는 볼륨(Volume) 개념 도입
   - AFSv2는 프로세스 대신 쓰레드를 사용하여 문맥 교환 문제 해결
   
