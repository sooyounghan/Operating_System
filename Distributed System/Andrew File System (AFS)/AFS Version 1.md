-----
### AFS 버전 1
-----
1. 기본적인 기능을 다 갖추고 있지만 확장성이 좋지 않아, 재설계를 통해 최종적인 프로토콜(AFSv2 또는 AFS)이 탄생
2. 모든 버전의 AFS의 기본 원칙 중 하나 : 클라이언트가 파일을 접근하면 로컬 디스크에 파일 전체를 캐싱(Whole-File-Caching)하는 것
   - 파일을 open()하면 전체 파일(존재한다면)을 서버에서 가져와서 로컬 디스크에 파일로 저장하는 것
   - 프로그램이 연이어 read()와 write() 요청을 하면 그 요청은 파일이 저장되어 있는 로컬 파일 시스템에서 서비스됨
   - 그러므로 이 연산들은 네트워크 통신이 발생하지 않으므로 매우 빠름
   - 마지막으로 close()를 호출하면 해당 파일은(변경이 있었으면) 서버로 전송
   - 여기서 NFS와 명백한 차이점에 유의해야 하며, NFS의 캐싱 단위는 블럭이며(전체 파일이 아니기는 하지만 NFS가 파일의 모든 블럭을 캐시할 수 있음), 클라이언트의 메모리(로컬 디스크가 아님)에 해당 블럭을 저장

3. 클라이언트 측 응용 프로그램이 open()을 호출하면, AFS 클라이언트(AFS 설계자들은 비너스(Venus)라고 부름)은 Fetch 프로토콜 메세지를 서버로 전송
   - Fetch 프로토콜 메세지를 통해 파일 전체 경로명(예) /home/remzi/notes.txt)을 파일 서버(바이스(Vice)라고 부름)로 전송
   - 서버는 경로명을 따라가서 파일을 찾은 후 클라이언트에게 전체 파일을 전송하며, 클라이언트의 로컬 디스크에 파일을 캐싱 (로컬 디스크에 씀)
   - AFS는 연이은 read()와 write() 시스템 콜은 엄격하게 로컬에서만 일어남 (서버와의 통신은 발생하지 않음)
   - 해당 호출은 로컬의 파일 사본으로 향하게 될 뿐이며, read()와 write() 호출은 마치 로컬 파일 시스템에 호출하는 것과 같이 동작하므로 접근된 블럭은 클라이언트 메모리에 캐시될 수 있음
   - 그러므로 AFS는 클라이언트의 메모리에 로컬 디스크의 블럭들을 사본에 캐싱
   - 작업이 종료되면, AFS의 클라이언트는 파일의 변경 여부를 검사 (만약 파일을 쓰기 위해 열었다면)
   - 변경되었으면 새로운 버전을 서버로 Store 프로토콜 메세지와 함께 전송하며, 이 때, 전체 파일 경로명이 서버로 전달되어 영속 저장 장치에 기록

4. 그 뒤에 해당 파일이 접근되면 좀 더 효율적 처리 가능
   - 클라이언트는 먼저 서버에 파일의 변경 여부를 확인 (TestAuth 프로토콜 메세지 사용)
   - 변경이 없다면, 클라이언트의 로컬에 캐시된 버전을 사용하면 되므로 네트워크 전송이 불필요해지고 성능을 개선할 수 있음

5. AFSv1 프로토콜 메세지
<div align="center">
<img src="https://github.com/user-attachments/assets/57e6deaf-c052-43bb-b238-50ce596b80c6">
</div>

   - 초기 버전 프로토콜에서는 파일 내용만 캐시했음
   - 디렉터리 등은 서버에 저장
