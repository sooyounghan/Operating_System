-----
### AFS 버전 2
-----
1. AFSv2는 클라이언트와 서버 간 상호작용 횟수를 줄이기 위해 콜백(Callback)이라는 개념 도입
   - 간단하게 콜백은 서버가 클라이언트에게 캐싱된 파일의 변경 사실을 알려주겠다고 하는 서버의 약속
   - 클라이언트에 캐쉬된 파일들에 있어 상태(State) 정보가 추가
   - 클라이언트는 캐시된 파일의 유효성 검사를 위해 서버에 접근할 필요가 없으며, 서버의 변경 여부를 알려주기 전까지 클라이언트는 파일이 유효하다고 가정

2. AFSv2는 경로명 대신 파일 식별자(File Identifier, FID, NFS의 파일 핸들과 유사)라는 개념울 사용해 클라이언트가 원하는 파일의 위치 표시
   - AFS의 FID는 볼륨 식별자와 파일 식별자 그리고 Uniquifier(파일이 삭제되었을 때, 볼륨과 파일 ID가 재사용이 가능하도록 함)로 구성
   - 전체 경로명을 서버로 전달하여 서버가 그 경로명 따라가도록 하는 대신, 클라이언트가 경로명을 한 번에 하나씩 따라가면서 그 결과를 캐싱

3. 클라이언트가 파일 /home/remzi/notes.txt를 접근한다고 가정
   - AFS 디렉토리의 home이 /에 마운트되었다고 가정 (즉, /가 로컬 루트 디렉토리이며, home과 그 이하 디렉토리는 AFS에 있는 것)
   - 클라이언트는 먼저 home 디렉터리 내용을 Fetch로 가져와서 로컬 디스크 캐시에 넣은 후 home에 대해 콜백 설정
   - 그 후, 디렉토리 remzi를 Fetch로 가져와서 로컬 디스크에 캐시로 넣은 후 서버의 remzi에 대해서도 콜백 설정
   - 마지막으로 notes.txt를 Fetch로 가져온 후 로컬 디스크에 이 일반 파일을 캐싱하고, 콜백 설정 후 최종적으로 호출한 응용 프로그램에게 파일 디스크럽터 리턴

<div align="center">
<img src="https://github.com/user-attachments/assets/3924a483-5d31-4b2b-ae76-1ffb0dc2257d">
</div>

4. NFS와의 차이점
   - 디렉토리 또는 파일을 가져오는 각 과정에서 AFS의 클라이언트는 서버에 콜백을 설정
   - 서버는 클라이언트가 캐시하고 있는 데이터의 상태가 변경되면 클라이언트에게 반드시 알려줌
   - 이로 인한 장점은, 예를 들어, /home/remzi/notes.txt를 처음으로 접근할 때 많은 클라이언트-서버 메세지가 발생하지만, 모든 디렉토리와 파일 notes.txt에 대해서 콜백을 설정했으므로, 이후 모든 접근이 로컬에서만 발생하고, 서버와 상호작용은 전혀 필요 없음
   - 클라이언트에 파일이 캐시되어 있는 경우 AFS는 로컬 디스크 기반의 파일 시스템과 거의 동일하게 동작
   - 파일을 한 번 이상 접근한다면 두 번째 접근은 로컬에서 접근하는 것처럼 빠르게 접근 가능
