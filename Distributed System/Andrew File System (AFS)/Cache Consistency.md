-----
### 캐시 일관성
-----
1. NFS의 캐시 일관성 : 갱신 가시성(Update Visibility)과 오래된 캐시(Cache Stalenes) 문제
   - 갱신 가시성에서는 새로운 파일이 서버로 갱신되었는지가 문제
   - 오래된 캐시는 서버가 새로운 버전을 갖게 되었을 때, 캐시 사본이 새 버전으로 갱신될 때까지의 걸리는 시간 문제

2. AFS가 제공하는 캐시 일관성은 콜백과 전체 파일 캐싱을 사용하므로 쉽게 설명되고 이해하기도 쉬움
   - 고려사항 : 다른 기계들 간의 일관성 그리고 같은 기계 내 프로세스들 간의 일관성
   - AFS는 서버에서 내용이 변경되는 시점과 다른 기계에 캐시된 사본이 무효화가 되는 시점이 같음 : 그 시점은 갱신된 파일이 닫히는 순간이며, 클라이언트는 파일을 연 후 씀
   - 클라이언트가 파일을 닫으면, 새로운 파일은 서버로 보내지며, 서버는 캐시된 사본을 갖고 있는 클라이언트들과 콜백을 모두 끊어서 클라이언트들이 더 이상 오래된 파일 사본을 캐시에 갖고 있지 않도록 함
   - 콜백이 끊긴 클라이언트들이 그 파일을 다시 열려면 파일을 서버로부터 다시 최신 버전을 갖게 오게 됨

3. AFS는 같은 기계 내 프로세스들 사이에서는 위 일관성을 유지 기법을 적용하지 않음
   - 파일에 대한 쓰기 결과는 즉시 다른 로컬 프로세스들에게 보여짐 (즉, 프로세스가 파일을 닫지 않아도 갱신된 최신 내용이 보임)

4. 서로 다른 기기의 프로세스들이 동시에 한 파일을 수정하는 경우
   - AFS는 마지막 기록자가 승리(Last Writer Wins)라는 방식 사용 (또는 마지막으로 닫는 자가 승리(Loast Closer Wins))
   - close()를 마지막으로 부르는 클라이언트가 서버에 마지막으로 파일의 전체를 갱신하는 것이고, 해당 파일이 승자 파일이 됨
   - 즉, 다른 이들이 보기 될 파일이며, 결과가 사용자가 갱신한 전체 파일
   - 이 때, 블럭 기반 프로토콜을 갖는 NFS와는 다른 점이 있는데, 바로 클라이언트가 파일을 갱신할 때 NFS는 개별 블럭에 쓰고 서버로 전송되었으며, 서버의 최종 파일은 양쪽 클라이언트 갱신 내용이 혼합되어, 혼합된 파일은 대부분 앞 뒤가 맞지 않음
   - 다른 시나리오
<div align="center">
<img src="https://github.com/user-attachments/assets/cd8ad7e3-4a35-434d-98b2-3fdf37cd08d7">
</div>

   - 각 열은 클라이언트 1 상의 두 프로세스(P1, P2)의 동작과 캐시 상태, 클라이언트 2 상의 프로세스(P3)와 캐시 상태 그리고 서버를 나타냄
   - 이 모두는 하나의 가상 파일인 F에 연산을 하고 있음
   - 서버 열은 단순하게 좌측 열들의 연산이 완료된 시점의 파일 내용을 나타냄

5. 참고 : 캐시 일관성이 모든 해결책이 아님
   - 분산 파일 시스템을 설명할 때, 파일 시스템의 캐시 일관성 기능은 중요
   - 하지만, 기본적 일관성으로는 다수의 클라이언트들이 파일에 접근할 때 발생하는 모든 문제를 해결할 수 없음
   - 예를 들어, 여러 클라이언트가 코드를 체크인하고 체크아웃하는 코드 저장소를 만든다고 할 때, 이 때에는 파일 시스템에 전적으로 의지하면 안 됨
     + 동시 접속이 가능한 상황에서는 파일 수준의 락(File-Level Locking)을 사용하여 반드시 제대로 된 일만 발생하도록 해야 함
   - 실제로 어느 응용 프로그램이든 동시 갱신에 주의를 기울이면, 충돌을 피하기 위한 기법 추가
   
