-----
### 캐시 일관성 문제
-----
1. 예제) 두 개의 클라이언트와 하나의 서버 구성 예
   - 클라이언트 C1이 파일 F를 열고, 그 파일의 사본을 로컬 캐시에 보관한다고 가정
   - 그리고 다른 클라이언트 C2가 그 파일 F를 덮어써서 내용을 변경
   - 새로운 버전을 파일 F(version 2) 또는 F[v2]라고 하고 이전 버전을 F[v1]라고 하여 두 개를 구분 (이름만 같을 뿐 다른 내용)
   - 마지막으로 세 번째 클라이언트 C3는 아직까지 파일 F에 접근하지 않음

2. 문제
   - 클라이언트 C2가 쓰기를 잠시 캐시에 보관하기 떄문에 발생
     + F[v2]가 C2의 메모리에 있는 다른 클라이언트(C3라고 하자)가 F를 접근하면 파일의 이전 버전(F[v1])을 가져가게 됨
     + 클라이언트가 쓰기 버퍼링을 사용하면 다른 클라이언트는 해당 파일의 예전 버전을 읽을 가능성이 있음
     + 이처럼 캐시 일관성 문제를 갱신 가시성(Update Visibility)라고 함

   - 오래된 캐시(Stale Cache)
     + C2가 파일 서버로 쓰기를 내려 보내서 서버가 최신 버전(F[v2])을 보관하고 있음
     + 반면에 C1은 여전히 F[v1]을 캐시에 갖고 있다고 하면, C1에서 파일 F를 읽으면 최신 버전 F[v2]가 아닌 (대부분) 오래된 버전 F[v1]을 얻게 됨

3. 해결 방법
   - 갱신의 가시성 해결 : 클라이언트는 닫을-때-내보냄(Flush-on-Close), 다른 이름으로는 열기-전에-닫음(Close-to-Open) 일관성 시맨틱 사용
     + 응용 프로그램이 파일을 갱신하여 그 파일을 닫는 시점에, 갱신 내용(즉, 캐시의 더티 페이지들)을 서버에 보냄
     + 이 기법에서는, NFS는 어떤 파일을 닫았을 때, 그 이후에 다른 노드에서 해당 파일을 열면, 닫겨진 시점의 최신 파일 내용을 읽음
     + 만약, 클라이언트가 파일을 닫을 때 해당 파일 블럭들을 플러시하지 않는다면, 다른 클라이언트들은 close() 시점의 최신 내용들을 읽을 수 없음

   - 오래된 캐시 해결 : NFSv2 클라이언트는 캐시에 보관된 내용을 사용하기 전 파일의 변경 여부를 먼저 검사
     + 클라이언트가 파일을 열 때 GETATTR 요청을 서버로 전송하여 파일의 속성 정보를 가져옴
     + 속성에는 파일이 서버에서 마지막으로 갱신된 시간을 나타내는 정보가 포함
     + 만약 갱신 시점이 파일이 클라이언트에 캐싱된 이후라면, 클라이언트는 캐시된 파일을 무효화(Invalidate)
     + 클라이언트는 캐시에서 파일을 제거하고 서버로 읽기 요청을 전달하여 파일의 최신 버전을 가져옴
     + 만약 클라이언트 자신이 갖고 있는 파일이 최신 버전이라면 캐시에 있는 내용을 그대로 사용하여 성능을 높일 수 있음

4. NFS 서버에 갑자기 GETATTR 요청이 폭발이 증가한 사례
   - 가장 바람직한 설계 원칙은 대표적인 경우(Common Case)를 잘 처리하는 방법을 만드는 것
   - 여기서 대표적인 경우란 하나의 클라이언트가 파일을(어쩌면 반복적으로) 사용하고 있더라도, 서버에 GETATTR 요청을 보내서 파일 변경 여부를 확인해야 함
   - 이 상황을 어느 정도 해결하기 위해 속성 정보 캐시(Attribute Cache)라는 것을 클라이언트에 추가
     + 클라이언트는 여전히 파일을 접근하기 전에 그것이 최신본인지 검사해야 하지만, 이를 위해 대부분 경우 속성 정보를 가져오기 위해 캐시되어 있는 속성 정볼르 사용할 것
     + 파일의 속성 정보는 파일에 처음 접근할 때 캐시에 저장되며, 일정 시간이 지나면 타임아웃(약 3초 정도)
     + 그 3초 동안은 캐시된 파일을 사용해도 괜찮다고 판단하여, 서버와 통신이 발생하지 않음
