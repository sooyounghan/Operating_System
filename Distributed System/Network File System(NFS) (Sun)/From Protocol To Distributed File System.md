-----
### 프로토콜에서 분산 파일 시스템으로
-----
1. 클라이언트 측 파일 시스템은 open()된 파일들을 관리하며, 응용 프로그램 요청을 적절한 프로토콜 메세지들로 변환하는 일을 함
2. 서버는 각 요청에 대해 답하는 것으로, 클라이언트가 보낸 요청은 수행에 필요한 모든 정보를 담고 있음
3. 예) 파일을 읽는 간단한 응용 프로그램 : 응용 프로그램의 시스템 콜을 클라이언트 측 파일 시스템과 파일 서버가 처리하는 과정을 도식적 표현
<div align="center">
<img src="https://github.com/user-attachments/assets/d748773e-1784-4d61-b116-fed98ac2aead">
</div>

   - 클라이언트가 파일 연산의 상태를 어떻게 관리하는지?
     + 클라이언트는 정수형으로 표현되는 파일 디스크럽터와 이에 연결된 NFS 파일 핸들에 대한 정보, 그리고 현재의 파일 오프셋 등을 저장
     + 이러한 정보를 다 관리하고 있으므로, 클라이언트는 각 읽기 요청(읽기 오프셋을 명시적으로 정하지 않음)을 적절하게 포맷된 읽기 프로토콜 메세지로 변환하여 서버가 파일의 어느 부분의 바이트를 읽어야 할 지 알 수 있도록 함
     + 성공적으로 읽기가 처리되면 클라이언트는 현재 파일 위치를 갱신하며, 연이은 읽기가 같은 파일 핸들을 사용하지만 오프셋은 다른 값을 가짐

   - 서버와 언제 상호작용하는가?
     + 파일이 처음으로 열렸다면, 클라이언트 측 파일 시스템은 LOOKUP 요청 메세지를 전송
     + 정확히 말하자면 아주 긴 경로명을 따라가야 한다면(예) /home/remzi/foo.txt), 클라이언트는 세 번의 LOOKUP 메세지를 보냄
       * / 디렉토리에서 home 디렉토리를 검색하기 위해 한 번
       * home에서 remzi를 검색하기 위해 한 번
       * 마지막으로 remzi에서 foo.txt를 탐색하기 위해 한 번

   - 서버에게 보내는 요청에는 그 요청을 완료하는데 필요한 모든 정보가 담겨있음
     + 즉, 서버가 실패했을 때 적절하게 복구할 수 있도록 만들어주는 핵심 설계 요소로, 서버가 상태 정보 없이도 요청에 응답 가능
