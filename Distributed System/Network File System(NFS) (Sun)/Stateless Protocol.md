-----
### 빠른 크래시 복구의 열쇠 : 상태를 유지하지 않음
-----
1. NFSv2가 크래시 복구라는 간단한 목표 달성을 위해 상태를 유지하지 않음(Stateless) 프로토콜 설계
   - 상태 : 서버는 각 클라이언트에서 서버에서 발생하고 있는 일에 관해 어떤 정보도 저장하지 않음
     + 예를 들어, 서버는 클라이언트가 어떤 블럭을 캐싱하고 있는지, 어떤 파일들이 열려 있는지 모르며, 또한 파일의 포인터의 현재 위치도 알지 못함
     + 즉, 서버는 클라이언트가 무엇을 하든 전혀 상관하지 않음
     + 대신에 각 요청에 필요한 모든 정보를 담아서 전송하도록 프로토콜이 설계

2. 대조적으로 상태를 유지(Stateful) 프로토콜이 존재
   - 중요한 예로 open() 시스템 콜
     + open()은 경로명이 전달되면, 파일 디스크럽터를 반환(int 타입)
     + 이 디스크럽터는 read()나 write()를 통해 파일을 읽거나 쓰는 데 사용
     + 파일 시스템은 파일 디스크럽터와 관련하여 상태를 제공하며, 여기서 가장 중요한 '상태' 정보는 입출력을 시작할 위치 (파일 오프셋)
     + read()나 write()을 호출하면 파일의 현재 오프셋으로부터 입출력을 수행하고, 해당 현재 오프셋 정보를 새로 갱신
     + 즉, 파일의 읽기 또는 쓰기와 관련된 상태를 지속적으로 갱신하는 것
<div align="center">
<img src="https://github.com/user-attachments/assets/54fa30b7-8252-4a2a-b211-9e7f7f96cccb">
</div>

   - 클라이언트 측 파일 시스템이 파일을 열기 위해 서버에게 파일 foo를 열고 해당 파일 디스크럽터를 전달 바란다는 프로토콜 메세지를 전송했다고 가정
   - 파일 서버는 로컬 저장 장치에 있는 파일을 열어 클라이언트에게 파일 디스크럽터를 전송
   - 그 뒤로 파일 서버에게 읽기 요청을 할 때, 클라이언트 파일 시스템은 전달하는 메세지에 해당 파일 디스크럽터를 포함시켜서 지금 전달하는 파일 디스크럽터가 가리키는 파일의 일정 바이트를 읽어달라고 요청
   - 이 예제의 파일 디스크럽터는 클라이언트와 서버 사이에서 공유되는 정보(Shared State)의 일부분이며, 이를 분산된 상태(Distributed State)라고 지칭
   - 클라이언트와 서버 간 상태 정보가 공유되면, 크래시 과정이 복잡해짐
     + 서버가 첫 번째 읽기를 종료한 후, 클라이언트가 두 번째 요청을 전송하기 전 서버가 크래시 되었다고 가정
     + 서버가 다시 동작하게 되면, 클라이언트는 두 번째 읽기 요청을 전송하게 되며, 여기서 문제가 발생
     + 클라이언트의 두 번째 읽기 요청이 서버에 도착했을 때, 서버는 클라이언트가 명시한 fd가 실제 어떤 파일을 가리키는지 알 수 없음
     + 파일 디스크럽터 테이블은 메모리에만 존재하는 자료구조로, 크래시와 함께 손실됨
     + 이 상황을 해결하려면 클라이언트와 서버는 어떤 형태로든 복구 프로토콜(Recovery Protocol)을 사용해야 함
     + 예를 들어, 클라이언트와 서버가 요청을 처리하는데 필요한 모든 정보를 메모리에 보관하며, 위 예제의 경우에는 클라이언트가 파일 디스크럽터 fd가 파일 foo를 가리킨다는 정보를 보관해야 함

3. 서버와 클라이언트 간 공유 상태를 유지할 경우, 서버도 클라이언트 측의 크래시를 고려해야 함
   - 예를 들어, 클라이언트가 파일을 연 후에 크래시가 되었다고 가정
   - open()은 서버의 파일 디스크럽터를 사용하였고, 이 때 서버는 일반적으로 클라이언트가 close()를 호출하면, 그 때 파일을 닫으면 됨
   - 하지만, 클라이언트가 크래시가 되면 서버는 close()를 절대로 받지 못할 것이고, 그렇기 때문에 클라이언트가 크래시되었다는 것을 서버에게 알려서 해당 파일을 닫을 수 있도록 해야함

4. 이러한 이유로 NFS 설계자들은 상태를 유지하지 않는 방식으로 사용하기로 결정
   - 상태 정보를 유지하지 않는다는 것은 클라이언트가 서버에게 파일 입출력 연산을 요청할 때, 그 때 필요한 정보를 모두 전송하는 것
   - 예를 들어, 읽을 위치 및 쓸 위치 등을 의미하는 것임
   - 서버는 다시 시작하면 되고, 클라이언트는 최악의 경우 요청을 재시도 하면 됨
