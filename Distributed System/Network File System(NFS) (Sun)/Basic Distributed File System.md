-----
### 기본적인 분산 파일 시스템
-----
1. 간단한 클라이언트 / 서버로 구성된 분산 파일 시스템
   - 클라이언트 쪽에서는 클라이언트 응용 프로그램이 클라이언트 측 파일 시스템을 통해서 파일과 디렉토리에 접근
   - 클라이언트 프로그램이 서버에 있는 파일에 접근하려면 클라이언트 측 파일 시스템에 시스템 콜(open(), read(), write(), close(), mkdir() 등) 호출
   - 분산 파일 시스템은 성능 부분을 제외한다면, 응용 프로그램 입장에서는 로컬(디스크 기반) 파일 시스템과 전혀 다르지 않음
   - 분산 파일 시스템들을 로컬 파일 시스템과 동일(Transparent)하게 접근할 수 있도록 하는 것이 목표

2. 클라이언트 측 파일 시스템의 역할을 시스템 콜을 서비스하기 위해 필요한 동작을 실행
   - 예를 들어, 만약 클라이언트가 read() 요청을 내렸다면, 클라이언트 파일 시스템은 서버 측 파일 시스템(또는, 좀 더 흔하게 파일 서버)에 메세지를 전송해서 해당 블럭을 읽도록 할 것
   - 그러면 파일 서버는 디스크(또는 자체가 갖고 있는 메모리 캐시)에서 블럭을 읽은 후 클라이언트가 요청한 데이터와 함께 메세지를 전송할 것
   - 클라이언트 파일 시스템의 read() 시스템 콜은 사용자 버퍼에 데이터를 복사하는 것으로 요청 완료
   - 클라이언트가 동일한 블럭을 read() 요청한다면, 클라이언트 측의 메모리 또는 디스크에 캐시된 이전 데이터를 전달하면 되므로, 최선의 경우 네트워크 트래픽이 발생하지 않을 수 있음
   - 물론, 다른 클라이언트가 해당 블럭을 갱신했을 경우에는 서버로부터 다시 읽어들여야 함

3. 분산 파일 시스템 구조
<div align="center">
<img src="https://github.com/user-attachments/assets/b8b881bb-4597-42c0-9338-6cc673c7dc9a">
</div>

4. 클라이언트 / 서버 기반의 분산 파일 시스템에는 두 가지 핵심적인 소프트웨어가 있어야 함
   - 클라이언트 측 파일 시스템과 파일 서버
   - 이 둘의 동작이 분산 파일 시스템의 행동을 결정

5. 참고 : 서버가 크래시 되는 이유
   - 정전이 되어 꺼질 수 있음 (따라서, 전원이 다시 복구가 되면 기계가 재시작될 것)
   - 서버들은 보통 수십만 또는 수백만 줄의 코드로 구성되어 있는데, 따라서 버그들이 존재할 수 있으므로, 서버가 크래시하게 되는 버그를 만날 수 있음
   - 서버에는 메모리 누설(Memory Leakage)이 있을 수 있는데, 아무리 작은 메모리 누설이라도 시스템의 메모리를 고갈시킬 수 있으며, 크래시가 나도록 만듬
   - 마지막으로 분산 시스템에는 서버와 클라이언트 사이 네트워크가 존재하는데, 만일 네트워크가 이상하게 동작한다면(예를 들어, 네트워크 구간이 분할(Partitioned) 되어서 클라이언트와 서버가 동작하지만 서로 통신이 안 되는 경우) 마치 원격 기계가 크래시된 것처럼 보일 수 있음 (하지만, 실제로는 네트워크를 통해 도달할 수 없을뿐임)
