-----
### 초창기 운영체제 : 단순 라이브러리
-----
1. 초창기 운영체제는 기본적으로 자주 사용되는 함수들을 모아 놓은 라이브러이에 불과 (예) 각자 저수준 입출력 처리 코드를 작성하는 것을 운영체제가 API로 제공)
2. 옛날 메인프레임 시스템에서는 프로그램을 한 번에 하나씩 실행
   - 현대 운영체제가 하는 많은 작업 (예) 작업 순서 결정 등) 컴퓨터 관리자가 담당
3. 작업들이 준비되면 컴퓨터 관리자가 일괄적으로 처리
   - 이러한 방식의 컴퓨팅을 일괄 처리 (batch)라고 부름
   - 그 당시 컴퓨터는 비용 때문에 대화 방식으로 사용되지 않음

-----
### 라이브러리를 넘어선 보호
-----
1. 컴퓨터 관리 면에서 더 중심적인 역할을 하게 됨
2. 운영체제 코드는 장치를 제어하는 역할을 함
3. Atlas 컴퓨텅 시스템에 의해 시스템 콜이라는 아이디어가 발명
   - 운영체제를 라이브러리가 아닌 특별한 하드웨어 명령어와 하드웨어 상태를 결합하여 운영체제로 전환하기 위해서는 정해진 규칙에 따라 제어 가능한 과정을 거치도록 설계

4. 시스템 콜과 프로시저 호출의 결정적 차이
   - 시스템 콜은 제어를 운영체제에 넘길 때, 하드웨어 특권 수준(Hardware Privilege Level)을 상향 조정하며, 사용자 응용 프로그램은 사용자 모드(User Mode)라고 불리는 상태에서 실행
   - 사용자 모드에서는 응용 프로그램이 할 수 있는 일을 하드웨어적으로 제한 (예) 사용자 모드에서 실행 중인 응용 프로그램은 디스크 입출력, 물리 메모리 페이지 접근 또는 네트워크 패킷 송신 등 작업등은 불가)
   - 시스템 콜은 보통 trap이라 불리는 특별한 하드웨어 명령어를 이용하여 호출
   - 시스템 콜 시작 시, 하드웨어는 미리 지정된 트랩 핸들러(Trap Handler) 함수에게 제어권을 넘기고, 특권 수준을 커널 모드(Kernel Mode)로 격상
     + 트랩 핸들러 함수는 운영체제가 미리 구현해 놓으며, 커널 모드에서 운영체제는 시스템의 하드웨어를 자유롭게 접근할 수 있으며 입출력 또는 메모리 할당 등과 같은 작업 수행 가능
     + 운영체제가 서비스를 완료하면 return-from-trap 특수 명령어를 사용하여 제어권을 다시 사용자에게 넘김
     + 이 명령어는 응용 프로그램이 출발했던 지점으로 제어권을 넘기는 동시에 사용자 모드로 다시 전환

-----
### 멀티프로그래밍 시대
-----
1. 운영체제 다운 운영체제의 실제 등장은 메인 프레임 이후 미니컴퓨터 시대에 이루어짐
2. 컴퓨터 자원의 효율적 활용을 위해 멀티프로그래밍(Multi-Programming) 기법이 대중으로 사용
   - 한 번에 하나의 프로그램만 실행시키는 대신 운영체제는 여러 작업을 메모리에 탑재하고 작업들을 빠르게 번갈아 가며 실행하여 CPU 사용률을 향상시킴
   - 입출력 장치가 느리므로 전환(Switching) 능력이 특히 중요해짐

3. 멀티프로그래밍 지원의 필요와 인터럽트를 통한 입출력 작업 처리 등이 운영체제 발전에 여러 가지 혁신을 가져옴
   - 메모리 보호와 같은 주제가 중요하게 되었으며, 한 프로그램이 다른 프로그램의 메모리에 접근하는 것을 원하지 않게 됨
   - 멀티프로그래밍에서 발생하는 병행성 문제에 대한 이해도 중요
   - 인터럽트가 발생하더라도 운영체제가 올바르게 동작하는 것을 보장해야 함

-----
### 현대
-----
1. 개인용 컴퓨터(Personal Computer, PC)의 등장
2. 초기 PC들은 미니컴퓨터 기술들에 무지했음 (예) DOS(Disk Operating System) 같은 초기 운영체제는 메모리 보호가 중요하다는 인식이 없었음)
3. 이후, 예전 미니컴퓨터 운영체제 기법들이 데스크톱 컴퓨터용 운영체제에 등장하기 시작

-----
### 참고 : UNIX
-----
1. Bell Labs의 UNIX는 서로 통합 사용 가능한 작고 강력한 프로그램이 핵심
2. 쉘(Shell) : pipes와 같은 기본 기법을 제공하여 프로그램 연결을 용이하게 해줌 (예) 텍스트 파일에서 foo 라는 단어를 포함하고 있는 행의 객체를 찾고 싶다면, grep foo file.txt | wc -l. grep과 같이 wc(Word Count) 프로그램을 이용하여 목적 달성 가능)
3. UNIX 환경은 개발자에게 친화적이며 새로운 C언어를 위한 컴파일러 제공
4. 더불어, 소스 코드를 요청한 누구에게나 무료로 배포 가능한 공개-소스 소프트웨어의 초창기 형태
5. 코드를 쉽게 접할 수 있고 가독성이 좋음
