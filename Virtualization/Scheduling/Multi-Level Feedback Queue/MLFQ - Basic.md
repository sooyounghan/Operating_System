-----
### MLFQ - 기본 규칙
-----
1. 멀티 레벨 피드백 큐는 미래를 예측하기 위해 과거의 경험을 활용하는 예로, 이러한 방식은 작업이 단계별로 진행되어 예측 가능할 때 동작
2. 여러 개의 큐로 구성되며, 각각 다른 우선 순위(Priority Level)가 배정되며, 실행 준비가 된 프로세스는 이 중 하나의 큐에 존재
3. MFLQ는 실행할 프로세스를 결정하기 위해 우선 순위를 사용하며, 높은 우선순위를 가진 작업이, 즉 높은 원순위 큐에 존재하는 작업이 선택
   - 💡 큐에 둘 이상의 작업이 존재할 수 있으며, 이들은 모두 같은 우선순위를 가지며, 이들 작업들 사이에는 라운드 로빈(Round Robin, RR) 스케줄링 알고리즘이 적용
4. MLFQ 스케줄링 핵심은 우선순위를 정하는 방식이며, MLFQ는 각 작업에 고정된 우선순위를 부여하는 것이 아닌, 각 작업 특성에 따라 동적으로 우선순위 부여
   - 예를 들어, 어떤 작업이 키보드 입력을 기다리며 반복적으로 CPU를 양보하면 MLFQ는 해당 작업의 우선 순위를 높게 유지함
   - 이러한 패턴은 대화형 프로세스가 나타내는 패턴
   - 대신에 한 작업이 긴 시간 동안 CPU를 집중적으로 사용하면 MLFQ는 해당 작업의 우선순위를 낮춤
   - MLFQ는 작업이 진행되는 동안 해당 작업의 정보를 얻고, 이 정보를 이용해 미래 행동을 예측

5. 두 가지 기본 규칙
   - 규칙 1 : Priority(A) > Priority(B)이면, A가 실행 (B는 실행되지 않음)
   - 규칙 2 : Priority(A) = Priority(B)이면, A와 B는 RR 방식으로 실행

6. 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/ccda3790-d675-487e-9a16-d3c86da111d9">
</div>

   - 두 작업 A, B가 가장 높은 우선순위에 위치하고, C는 중간, D는 가장 낮은 우선순위 큐에 존재
   - MLFQ 동작을 고려하면 A와 B는 번갈아 실행할 것이며, C와 D는 실행되지 않음

-----
### 우선순위의 변경
-----
1. MLFQ가 작업의 우선순위를 변경하는 방법 (이는 작업이 존재할 큐를 결정하는 것과 마찬가지임)
   - 이를 위해서는 워크로드 특성을 반영해야 함
   - 짧은 실행 시간을 갖는 CPU를 자주 양보하는 대화형 작업과 많은 CPU 시간을 요구하지만 응답 시간은 중요하지 않은 긴 실행 시간의 CPU 위주 작업이 혼재
  
2. 규칙
   - 규칙 3 : 작업이 시스템에 진입하면, 가장 높은 우선순위, 즉 맨 위의 큐에 놓여짐
   - 규칙 4a : 주어진 타임 슬라이스를 모두 사용하면 우선순위는 낮아짐 (즉, 한 단계 아래 큐로 이동)
   - 규칙 4b : 타임 슬라이스를 소진하기 전에 CPU를 양도하면 같은 우선순위를 유지

3. 예시 1) 한 개의 긴 실행 시간을 가진 작업
<div align="center">
<img src="https://github.com/user-attachments/assets/9b7c4770-a416-4d1e-bf2a-26b396809f52">
</div>

   - 세 개의 큐로 이루어진 스케줄러에서 시간이 지남에 따라 작업의 우선순위 변함을 보여줌
   - 작업은 최고 우선순위로 먼저 진입(Q2)
   - 10 msec 타입 슬라이스가 하나 지나면 스케줄러는 작업의 우선순위를 한 단계 낮추어 해당 작업을 Q1로 이동
   - 다시 하나의 타임 슬라이스 동안 Q1에서 실행한 후 작업은 마침내 가장 낮은 우선순위를 가지게 되고 Q0으로 이동되어, 이후 계속 머무르게 됨

4. 예시 2) 짧은 작업과 함께 진행
<div align="center">
<img src="https://github.com/user-attachments/assets/c206ee8a-0916-4647-970b-3c231e9602f1">
</div>

   - 2개의 작업이 존재 : A는 오래 실행되는 CPU 위주 작업, B는 짧은 대화형 직업
   - A는 얼마 동안 이미 실행해온 상태, B는 이제 도착했다고 가정
   - 다른 오래 실행되는 CPU 위주 작업들처럼 A(검정색)은 가장 낮은 우선순위 큐에서 실행
   - B(회색)는 T = 100에 시스템에 도착하고 가장 높은 우선순위 큐에 놓여짐
     + 실행 시간이 짧기 때문에 (20 ms) 두 번의 타임 슬라이스를 소모하면 B는 바닥의 큐에 도착하기 전에 종료
   - A는 이후 가장 낮은 우선순위에서 실행을 재개
   - 결론 : 스케줄러는 작업이 짧은 작업인지, 긴 작업인지 알 수 없으므로 일단 짧은 작업으로 가정하여 높은 우선순위를 부여하며, 짧은 작업이라면 빨리 실행되고 바로 종료될 것이며, 아니라면, 천천히 아래 큐로 이동하게 되고 스스로 긴 배치형 작업이라는 것을 증명함으로서 MLFQ가 SJF에 근사하게 됨

5. 예시 3) 입출력 작업
   - 프로세스가 타임 슬라이스를 소진하기 전에 프로세서에게 양도하면 같은 우선순위를 유지 : 대화형 작업이 키보드나 마우스로부터 사용자 입력을 대기하며 자주 입출력을 수행하면 타임 슬라이스가 종료되기 전에 CPU를 양도하게 될 것이므로, 동일한 우선순위를 유지
<div align="center">
<img src="https://github.com/user-attachments/assets/0b134243-7f73-4bdd-a458-09a1e4b2a344">
</div>

   - B(회색)는 대화형 작업으로서 입출력을 수행하기 전 1 msec 동안만 실행
   - A(검정색)는 긴 배치형 작업으로 B와 CPU를 사용하기 위해
   - B는 CPU를 계속해서 양도하므로 MLFQ 방식은 B를 가장 높은 우선순위로 유지
   - B가 대화형 작업이라면 MLFQ는 대화형 작업을 빨리 실행시킨다는 목표에 접근 가능

-----
### 현재 MLFQ의 문제점
-----
1. 현재 MLFQ는 CPU를 긴 작업들과 짧은 작업들 사이에서 잘 공유하고, 입출력 중점 대화형 작업을 빨리 실행시키기 때문에 잘 동작하는 것처럼 보임
2. 문제점
   - 기아 상태(Starvation) 발생 가능 : 시스템에 너무 많은 대화형 작업이 존재하면 그들이 모든 CPU 시간을 소모하게 될 것이며, 따라서 긴 실행 시간 작업은 CPU 시간을 할당받지 못함
   - 스케줄러를 자신에게 유리하게 동작하도록 프로그램 작성 가능 : 즉, 스케줄러를 속여서 지정된 몫보다 더 많은 시간을 할당하도록 하게 만들 수 있음
     + 타임 슬라이스가 끝나기 전 아무 파일 대상으로 입출력 요청을 내려 CPU를 양도
     + 같은 큐에 머무를 수 있게 되며, 따라서 더 높은 퍼센트의 CPU 시간을 얻게 됨
   - 프로그램은 시간 흐름에 따라 특성이 변할 수 있음 : CPU 위주 작업이 대화형 작업으로 변경될 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/1be9f100-eb25-4093-b8d1-858c9a82f260">
</div>
