-----
### MLFQ - 기본 규칙
-----
1. 멀티 레벨 피드백 큐는 미래를 예측하기 위해 과거의 경험을 활용하는 예로, 이러한 방식은 작업이 단계별로 진행되어 예측 가능할 때 동작
2. 여러 개의 큐로 구성되며, 각각 다른 우선 순위(Priority Level)가 배정되며, 실행 준비가 된 프로세스는 이 중 하나의 큐에 존재
3. MFLQ는 실행할 프로세스를 결정하기 위해 우선 순위를 사용하며, 높은 우선순위를 가진 작업이, 즉 높은 원순위 큐에 존재하는 작업이 선택
   - 💡 큐에 둘 이상의 작업이 존재할 수 있으며, 이들은 모두 같은 우선순위를 가지며, 이들 작업들 사이에는 라운드 로빈(Round Robin, RR) 스케줄링 알고리즘이 적용
4. MLFQ 스케줄링 핵심은 우선순위를 정하는 방식이며, MLFQ는 각 작업에 고정된 우선순위를 부여하는 것이 아닌, 각 작업 특성에 따라 동적으로 우선순위 부여
   - 예를 들어, 어떤 작업이 키보드 입력을 기다리며 반복적으로 CPU를 양보하면 MLFQ는 해당 작업의 우선 순위를 높게 유지함
   - 이러한 패턴은 대화형 프로세스가 나타내는 패턴
   - 대신에 한 작업이 긴 시간 동안 CPU를 집중적으로 사용하면 MLFQ는 해당 작업의 우선순위를 낮춤
   - MLFQ는 작업이 진행되는 동안 해당 작업의 정보를 얻고, 이 정보를 이용해 미래 행동을 예측

5. 두 가지 기본 규칙
   - 규칙 1 : Priority(A) > Priority(B)이면, A가 실행 (B는 실행되지 않음)
   - 규칙 2 : Priority(A) = Priority(B)이면, A와 B는 RR 방식으로 실행

6. 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/ccda3790-d675-487e-9a16-d3c86da111d9">
</div>

   - 두 작업 A, B가 가장 높은 우선순위에 위치하고, C는 중간, D는 가장 낮은 우선순위 큐에 존재
   - MLFQ 동작을 고려하면 A와 B는 번갈아 실행할 것이며, C와 D는 실행되지 않음

-----
### 우선순위의 변경
-----
1. MLFQ가 작업의 우선순위를 변경하는 방법 (이는 작업이 존재할 큐를 결정하는 것과 마찬가지임)
   - 이를 위해서는 워크로드 특성을 반영해야 함
   - 짧은 실행 시간을 갖는 CPU를 자주 양보하는 대화형 작업과 많은 CPU 시간을 요구하지만 응답 시간은 중요하지 않은 긴 실행 시간의 CPU 위주 작업이 혼재
  
2. 규칙
   - 규칙 3 : 작업이 시스템에 진입하면, 가장 높은 우선순위, 즉 맨 위의 큐에 놓여짐
   - 규칙 4a : 주어진 타임 슬라이스를 모두 사용하면 우선순위는 낮아짐 (즉, 한 단계 아래 큐로 이동)
   - 규칙 4b : 타임 슬라이스를 소진하기 전에 CPU를 양도하면 같은 우선순위를 유지

3. 예시 1) 한 개의 긴 실행 시간을 가진 작업
<div align="center">
<img src="https://github.com/user-attachments/assets/9b7c4770-a416-4d1e-bf2a-26b396809f52">
</div>

   - 세 개의 큐로 이루어진 스케줄러에서 시간이 지남에 따라 작업의 우선순위 변함을 보여줌
   - 작업은 최고 우선순위로 먼저 진입(Q2)
   - 10 msec 타입 슬라이스가 하나 지나면 스케줄러는 작업의 우선순위를 한 단계 낮추어 해당 작업을 Q1로 이동
   - 다시 하나의 타임 슬라이스 동안 Q1에서 실행한 후 작업은 마침내 가장 낮은 우선순위를 가지게 되고 Q0으로 이동되어, 이후 계속 머무르게 됨

4. 예시 2) 짧은 작업과 함께 진행
<div align="center">
<img src="https://github.com/user-attachments/assets/c206ee8a-0916-4647-970b-3c231e9602f1">
</div>

   - 2개의 작업이 존재 : A는 오래 실행되는 CPU 위주 작업, B는 짧은 대화형 직업
   - A는 얼마 동안 이미 실행해온 상태, B는 이제 도착했다고 가정
   - 다른 오래 실행되는 CPU 위주 작업들처럼 A(검정색)은 가장 낮은 우선순위 큐에서 실행
   - B(회색)는 T = 100에 시스템에 도착하고 가장 높은 우선순위 큐에 놓여짐
     + 실행 시간이 짧기 때문에 (20 ms) 두 번의 타임 슬라이스를 소모하면 B는 바닥의 큐에 도착하기 전에 종료
   - A는 이후 가장 낮은 우선순위에서 실행을 재개
   - 결론 : 스케줄러는 작업이 짧은 작업인지, 긴 작업인지 알 수 없으므로 일단 짧은 작업으로 가정하여 높은 우선순위를 부여하며, 짧은 작업이라면 빨리 실행되고 바로 종료될 것이며, 아니라면, 천천히 아래 큐로 이동하게 되고 스스로 긴 배치형 작업이라는 것을 증명함으로서 MLFQ가 SJF에 근사하게 됨

5. 예시 3) 입출력 작업
   - 프로세스가 타임 슬라이스를 소진하기 전에 프로세서에게 양도하면 같은 우선순위를 유지 : 대화형 작업이 키보드나 마우스로부터 사용자 입력을 대기하며 자주 입출력을 수행하면 타임 슬라이스가 종료되기 전에 CPU를 양도하게 될 것이므로, 동일한 우선순위를 유지
<div align="center">
<img src="https://github.com/user-attachments/assets/0b134243-7f73-4bdd-a458-09a1e4b2a344">
</div>

   - B(회색)는 대화형 작업으로서 입출력을 수행하기 전 1 msec 동안만 실행
   - A(검정색)는 긴 배치형 작업으로 B와 CPU를 사용하기 위해
   - B는 CPU를 계속해서 양도하므로 MLFQ 방식은 B를 가장 높은 우선순위로 유지
   - B가 대화형 작업이라면 MLFQ는 대화형 작업을 빨리 실행시킨다는 목표에 접근 가능

-----
### 현재 MLFQ의 문제점
-----
1. 현재 MLFQ는 CPU를 긴 작업들과 짧은 작업들 사이에서 잘 공유하고, 입출력 중점 대화형 작업을 빨리 실행시키기 때문에 잘 동작하는 것처럼 보임
2. 문제점
   - 기아 상태(Starvation) 발생 가능 : 시스템에 너무 많은 대화형 작업이 존재하면 그들이 모든 CPU 시간을 소모하게 될 것이며, 따라서 긴 실행 시간 작업은 CPU 시간을 할당받지 못함
   - 스케줄러를 자신에게 유리하게 동작하도록 프로그램 작성 가능 : 즉, 스케줄러를 속여서 지정된 몫보다 더 많은 시간을 할당하도록 하게 만들 수 있음
     + 타임 슬라이스가 끝나기 전 아무 파일 대상으로 입출력 요청을 내려 CPU를 양도
     + 같은 큐에 머무를 수 있게 되며, 따라서 더 높은 퍼센트의 CPU 시간을 얻게 됨
   - 프로그램은 시간 흐름에 따라 특성이 변할 수 있음 : CPU 위주 작업이 대화형 작업으로 변경될 수 있음

-----
### 우선순위 상향 조정
-----
1. 기아 문제 해결 방법 : 주기적으로 모든 작업의 우선순위를 상향 조정(Boost)하는 것 (즉, 최상위 큐로 보내는 것)
   - 규칙 5 : 일정 기간 S가 지나면, 시스템의 모든 작업을 최상위 큐로 이동

2. 두 가지 문제를 한 번에 해결
   - 프로세스는 굶지 않는다는 것을 보장 : 최상위 큐에 존재하는 동안 작업은 다른 높은 우선순위 작업들과 라운드 로빈 방식으로 CPU를 공유하게 되고 서비스를 받게 됨
   - CPU 위주 작업이 대화형 작업으로 변하더라도, 우선 순위 상향을 통해 스케줄러가 변경된 특성에 적합한 스케줄링 방법 적용

3. 예시) 긴 실행 시간을 가진 작업이 두 개의 대화형 작업과 CPU를 두고 경쟁할 때의 시나리오
<div align="center">
<img src="https://github.com/user-attachments/assets/1be9f100-eb25-4093-b8d1-858c9a82f260">
</div>

   - 우선순위 상향이 없는 경우 : 긴 실행 시간 작업은 두 개의 짧은 작업 도착 후 굶게 됨
   - 우선순위 상향이 있는 경우 (50 msec 마다 발생)

4. S값 (부두 상수(Voo-doo Constant))
   - S값의 결정이 중요한데, 이는 부두 상수라고 함
   - 정확하게 결정하기 위해서는 흑마술이 필요한 것처럼 보이기 때문에 붙여진 것이며, 너무 크면 긴 실행 시간을 가진 작업은 굶을 수 있으며, 너무 작으면 대화형 작업이 적절한 CPU 시간을 사용할 수 없음

-----
### 더 나은 시간 측정
-----
1. 스케줄러를 자신에게 유리하게 동작시키는 것을 막는 방법 : 타임 슬라이스가 끝나기 전 CPU를 양보하여 우선 순위가 유지하다는 규칙을 변경
2. MLFQ의 각 단계에서 CPU 총 사용 시간을 측정
   - 스케줄러는 현재 단계에서 프로세스가 소진한 CPU 사용 시간을 저장
   - 프로세스가 타임 슬라이스에 해당하는 시간을 모두 소진하면, 다음 우선순위 큐로 강등되며, 타임 슬라이스를 한 번에 소진하든 짧게 여러 번 소진하든 상관 없음
   - 규칙 4의 재정의 : 주어진 단계에서 시간 할당량을 소진하면(CPU를 몇 번 양도하였는지 상관없이), 우선순위는 낮아짐(즉, 아래 단계 큐로 이동)

3. 예시) 워크로드가 스케줄러를 자신에게 유리하게 동작시키려고 할 때, 예전 규칙 4a와 4b일 때 행동과 새로운 조작 방지 규칙 4일 때 행동 양식
<div align="center">
<img src="https://github.com/user-attachments/assets/675e28ae-3909-45c5-8534-39417361718f">
</div>

   - 방지책이 없다면, 프로세스는 타임 슬라이스가 끝나기 전 입출력 명령어를 내릴 수 있어서 CPU 시간을 독점 가능
   - 방지책이 마련되면, 프로세스 입출력 행동과 무관하게 아래 단계 큐로 천천히 이동시켜 CPU를 자기 몫 이상으로 사용할 수 없게 됨

-----
### MLFQ 조정과 다른 쟁점들
-----
1. 필요한 변수들을 스케줄러가 어떻게 설정해야 할 것인가?
   - 몇 개의 큐가 존재해야 하는가?
   - 큐 당 타임 슬라이스의 크기는 얼마로 해야 하는가?
   - 기아를 피하고 변화된 행동을 반영하기 위하여 얼마나 자주 우선순위가 상향 조정되어야 하는가?

2. 예를 들어, 대부분의 MLFQ 기법들은 큐 별로 타임 슬라이스를 변경할 수 있음
   - 우선순위가 높은 큐는 보통 짧은 타임 슬라이스(예) 10 msec 이하)가 주어짐
   - 이 큐는 대화형 작업으로 구성되고, 결국 이 작업들을 빠르게 교체하는 것은 의미가 있음
   - 낮은 우선순위는 반대로 CPU-중심의 오래 실행되는 작업을 포함하므로, 긴 타임 슬라이스(예) 수백 msec)가 적당
<div align="center">
<img src="https://github.com/user-attachments/assets/9ba4dd11-d6a1-4225-9e5d-703c716bf400">
</div>

   - 가장 높은 우선순위 큐는 10 ms, 중간 큐는 20 ms, 가장 낮은 큐는 40 ms의 스케줄러에서 두 개의 작업이 실행되는 모양을 보여줌

3. Solaris의 MLFQ 구현, 시분할 스케줄링 클래스 또는 TS는 설정이 특히 쉬움
   - 프로세스의 우선순위가 일생 동안 어떻게 변하는지, 타임 슬라이스의 길이는 얼마인지, 작업의 우선순위는 얼마나 자주 상향되는지 결정하는 테이블 제공
   - 관리자는 이 테이블을 수정하여 스케줄러의 동작 방식을 바꿀 수 있음
   - 테이블의 기본 값은 큐의 개수는 60, 각 큐의 타임 슬라이스 크기는 가장 높은 우선순위 큐가 20 msec에서 가장 낮은 우선순위 큐가 수백 msec까지 천천히 증가하고, 우선순위 상향 조정은 1초 정도마다 일어남

4. 다른 MLFQ 스케줄러는 테이블이나 규칙 등을 사용하지 않으며, 수학 공식을 이용해 우선순위 조정
5. 스케줄러들은 다른 여러 기능을 제공
   - 예를 들어, 일부 스케줄러의 경우 높은 우선순위를 운영체제 작업을 위해 예약
   - 일반적인 사용자 작업은 시스템 내 가장 높은 우선순위를 얻을 수 없음
   - 일부 시스템은 사용자가 우선순위를 정할 수 있도록 도움을 주는 것을 허용 (예) 명령어 라인 도구인 nice를 이용해 작업의 우선순위를 높이거나 낮출 수 있으며, 작업의 실행 순서를 바꿀 수 있음)
   
