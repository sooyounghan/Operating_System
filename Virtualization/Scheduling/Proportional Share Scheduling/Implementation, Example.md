-----
### 구현
-----
1. 추첨 스케줄링의 가장 큰 장점은 구현이 단순하다는 점
   - 필요한 것은 난수 발생기와 프로세스들의 집합을 표현하는 자료 구조(예) 리스트), 추첨권의 전체 개수 뿐임
   - 리스트를 사용하여 프로세스를 관리한다고 가정 : A, B 및 C 세 개의 프로세스로 구성되고 각자 몇 장의 추첨권을 가짐
<div align="center">
<img src="https://github.com/user-attachments/assets/e5f3681f-93c3-4f7d-980f-2fe1b85bfdd0">
</div>

   - 스케줄을 결정하기 위해 먼저 총 추첨권의 개수 400개 중에서 한 숫자를 선택해야 하는데, 300이 선택되었다고 가정 : 리스트를 순회하며 카운터 값을 이용해 당첨차를 찾아냄
<div align="center">
<img src="https://github.com/user-attachments/assets/ea0f68bd-1087-41f8-8fb8-50a695786fc0">
</div>

2. 프로세스는 리스트를 순회하면서 counter 값이 winner의 값을 초과할 때까지 각 추첨권 개수를 counter에 더함
   - 값이 초과하게 되면 리스트의 현재 원소가 당첨자가 됨
   - 당첨 번호가 300인 예에서의 진행 방식
     + 먼저 A의 추첨권 개수가 더해져서 counter의 값이 100으로 증가
     + 100은 300보다 작기 때문에 계속 루프 실행
     + 다음 counter는 150(B의 당첨권 개수)으로 갱신되고, 아직 300보다 작으므로, 다시 순회를 계속함
     + 마침내 counter는 400(300보다 큼)으로 갱신되고 루프를 빠져나오게 되며, current는 프로세스 C(당첨자)를 가리키게 됨

3. 일반적으로 리스트를 내림차순으로 정렬하면 이 과정이 가장 효율적
   - 정렬 순서는 알고리즘의 정확성에 영향을 주지 않지만, 리스트를 정렬해 놓으면 검색 횟수가 최소화되는 것을 보장
   - 특히, 적은 수의 프로세스가 대부분의 추첨권을 소유하고 있는 경우에 효과적

-----
### 예제
-----
1. 추첨 스케줄링 동작을 쉽게 이해하기 위해서 CPU를 공유하는 두 개의 작업을 수행하는 시간 확인
   - 각 프로세스는 같은 개수의 추첨권(100)을 가지고 있으며 동일한 실행 시간을 가짐 (R 값은 변경할 수 있음)

2. 두 작업을 거의 동시에 종료시키고자 함
   - 하지만, 추첨 스케줄링의 무작위성 때문에 한 작업이 다른 작업보다 먼저 종료될 수 있으며, 이 차이를 정량화하기 위해 간단한 불공정 지표(Unfairness Metric)인 U를 정의
   - U는 첫 번째 작업이 종료된 시간을 두 번쨰 작업이 종료된 시간으로 나눈 값임
     + 예를 들어, R = 10, 첫 번째 작업 시간이 10에 종료되었을 때 (그리고 두 번째 작업은 20에서 종료), U = 10 / 20 = 0.5
     + 두 작업이 거의 동시에 종료하면 U = 1에 근접해짐
     + 완벽한 공정 스케줄러에서는 U = 1를 얻게 됨

3. 평균적인 불공정 정도
<div align="center">
<img src="https://github.com/user-attachments/assets/804df795-0e89-4bdd-961f-18bf911e9ebc">
</div>

   - 두 작업 수행 시간은 1에서 1000까지 변경시켰으며 30번씩 실행
   - 작업 길이가 길지 않으면, 평균 불공정 정도는 심각하지만, 작업이 충분한 기간 동안 실행되면 추첨 스케줄러는 원하는 결과에 도달

-----
### 추첨권 배분 방식
-----
1. 추첨권을 작업에게 나누어주는 방식에 대해서 한 가지 접근 방식은 사용자가 가장 잘 알고 있다고 가정하여, 각 사용자가 추첨권을 나누어준 후 사용자가 알아서 실행시키고자 하는 작업들에게 추첨권을 배분해주는 것
2. 하지만 이는 해결책이 아니며, 어떤 일을 해야하는지 전혀 제시하지 않으므로, 미해결된 상태
