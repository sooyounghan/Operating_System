-----
### 입출력 연산의 고려
-----
1. 모든 프로그램은 입출력 작업을 수행한다고 가정
   - 이 경우, 스케줄러는 다음에 어떤 작업을 실행할지 결정해야 하며, 현재 실행 중인 작업은 입출력이 완료될 때까지 CPU를 사용하지 않을 것임
   - 입출력 요청을 발생시킨 작업은 입출력 완료를 기다리며, 대기 상태가 됨
   - 입출력이 하드 디스크 드라이브에 보내진 경우, 프로세스는 드라이브의 현재 입출력 워크로드에 따라 몇 초 또는 좀 더 긴 시간동안 블록될 것이며, 스케줄러는 그 시간 동안 실행될 다른 작업을 스케줄해야 함

2. 마찬가지로, 스케줄러는 입출력 완료 시에도 의사 결정을 해야 함
   - 입출력이 완료되면, 인터럽트가 발생하고 운영체제가 실행되어 입출력을 요청한 프로세스를 대기 상태에서 준비 상태로 다시 이동시킴
   - 물론, 인터럽트가 발생했을 때 요청 프로세스를 즉시 실행시키고 결정할 수 있음
  
3. 예시) 두 개의 작업 A, B가 존재하며, 각 작업은 50 msec CPU 시간을 필요로 함 (단, A는 10 mesc 동안 실행된 후, 입출력 요청을 하며 (입출력 시간 : 10 msec이라고 가정), B는 입출력을 수행하지 않음)
   - 스케줄러는 A를 먼저 실행시키고, B를 다음에 실행시킴
<div align="center">
<img src="https://github.com/user-attachments/assets/c68001b2-37c1-4569-9cba-1735fec4e81f">
</div>

   - STCF 스케줄러 구축한다고 가정
     + A가 5개의 10 msec 작업으로 분할되는 반면, B는 하나의 50 msec의 CPU를 요청하는 방법 : 입출력을 고려하지 않고, 작업을 하나씩 실행하는 것은 의미가 없음
   - 일반적인 접근 방식 : A의 각 10 msec 하위 작업을 독립적인 작업으로 다루는 것
     + 즉, 시스템이 시작할 때 10 msec 작업들과 50 msec를 스케줄하는 것
     + STCF의 경우 : 가장 짧은 작업을 선택하므로, A를 선택하고, A의 첫 번째 소 작업이 완료되면 B만 남게 되어 실행을 시작
     + A의 다음 작업이 제출되고, B를 선점하여 10 msec 동안 실행
     + 이렇게 하면, 프로세스의 입출력이 끝나기를 기다리는 동안 CPU는 다른 프로세스에 의해 사용되어 연산 중첩이 가능하게 되어, 시스템은 좀 더 활용 가능
<div align="center">
<img src="https://github.com/user-attachments/assets/ecdc17d7-82cc-4d76-b7ad-3f91db0134ad">
</div>

4. 입출력을 고려한 스케줄링은 각 CPU 버스트를 하나의 작업으로 간주함으로써 스케줄러는 대화형 프로세스가 더 자주, 즉, 유리하게 실행되는 것을 보장
   - 이러한 대화형 작업이 입출력을 실행하는 동안 다른 CPU-집중 작업들이 실행되고 CPU 이용률이 더 높아짐

5. 참고 : 스케줄러가 각 작업의 실행 시간을 알고 있다는 가정으로 진행
   - 범용 운영체제에서는 작업의 길이에 대해 알 수 없음
