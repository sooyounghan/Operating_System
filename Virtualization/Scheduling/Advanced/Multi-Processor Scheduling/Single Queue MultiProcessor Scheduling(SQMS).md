-----
### 단일 큐 스케줄링 (Single Queue MultiProcessor Scheduling(SQMS))
-----
1. 가장 기본적인 방식으로 단일 프로세서 스케줄링의 기본 프레임워크를 그대로 사용
2. 기존 정책을 다수 CPU에 동작하도록 하는데 많은 변경이 필요하지 않음
3. 단점
   - 확장성(Scalability) 결여
     + 스케줄러가 다수의 CPU를 제대로 동작하기 위해 코드에 일정 형태의 락을 삽입해야 함
     + 락은 SQMS 코드가 단일 큐에 접근할 때 (즉, 실행 시킬 다음 작업을 찾을 때) 올바른 결과가 나오게 하지만, 락은 성능을 크게 저하시킬 수 있으며, 시스템의 CPU 개수가 증가할 수록 더욱 심해짐
     + 단일 락에 대한 경쟁이 증가할수록 시스템은 락에 점점 많은 시간을 소모하게 되어, 실제 필요한 일에 쓰는 시간은 줄어듬

    - 캐시 친화성
      + 예를 들어, 실행할 5개의 작업이 있고 (A, B, C, D, E), 4개의 프로세서가 있다고 가정할 때, 스케줄링 큐는 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/ac1a874c-e160-4c0d-a577-82ed89f56f25">
</div>

   + 시간이 흐르면서 각 작업은 주어진 타임 슬라이스 동안 실행되고, 다음 작업이 선택되었다고 가정하면 작업 스케줄은 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/75377263-e91f-4df2-a2b3-30d53362a7e1">
</div>

   + 각 CPU는 공유 큐에서 다음 작업을 선택하기 때문에 CPU를 옮게 다니게 되며, 캐시 친화성 관점에서는 잘못된 선택을 하는 것
   + 이 문제 해결을 위해 대부분 SQMS 스케줄러는 가능한 한 프로세스를 동일한 CPU에서 재실행할 수 있도록 시도
   + 구체적으로, 특정 작업들에 대해 캐시 친화성을 고려하여 스케줄링하고 다른 작업들은 오버헤드를 균등하게 하기 위해 분산시키는 정책 사용
   + 예를 들어, 다음과 같은 동일한 5개의 작업에 대해 생각
<div align="center">
<img src="https://github.com/user-attachments/assets/cb91aa4b-e4fe-4c1d-a621-d24b210d1c98">
</div>

   + A와 D까지 작업은 각 자신의 프로세서에서 실행되며, 오직 E만이 하나의 프로세서에서 다른 프로세서로 이동
   + 대부분의 작업에게 친화성을 보존하고 있으며, 다음에는 다른 작업을 이동시켜서 일종의 친화성에 대한 형평성도 추구할 수 있지만, 구현이 복잡해질 수 있음

