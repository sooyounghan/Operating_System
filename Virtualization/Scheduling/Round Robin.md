-----
### 라운드 로빈
-----
1. 응답 시간 문제 해결을 위해 등장한 스케줄링 알고리즘
2. RR은 작업이 끝날 때까지 기다리지 않으며, 대신 일정 시간 동안 실행한 후 실행 큐의 다음 작업으로 전환
   - 이 때, 작업이 실행되는 일정 시간을 타임 슬라이스(Time Slice) 또는 스케줄링 퀀텀(Scheduling Quantum)이라 부르며, 작업이 완료될 때까지 이런식으로 계속 진행
   - 이러한 이유로 RR은 때때로 타임 슬라이싱이라 불림
   - 타임 슬라이스 길이는 타이머 인터럽트 주기의 배수 (예) 타이머가 10 msec 마다 인터럽트를 발생시키면, 타임 슬라이스는 10, 20 등 10 msec의 배수가 될 수 있음)

3. 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/a10bf3c5-00c3-4ae0-aeb8-5a9739667b8a">
</div>

   - 3개의 작업 A, B, C가 시스템에 동시에 도착하고, 각각 5초 간 실행된다고 가정
   - SJF 스케줄러는 다른 작업을 실행하기 전 각 작업을 종료할 때까지 실행 (평균 응답 시간 : (0 + 5 + 10) / 3 = 5)
   - RR은 1초의 타임 슬라이스를 가지며, 작업을 바르게 순환 (평균 응답 시간 : (0 + 1 + 2) / 3 = 1)

4. 💡 타임 슬라이스 길이는 RR에게 매우 중요하며, 타임 슬라이스가 짧을 수록 응답 시간 기준으로 RR 성능이 더 좋아짐
   - 그러나 타임 슬라이스를 너무 짧게 지정하면 문제가 발생 : 문맥 교환 비용이 전체 성능에 큰 영향을 미치게 되며, 시스템 설계자는 시스템이 최적 상태로 동작할 수 있도록 타임 슬라이스의 길이를 결정해야 함
   - 즉, 문맥 교환 비용을 상쇄할 수 있을 만큼 길어야 하지만, 응답 시간이 너무 길어지면 안됨
     + 상쇄 기술은 어떤 연산에 고정 비용이 존재하는 시스템에서 흔히 사용되며, 그 비용이 적은 횟수로 발생하게 하여, 즉 해당 연산을 적게 실행함으로써 시스템 전체 비용이 감소 (예를 들어, 타임 슬라이스는 10 msec로 설정되고 문맥 교환 비용은 1 msec라면 대강 10% 시간이 문맥 교환에 사용되므로 낭비, 하지만 타임 슬라이스를 100 msec로 늘리면 문맥 교환에 1% 미만 시간이 소모되고 타임 슬라이싱 비용이 상쇄)

5. 적당한 길이의 응답 시간이 유일한 평가 기준일 경우 타임 슬라이스를 가진 RR은 매우 훌륭한 스케줄링
   - 반환 시간 기준으로는, A, B, C는 각 작업 간 5초간 실행되고, 동시에 도착하고, RR은 1초의 타임 슬라이스를 가짐
   - A는 13, B는 14, C는 15에 종료하고 평균 14의 반환 시간을 보이므로 매우 안 좋음

6. 반환 시간이 유일한 측정 기준인 경우 RR이 최악의 정책임
   - RR은 각 작업을 잠깐 실행하고 다음 작업으로 넘거가고, 가능한 한 각 작업을 늘리는 것이 목표
   - 반환 시간은 작업 완료 시간만을 고려하므로, RR은 최악이며, 많은 경우 단순한 FIFO보다도 성능이 좋지 않게 됨

7. 즉, RR과 같은 공정한 정책, 즉 작은 시간 단위로 모든 프로세스에게 CPU를 분배하는 정책은 반환 시간과 같은 평가 기준에서 성능이 나쁨
   - 불공정하게 한다면, 하나의 작업을 끝까지 실행하고 종료할 수 있지만, 나머지 작업들에 대한 응답 시간은 포기해야 함
   - 반대로, 공정성을 더 중히 여긴다면 응답 시간은 줄어들지만, 반환 시간은 나빠지게 됨
