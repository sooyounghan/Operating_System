-----
### 제한된 연산
-----
1. 직접 실행의 장점은 빠르게 실행된다는 것
   - 기본적으로 프로그램이 하드웨어 CPU에서 실행됨
   - 하지만, 프로세스가 특수한 종류의 연산을 수행하길 원하거나 이러한 연산에는 디스크 입출력 요청이나 CPU 또는 메모리 같은 시스템 자원에 추가 할당 요청 등이 포함됨
   - 프로세스가 원하는 대로 할 수 있게 방치하는 방안도 존재하지만, 이 방은 바람직한 시스템을 구축하는데 방해요인
     + 예) 파일에 대한 접근을 허용하기 전 접근 권한을 검사하는 파일 시스템을 구현하는 예시
       * 프로세스가 디스크에 대하여 입출력하는 것을 제한하지 않으면, 프로세스는 전체 디스크를 읽고 쓸 수 있기 때문에 접근 권한을 검사하는 기능은 아무런 의미가 없음

2. 사용자 모드(User Mode)와 커널 모드(Kernel Mode)
   - 사용자 모드 : 실행되는 코드는 할 수 있는 일이 제한 (예) 프로세스가 사용자 모드에서 실행 중이면 입출력 요청을 할 수 없도록 설정하며, 입출력 요청을 하면 프로세서가 예외를 발생시키고, 운영체제는 해당 프로세스를 제거)
     + 즉, 응용 프로그램은 하드웨어 자원에 대한 접근 권한이 일부 제한되어 있음
   - 커널 모드 : 사용자 모드와 대비되는 모드로서 운영체제의 중요한 코드들이 실행되며, 이 모드에서 실행되는 코드는 모든 특수한 명령어를 포함하여 원하는 모든 작업을 수행할 수 있음
     + 운영체제는 따라서 커널 모드를 통해 컴퓨터의 모든 자원에 대한 접근 권한을 가짐
   - 이를 위해 커널 모드로 진입하기 위한 trap 명령어와 사용자 모드로 돌아가기 위한 return-from-trap 명령어가 제공되며, 운영체제가 하드웨어에게 트랩 테이블(Trap Table)의 메모리 주소를 알려주기 위한 명령어도 함께 제공
   - 또한, 사용자 프로세스가 디스크를 읽기와 같은 특권 명령어를 실행해야 할때, 제한 작업의 실행을 허용하기 위해 사용자 프로세스에게 시스템 콜을 제공 (즉, 커널은 시스템 콜을 통하여 자신의 주요 기능을 사용자 프로그램에게 제공하며, 파일 시스템 접근 / 프로세스 생성 및 제거 / 다른 프로세스와의 통신 및 메모리 할당 등 포함)
   - 대부분의 운영체제는 수백 개의 시스템 콜을 제공
     + 시스템 콜을 실행하기 위해 프로그램은 trap 특수 명령어를 실행해야 하며, 이 명령어는 커널 안으로 분기하는 동시에 특권 수준을 커널 모드로 상향 조정
     + 커널 모드로 진입하면 운영체제는 모든 명령어를 실행할 수 있고, 이를 통하여 프로세스가 요청한 작업을 처리할 수 있음
     + 완료가 되면 운영체제는 return-from-trap 특수 명령어를 호출해, 특권 수준을 사용자 모드로 다시 하향 조정하면서 호출한 사용자 프로그램으로 리턴
     + 하드웨어는 trap 명령어를 수행할 때, 호출한 프로세스의 필요한 레지스터들을 저장해야 하는데, 이는 운영체제가 retrun-from-trap 명령어 실행 시 사용자 프로세스로 제대로 리턴하기 위함
     + 예를 들어, x86에서 프로그램, 카운터, 플래그와 다른 몇 개의 레지스터를 각 프로세스의 커널 스택(Kernel Stack)에 저장하며, return-from-trap 명령어가 이 값들을 스택에서 팝(Pop)하여 사용자 모드 프로그램의 실행을 다시 시작함

3. trap 명령어
   - 호출한 프로세스는 분기할 주소를 명시할 수 없음 (주소를 명시한다는 것은 커널 내부의 원하는 지점에 접근할 수 있다는 것이기 때문에 위험함)
   - 커널이 임의 코드를 실행하기 위해 접근 권한 검사가 끝난 후 분기해야 함
   - 이러한 문제 때문에 커널은 trap 발생 시 어떤 코드를 실행할지 신중하게 통제해야 함

4. 커널은 부팅 시 트랩 테이블(Trap Table)을 만들고 이를 이용해 시스템을 통제
   - 컴퓨터가 부트될 때는 커널 모드에서 동작하므로 하드웨어는 원하는 대로 제어 가능
   - 운영체제가 하는 초기 작업 중 하나는 하드웨어에게 예외 사건이 일어났을 때, 어떤 코드를 실행해야 하는지 알려주는 것
   - 예를 들어, 하드 디스크 인터럽트가 발생하면 (키보드 인터럽트 또는 하드 디스크 인터럽트 등), 운영체제는 특정 명령어를 사용하여 하드웨어에게 트랩 핸들러(Trap Handler)의 위치를 알려줌
   - 하드웨어는 이 정보를 전달받으면 해당 위치를 기억하고 있으며, 따라서 시스템 콜과 같은 예외적인 사건이 발생했을 때 하드웨어는 무엇을 해야할지(즉, 어느 코드로 분기하여 실행할지) 알 수 있음
  
5. 제한적 직접 실행 프로토콜
<div align="center">
<img src="https://github.com/user-attachments/assets/b1865820-e087-40f2-ab1e-f8ea60cdcbb0">
</div>

   - 프로세스는 커널 스택을 각자 가지고 있으며, 커널 모드로 진입하거나 진출할 때 하드웨어에 의해 프로그램 카운터와 범용 레지스터 등의 레지스터가 저장되고 복원되는 용도로 사용

6. LDE 프로토콜은 두 단계로 진행
   - 전반부 (부팅 시) : 트랩 테이블을 초기화하고, CPU는 나중에 사용하기 위하여 테이블의 위치를 기억하며, 커널은 이러한 작업을 커널 모드에서만 사용할 수 있는 명령어를 이용하여 수행
   - 후반부 (프로세스 실행) : return-from-trap을 이용하여 사용자 프로세스를 시작할 때 몇가지 작업을 수행하는데, 새로운 프로세스를 위한 노드를 할당하여 프로세스 리스트에 삽입하고, 메모리 할당 등의 작업이 포함
     * return-from-trap 명령어는 CPU를 사용자 모드로 전환하고 프로세스 실행을 시작
     * 프로세스가 시스템 콜을 호출하면 운영체제로 다시 트랩
     * 운영체제는 시스템 콜을 처리하고 return-from-trap 명령어를 사용하여 다시 제어를 프로세스에게 넘김
     * 프로세스는 이후 자신의 할 일을 다하면 main()에서 리턴하며, 이 때, 일반적으로 스텁 코드를 리턴하고 스텁 코드가 프로그램을 종료
     * 종료시킬 때, exit() 시스템을 호출하고 다시 운영체제로 트랩
     * 이 시점에 운영체제는 정리 작업을 하게 되어 모든 일이 완료
    
