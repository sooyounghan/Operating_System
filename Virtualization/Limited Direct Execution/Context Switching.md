-----
### 프로세스 간 전환
-----
1. 직접 실행의 두 번쨰 문제점은 프로세스 간 전환을 할 수 있어야 함
2. 운영체제는 실행 중인 프로세스를 계속 실행할 것인지, 멈추고 다른 프로세스를 실행할 것인지 결정해야 함
   - CPU에서 프로세스가 실행 중이라는 것은 운영체제는 실행 중이지 않다는 것

-----
### 협조(Cooperative) 방식 : 시스템 콜 기다리기
-----
1. 과거 몇 시스템에서 채택되었던 방식으로, 운영체제가 프로세스들이 합리적으로 행동할 것이라고 신뢰하며, 너무 오랫동안 실행할 가능성이 있는 프로세스는 운영체제가 다른 작업을 실행할 결정을 할 수 있도록 주기적으로 CPU를 포기할 것이라고 가정
2. 대부분의 프로세스는 자주 시스템 콜을 호출하여 CPU 제어권을 운영체제에게 넘겨줌 (예) 파일을 열고 읽는 작업을 한다거나 다른 컴퓨터에게 메세지를 송신하거나 또는 새 프로세스를 생성하는 등의 시스템 콜을 호출)
   - 이런 유형의 운영체제는 yield 시스템 콜을 제공하는데, 이 시스템 콜은 운영체제에게 제어를 넘겨 운영체제가 다른 프로세스를 실행할 수 있게 함

3. 응용 프로그램이 비정상적 행위를 하게 되면 운영체제에게 제어가 넘어감
   - 예를 들어, 응용 프로그램이 어떤 수를 0으로 나누는 연산을 실행하거나 접근할 수 없는 메모리에 접근하려고 하면 운영체제로의 트랩 발생
   - 그러면, 운영체제는 다시 cpu를 획득하여 해당 행위를 하는 프로세스를 종료할 수 있음
   - 협조 방식의 스케줄링 시스템에서 운영체제는 시스템 콜이 호출되기를 기다리거나 불법적 연산이 일어나기를 기다려서 CPU 제어권을 다시 획득

-----
### 비협조 방식 : 운영체제가 전권을 행사
-----
1. 프로세스가 시스템 콜을 호출하기를 거부하거나 실수로 호출하지 않아 운영체제에게 제어를 넘기지 않을 경우 하드웨어의 추가적인 도움 없이 운영체제가 할 수 있는 일은 거의 없음
2. 따라서, 타이머 인터럽트(Timer Interrupt)를 이용하여 해결
   - 타이머 장치는 수 밀리 초마다 인터럽트를 발생시키도록 프로그램 가능
   - 인터럽트가 발생하면 수행 중인 프로세스는 중단되고 미리 구성된 운영체제 인터럽트 핸들러(Interrupt Handler)가 실행
   - 이 시점에서 운영체제는 CPU 제어권을 다시 얻고 자신이 원하는 일을 할 수 있음
   - 현재의 프로세스를 중단하고, 다른 프로세스를 실행시키는 작업 등 해당

3. 운영체제는 하드웨어에게 타이머 인터럽트가 발생했을 때 실행해야 할 코드(특정 작업을 대치하는 코드)를 알려줘야 함
   - 부팅될 때 운영체제가 이런 준비를 하며, 부팅 과정 진행 중에 운영체제는 타이머를 시작
   - 타이머가 시작되면, 운영체제는 자신에게 제어가 돌아올 것을 알고 부담 없이 사용자 프로그램을 실행 할 수 있음
   - 또한, 타이머는 특정 명령어를 수행하여 끌 수 있음

4. 인터럽트 발생 시, 하드웨어에게도 역할 존재 : 인터럽트가 발생했을 때 실행 중이던 프로그램 상태를 저장하여 나중에 return-from-trap 명령어가 프로그램을 다시 시작할 수 있도록 해야 함
5. 즉, 다양한 레지스터가 커널 스택에 저장되고, return-from-trap 명령어를 통해 복원

-----
### 문맥의 저장과 복원
-----
1. 시스템 콜을 통하여 협조적으로 하던, 또는 타이머 인터럽트를 통해 약간은 강제적으로 하던, 운영체제가 제어권을 회득하려면 중요한 결정을 내려야 함
   - 즉, 현재 실행 중인 프로세스를 계속 실행할 것인지 아니면 다른 프로세스로 전환할 것인지 결정해야 함
   - 이 결정은 운영체제의 스케줄러(Scheduler)라는 부분에 의해 내려짐

2. 💡 다른 프로세스로 전환하기로 결정되면 운영체제는 문맥 교환(Context Switching)이라고 알려진 코드를 실행
   - 운영체제가 해야 하는 작업은 현재 실행 중인 프로세스의 레지스터 값을 커널 스택 같은 곳에 저장하고 곧 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원하는 것
   - 따라서, 운영체제는 return-from-trap 명령어가 마지막으로 실행될 때 현재 실행 중이던 프로세스로 리턴하는 것이 아닌 다른 프로세스로 리턴하며 실행을 다시 시작할 수 있음
   - 프로세스 전환을 위해 운영체제는 저수준 어셈블리 코드를 사용하여 현재 실행중인 프로세스의 범용 레지스터, PC뿐 아니라 커널 스택 포인터를 저장
   - 그리고 곧 실행될 프로세스의 범용 레지스터, PC를 복원하고 커널 스택을 이 프로세스의 커널 스택으로 전환
   - 이로써, 운영체제는 인터럽트된 프로세스 문맥에서 전환 코드를 호출하고, 실행될 프로세스 문맥으로 리턴 가능
   - 운영체제가 마지막으로 return-from-trap 명령어를 실행하면 곧 실행될 프로세스가 현재 실행 중인 프로세스가 되면서, 문맥 교환이 마무리

3. 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/011fda30-f09e-4039-9920-182577a01f0a">
</div>

   - 프로세스 A가 실행 중이고 타이머 인터럽트에 의해 중단
   - 하드웨어는 A의 레지스터를 커널 스택에 저장하고 커널 모드로 진입
   - 타이머 인터럽트 핸들러에서 운영체제는 프로세스 B로 전환하기 결정
   - 이 시점에서 switch() 루틴을 호출하며, 이 루틴이 A의 레지스터의 현재 값을 A의 프로세스 구조체에 저장하고 B의 프로세스 구조체에서 B의 레지스터를 복원
   - 그런 후 A의 커널 스택이 아니라 B의 커널 스택을 사용하도록 스택 포인터를 바꾸어서 문맥 교환을 수행
   - 마지막으로 운영체제는 return-from-trap을 수행하여 B의 레지스터를 복원하고 실행 시작
   - 이 과정이 실행되는 동안 두 번의 레지스터 저장 / 복원이 일어남
     + 첫 번째는 레지스터가 하드웨어에 의해 암묵적으로 저장되고 저장 장소로 해당 프로세스의 커널 스택이 사용
     + 두 번쨰는 운영체제가 A에서 B로 전환하기로 결정했을 때 일어남
     + 이 경우 커널 레지스터는 운영체제에 의하여 해당 프로세스의 프로세스 구조체에 저장 (이는 운영체제가 A가 아닌 B로부터 커널로 트랩된 것처럼 만듬)
     
4. xv6 문맥 교환 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/3a2fac80-9bf6-4020-a50b-522be2945b80">
</div>

