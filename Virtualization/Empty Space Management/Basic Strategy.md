-----
### 기본 전략
-----
1. 빈 공간 할당을 위한 기본 전략
   - 이상적인 할당기는 속도가 빠르고 단편화를 최소로 해야함
   - 하지만, 할당과 해제 요청 스트림은 무작위, 결국 프로그래머에 의해 결정되므로 어느 특정 전략도 잘 맞지 않는 입력을 만나면 성능이 매우 좋지 않을 수 있음
  
2. 최적 적합 (Best Fit)
   - 빈 공간 리스트를 검색하여 요청한 크기와 같거나 더 큰 빈 메모리 청크를 찾음
   - 그 후, 후보자 그룹 중 가장 작은 크기의 청크를 반환 (이 청크를 최적 청크라고 부르며, 최소 적합이라고도 불릴 수 있음)
   - 빈 공간 리스트를 한 번만 순회하면 반환할 정확할 블럭을 찾을 수 있음
   - 즉, 사용자가 요청한 크기에 가까운 블럭을 반환함으로써 공간의 낭비를 줄이려고 노력하지만, 비용이 수반됨 (정교하지 않은 구현은 해당 빈 블럭을 찾기 위해 항상 전체를 검색해야하므로 전체 성능 저하 발생 가능)

3. 최악 적합 (Worst Fit)
   - 최적 적합의 반대로, 가장 큰 빈 청크를 찾아 요청된 크기 만큼만 반환하고 남는 부분은 빈 공간 리스트에 계속 유지
   - 최적 적합에서 발생할 수 있는 수많은 작은 청크 대신 커다란 빈 청크를 남기려고 시도
   - 그러나 다시 한 번 빈 공간 전체를 탐색해야하므로 높은 비용이 발생하며, 엄청난 단편화가 발생하므로 오버헤드도 큼

4. 최초 적합 (First Fit)
   - 요청보다 큰 첫 번째 블럭을 찾아 요청만큼 반환
   - 남은 빈 공간은 후속 요청을 위해 계속 유지
   - 속도가 빠르다는 장점이 있음 : 원하는 블럭을 찾기 위해 항상 빈 공간 리스트 전체를 탐색할 필요가 없지만, 리스트 시작에 크기가 작은 객체가 많이 생길 수 있음
   - 따라서, 할당기가 빈 공간 리스트의 순서를 관리하는 방법이 필요한데, 주소-기반 정렬(Adress-based Ordering)을 사용하는 것 : 리스트를 주소로 정렬하여 병합을 쉽게하고, 단편화 감소

5. 다음 적합 (Next Fit)
   - 항상 리스트의 처음부터 탐색하는 대신 마지막으로 찾았던 원소를 가리키는 추가의 포인터를 유지하여, 빈 공간 탐색을 리스트 전체에 더 균등하게 하는 것
   - 리스트의 첫 부분에만 단편이 집중적으로 발생하는 것을 방지
   - 전체 탐색을 하지 않으므로 최초 적합의 성능과 비슷

6. 예제
   - 크기가 각각 10, 30, 20인 세 개의 원소를 가진 빈 공간 리스트 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/87eb9e57-46fc-4bc6-8e5f-581123557748">
</div>

   - 크기가 15인 요청이 들어왔다고 가정
   - 최적 적합 방법은 전체 리스트를 검삭하여 요청을 만족시킬 수 있는 청크 중 가장 적은 20 선택
<div align="center">
<img src="https://github.com/user-attachments/assets/bf4e2faa-4fcd-4e4d-bd48-e65ba97eeeab">
</div>

   - 최적 적합의 경우 종종 작은 빈 청크가 남게 됨

   - 최악 적합은 방식은 유사하지만, 가장 큰 청크를 찾는데 여기서는 30이므로 이를 선택
<div align="center">
<img src="https://github.com/user-attachments/assets/4dd32416-522a-46dd-a224-43e45fa2b2c2">
</div>

   - 최초 적합 전략은 최악 전략 집합과 같은 결과를 도출
     + 요청을 충족시킬 수 있는 첫 번째 빈 블럭을 찾았지만, 차이점은 탐색과 비용
     + 최적 적합과 최악 적합은 리스트 전체를 탐색하지만, 최초 적합은 단지 적합한 청크를 발견할 때까지만 빈 청크를 검사하므로 탐색 비용 감소

