-----
### 저수준 기법
-----
1. 대부분의 할당기에서 사용되는 일반적인 기법 : 분할(Spliting)과 병합(Coalescing)
2. 분할 기법
   - 빈 공간 리스트는 힙에 있는 빈 공간들의 집합으로, 30바이트의 힙이 있다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/f4face32-7ee9-4c9f-93cc-4e0a8eb6afb0">
</div>

   - 이 힙의 빈공간 리스트에는 2개의 원소가 존재
     + 첫 번째 10바이트의 빈 세그먼트(바이트 0 ~ 9)
     + 나머지 빈 세그먼트 (바이트 20 ~ 29)
<div align="center">
<img src="https://github.com/user-attachments/assets/9df635bb-49dd-43f8-8473-57bb0f0c3b2a">
</div>

   - 10바이트를 초과하는 모든 요청은 실패하여 NULL을 반환 : 요청한 크기에 해당하는 메모리 청크가 없기 때문임
   - 10바이트에 대한 요청은 둘 중 하나 빈 청크를 사용해 충족
   - 10바이트보다 적은 요청 : 예를 들어, 메모리를 1바이트만 요청했다고 가정
     + 분할(Spliting) 작업 수행
     + 요청을 만족시킬 수 있는 빈 청크를 찾아 이를 둘로 분할
     + 첫 번째 청크는 호출자에게 반환되고, 두 번째 청크는 리스트에 남게 됨
     + 따라서 1바이트 요청이 발생하고 할당기가 리스트의 두 번째 원소를 사용해 요청을 충족시키기로 했다고 결정 : malloc()은 20(1바이트가 할당된 영역의 주소)을 반환하고 최종 빈 리스트는 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/18b23bd8-b95f-455e-9f65-7929e3fbe2f5">
</div>

   - 기본적인 리스트의 모습을 바뀌지 않았으며, 유일한 변경 사항은 빈 공간이 20이 아니라 21에서 시작되며, 빈 공간의 길이가 9 인 것 (헤더는 없다고 가정)
   - 요청이 특정 빈 청크 크기보다 작을 경우 분할 기법 사용

3. 병합 기법
   - 위의 예 (빈 공간 10바이트, 사용 중 10바이트, 또 하나의 빈 공간 10바이트)에서 응용 프로그램이 free(10)을 호출하여 힙의 중간에 조재하는 공간을 반환할 때 상황
<div align="center">
<img src="https://github.com/user-attachments/assets/4fa13daf-23b0-4eac-bfbb-745bd53d1d5a">
</div>

   - 힙 전체가 비어있지만, 10바이트 길이의 청크 3개로 나누어져 있으며, 사용자가 20바이트를 요청하는 경우 단순한 리스트 탐색은 빈 청크를 발견하지 못하고 실패를 반환
   - 할당기가 이 문제를 방지하기 위하여 할 수 있는 것은 메모리 청크가 반환될 때 빈 공간들을 병합하는 것
     + 메모리 청크를 반환할 때 해제되는 청크의 주소와 바로 인접한 빈 청크의 주소를 살펴봄
     + 새로 해제된 빈 공간의 왼쪽의 빈 청크와 바로 인접해있다면, 하나의 더 큰 청크로 병합
   - 병합 이후 최종 리스트
<div align="center">
<img src="https://github.com/user-attachments/assets/ad30ecbf-4ae3-4aca-ac40-a068033bc258">
</div>

   - 할당이 한 번도 일어나지 않은 최초 힙 리스트 모양과 동일

4. 할당된 공간의 크기 파악
   - free(void *ptr) 인터페이스는 크기를 매개변수로 받지 않음
   - 포인터가 인자로 전달되면 malloc 라이브러리는 해제되는 메모리 영역을 신속하게 파악하고 그 공간을 빈 공간 리스트에 추가시킬 수 있다고 가정
   - 이 작업을 위해 대부분 할당기는 추가 정보를 헤더(Header) 블럭에 저장 : 메모리에 유지되며, 보통 해제된 청크 바로 직전에 위치
   - 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/08cb2847-b105-43f2-9084-e96b2c98b87d">
</div>

   - ptr이 가리키는 크기 20바이트의 할당된 블럭을 검토하고 있으며, 사용자는 malloc()을 호출하고 그 결과를 ptr에 저장했다고 가정 (예) ptr = malloc(20))
     + 헤더는 적어도 할당된 공간의 크기는 저장해야 함(이 경우에는 20)
     + 또한, 해제 속도를 향상시키기 위한 추가 포인터, 부가적인 무결성 검사를 제공하기 위한 매직 넘버, 기타 정보 저장할 수 있음
```c
typedef struct __header_t {
    int size;
    int magic;
} header_t;
```
   - 사용자가 free(ptr)을 호출하면, 라이브러리는 헤더의 시작 위치를 파악하기 위해 간단한 포인터 연산 시행
```c
void free(void *ptr) {
    header_t *hptr = (void *)ptr − sizeof(header_t);
    ...
}
```
   - 헤더를 가리키는 포인터를 얻어내면, 라이브러리는 매직 넘버가 기대하는 값과 일치하는지 비교하여 안정성 검사(Stability Check 실시 (assert(hptr->magic == 1234567)
   - 새로 해제된 영역의 크기를 계산 (즉, 헤더의 크기를 영역의 크기에 더함)
   - 빈 영역의 크기 = 헤더 크기 + 사용자에게 할당된 영역의 크기
     + 따라서, 사용자가 N 바이트의 메모리 청크를 요청 : 라이브러리는 크기 N의 빈 청크를 찾는 것이 아닌 빈 청크의 크기 N + 헤더의 크기인 청크를 탐색

5. 빈 공간 리스트 내장
   - 리스트를 빈 공간에 구현하는 방법
   - 새로운 노드를 위해 일반적으로 공간이 필요할 때 malloc()을 호출하지만, 메모리 할당 라이브러리 루틴에서는 이것이 불가능하므로 빈 공간 내 리스트를 구축해야 함
   - 4096바이트 크기의 메모리 청크가 있다고 가정 (힙의 크기는 4 KB)
     + 이를 빈 공간 리스트로 관리하기 위해 먼저 리스트를 초기화
     + 처음 리스트는 4096 - 헤더크기 길이의 항목을 하나 가지고 있음
```c
typedef struct __node_t {
    int size;
    struct __node_t *next;
} node_t;
```
   - 힙을 초기화하고 힙의 빈 공간 리스트에 첫 번째 원소를 넣는 코드
     + 시스템 콜 mmap()을 호출하여 얻어진 영역에 구축된다고 가정
     + 힙을 구축하기 위한 유일한 방법은 아니지만, 해당 예에서는 이 방법 사용
```c
// mmap()이 빈 공간의 청크에 대한 포인터를 변환
node_t *head = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, −1, 0);

head−>size = 4096 − sizeof(node_t);

head−>next = NULL;
```
   - 이 코드 실행 후 리스트는 크기 4088의 항목 하나만을 가지게 됨
   - head 포인터는 이 영역의 시작 주소를 담고 있으며, 영역의 시작 주소를 16 KB라고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/275164ea-7ca5-4bf2-8cc4-dba76e258efd">
</div>

   - 100바이트 메모리 청크 요청이 발생했다고 가정
     + 이 요청을 처리하기 위해 라이브러리는 먼저 충분한 크기의 청크를 찾음 : 하나의 빈 청크 (크기 : 488)만이 존재하므로 이 청크를 선택
     + 요청을 처리하기에 충분히 큰 크기, 즉, 빈 영역 크기 + 헤더 크기를 충족할 수 있는 청크와 나머지 빈 청크 두 개로 분할
     + 헤더의 크기를 8바이트라 가정하면 (정수형의 크기와 정수형의 매직 넘버) 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/126f51ad-496c-414b-a54b-2f053b600927">
</div>

   - 100바이트에 대한 요청이 오면 라이브러리는 기존 하나의 빈 청크 중 108바이트를 할당하고 할당 영역을 가리키는 포인터(ptr) 반환
   - 그리고 나중에 free()에서 사용할 수 있도록 할당된 공간 직전 8바이트에 헤더 정보를 넣음
   - 그런 후, 하나의 남은 빈 노드를 3980(4088 - 108)로 축소

   - 100바이트씩(또는 헤더 포함 108바이트) 할당된 3개의 공간이 존재한다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/ce684bf6-e3ea-416d-ab39-7bd40f73c966">
</div>

   - 힙의 시작 부분 324바이트가 현재 할당 : 3개의 헤더와 호출 프로그램에 의해 사용 중인 3개의 100바이트 영역을 볼 수 있음
   - 빈 공간 리스트는 여전히 head가 가리키는 하나의 노드로 구성되어있지만, 세 번의 분할 이후 3764바이트로 축소
   - 이 상황에서 free()를 통해 일부 메모리 반환
     + 응요 프로그램은 free(16500)을 호출하여 할당 영역의 가운데 청크 반환
     + 16500은 메모리 영역의 시작 주소 16384, 이전 메모리 청크의 크기 108, 해제되는 청크의 헤더 8바이트를 모두 더해서 나온 값이며, sptr으로 나타냄
     + 라이브러리는 신속히 빈 공간의 크기를 파악하고, 빈 청크를 빈 공간 리스트에 삽입
     + 빈 공간 리스트의 헤드 쪽에 삽입한다고 가정하면 공간의 모양은 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/025d402c-b5e1-4b23-b35f-ad05204948e5">
</div>

   - 빈 공간 리스트의 첫 번째 원소는 작은 빈 청크(100바이트 크기이며 리스트 헤드가 가리킴)
   - 두 번쨰 원소는 큰 빈 청크(3764 바이트)
   - 빈 공간 리스트가 하나 이상의 원소를 가졌으나, 단편화가 발생

   - 마지막으로, 마지막 2개의 사용 중인 청크가 해제된다고 가정 : 병합이 없다면, 작은 단편으로 이루어진 빈 공간 리스트가 됨
<div align="center">
<img src="https://github.com/user-attachments/assets/6e8b88eb-4f99-414d-a41c-d260b33a6857">
</div>

   - 리스트를 병합하지 않았으므로, 모든 메모리가 비어있지만, 전부 조각나있어 한 청크가 아닌 단편으로 이루어진 메모리처럼 보임
   - 따라서, 리스트를 순회하면서 인접한 청크를 병합하면 힙은 전체의 하나의 큰 청크가 됨

-----
### 힙의 확장
-----
1. 힙 공간이 부족한 경우 가장 쉬운 방법 : 단순히 실패를 반환, 즉 NULL을 반환
2. 대부분의 전통적인 할당기는 적은 크기의 힙으로 시작해 모두 소진하여 운영체제로부터 더 많은 메모리를 요청
   - 할당기는 힙을 확장하기 위해 특정 시스템 콜(예) 대부분 UNIX 시스템에서 sbrk)을 호출
   - 그런 후 확장된 영역에서 새로운 청크 할당
   - sbrk 요청을 수행하기 위해 운영체제는 빈 물리 페이지를 찾아 요청 프로세스 주소 공간에 매핑한 후, 새로운 힙의 마지막 주소 반환
