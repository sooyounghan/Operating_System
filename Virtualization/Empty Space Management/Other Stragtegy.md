-----
### 다른 접근법
-----
1. 개별 리스트(Segregated List)
   - 별도의 개별 리스트를 사용하는 것
   - 즉, 특정 응용 프로그램이 한 두 개 자주 요청하는 크기가 있다면, 그 크기의 객체를 관리하기 위한 별도 리스트를 유지
   - 다른 모든 요청은 더 일반적인 메모리 할당기에 전달
   - 장점 : 특정 크기의 요청을 위한 메모리 청크를 유지함으로써 단편화 가능성을 줄일 수 있으며, 요청된 크기의 청크만이 존재하므로 복잡한 리스트 검색을 하지 않아도 되므로 할당과 해제 요청을 신속히 처리 가능
   - 단점 : 지정된 크기의 메모리 풀과 일반적인 풀에 어느정도의 메모리를 할당해야 되는지 알 수 없음
     + 특수 목적 할당기인 슬랩 할당기 (Slap Allocator)는 이 문제를 해결

 2. 슬랩 할당기(Slab Allocator)
     - 커널이 부팅될 때 커널 객체를 위한 여러 객체 캐시(Object Cache)를 할당 (커널 객체 : 락, 파일 시스템 아이노드 등 자주 요청되는 자료 구조들을 일컫음)
     - 객체 캐시는 지정된 크기의 객체들로 구성된 빈 공간 리스트이며, 메모리 할당 및 해제 요청을 빠르게 서비스하기 위해 사용됨 (아이노드로만 구성된 객체 캐시가 있고, 락 구조만을 담고 있는 객체 캐시도 존재)
     - 기존에 할당된 캐시 공간이 부족하면 상위 메모리 할당기에게 추가 슬랩을 요청 : 요청 전체 크기는 페이지 크기의 정수배
     - 반대로, 객체들에 대한 참조 횟수가 0이 되면, 상위 메모리 할당기는 이 슬랩을 회수할 수 있음 (VM 시스템이 더 많은 메모리를 필요로 할 때 실제 회수가 발생)
     - 슬랩 할당 방식은 빈 객체들을 사전에 초기화된 상태로 유지한다는 점에서 개별 리스트 방식보다 우수
       + 자료 구조의 초기화와 반납에는 많은 시간이 소요되는데, 반납된 객체들을 초기화된 상태로 리스트에 유지하는 슬랩 할당기는 객체당 잦은 초기화와 반납 작업을 피할 수 있으므로 오버헤드를 현저히 감소시킴

3. 버디 할당(Buddy Allocation)
   - 빈 공간의 합병은 할당기의 매우 중요한 기능이므로, 합병을 간단히 하는 방법 필요
   - 이진 버디 할당기 (Binary Buddy Allocator)
     + 빈 메모리는 처음에 개념적으로 크기 $2^{N}$인 하나의 큰 공간으로 생각
     + 메모리 요청이 발생하면, 요청을 충족시키기에 충분한 공간이 발견될 때까지 (그리고 더 분할하면 공간이 너무 작아져서 요청을 만족할 수 없을 때까지), 빈 공간을 2개로 계속 분할
     + 이 시점에서 요청된 블럭이 사용자에게 반환

   - 64 KB 빈 공간에서 7 KB 블럭을 할당하는 예
<div align="center">
<img src="https://github.com/user-attachments/assets/579a9661-22b9-46e3-bae7-e1f5552bbfd4">
</div>

   - 이 예에서 가장 왼쪽의 8 KB이 할당되고(짙은 회색), 사용자에게 반환
   - 이 방식은 2의 거듭제곱 크기 만큼 블럭만 할당할 수 있으므로 내부 단편화가 발생 가능
   - 해제 상황
     + 8 KB 블럭을 빈 공간 리스트에 반환하면 할당기는 버디 8 KB가 비어있는지 확인
     + 비어있다면, 두 블럭을 병합하여 16 KB로 만들며, 할당기는 다음 16 KB 버디가 비어있는지 확인
     + 비어있다면, 다시 두 블럭 합병하며, 이 재귀 합병 과정은 트리를 따라 전체 빈 공간이 복원되거나 버디가 사용 중이라는 것이 밝혀질때까지 계속 올라감

   - 버디 할당이 잘 동작하는 이유 : 특정 블럭의 버디를 결정하는 것이 쉽기 때문임
     + 빈 공간에 존재하는 블럭의 주소에 대해, 각 버디 쌍의 주소는 오직 한 비트만 다름
     + 어느 위치의 비트가 다른가는 버디 트리의 수준에 따라 다름

4. 기타 아이디어
   - 문제점 : 확장성
     + 빈 공간들의 개수가 늘어남에 따라 리스트 검색이 매우 느려질 수 있음
     + 좀 더 정교한 할당기는 복잡한 자료 구조를 사용해 이 비용을 줄임 (즉, 단순함과 성능을 교환)
     + 예) 균형 이진 트리(Balanced Binary Tree), 스플레이 트리(Splay Tree), 부분 정렬 트리(Partially Ordered Tree)

   - 현대의 시스템은 멀티프로세서 및 멀티 쓰레드로 작동하므로, 멀티프로세스를 위한 할당기를 최적화하는 노력이 많이 있음
  
