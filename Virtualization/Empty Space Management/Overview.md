-----
### 빈 공간 관리
-----
1. 메모리 관리 시스템은 프로세스 힙의 페이지를 관리하는 malloc() 라이브러리일 수 있고, 혹은 프로세스 주소 공간의 일부분을 관리하는 운영체제 자체일 수 있지만, 여기서는 빈 공간 관리에 대해 논의할 것
2. 관리하고 있는 공간의 크기가 고정 크기 단위로 나뉘어지면, 이 고정 크기 단위의 리스트를 유지하면 되고, 클라이언트가 그 중 하나를 요청하면 첫 번째 항목을 반환하면 됨
3. 가변-크기 빈 공간들의 집합일 경우, malloc()과 free()처럼 사용자 수준 메모리-할당 라이브러리에서, 그리고 세그멘테이션으로 물리 메모리를 관리하는 운영체제에서 발생하며, 외부 단편화도 어느 경우에는 존재
   - 빈 공간은 다양한 크기의 작은 조각으로 분할되어 결국 단편화가 되며, 빈 공간들의 전체 크기가 요청된 것보다 크더라도 하나의 연속된 영역이 존재하지 않으면 요청은 실패할 수 있음

4. 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/70133d9c-bd65-4a65-b9c9-ff34e59bc3bb">
</div>

   - 빈 공간의 전체 크기는 20바이트
   - 하지만, 10바이트 2조각으로 나뉘어져 있으며, 그 결과 20바이트의 빈 공간이 있지만 15바이트 요청이 들어오면 요청은 실패

-----
### 가정
-----
1. malloc(), free()에서 제공하는 것과 같은 기본 인터페이스 가정
   - 구체적으로 void *malloc(size_t size)는 응용 프로그램이 요청한 바이트 수를 나타내는 변수 size를 받아들이며, 이 함수는 요청된 크기와 같거나 큰 영역을 가리키는, 타입이 없는 또는 C 타입 용어로 void 포인터를 반환
   - 대응되는 루틴 void free(void *ptr)는 포인터를 인자로 전달받고 해당 영역을 해제하는데, 공간을 해제할 때 라이브러리에게 크기 정보를 전달하지 않으며, 포인터만으로 해제하고자 하는 메모리 영역 크기를 파악해야 함

2. 라이브러리가 관리하는 공간은 힙(Heap)이며, 힙의 빈 공간을 관리하는데 일반적인 링크드리스트가 사용
   - 이 자료 구조는 영역 내 모든 청크에 대한 주소를 가지고 있으며, 반드시 리스트일 필요는 없고, 빈 공간들을 표현할 수 있는 자료 구조면 충분

3. 외부 단편화와 내부 단편화 방지
   - 할당기가 요청한 크기보다 더 큰 메모리 청크를 할당할 경우, 요청되지 않은 사용되지 않는 공간에 대해서는 할당 청크의 내부에서 낭비가 일어났기 때문에 내부 단편화라고 간주

4. 클라이언트에게 할당된 메모리는 다른 위치로 재배치될 수 없다고 가정
   - 예를 들어, 프로그램이 malloc()을 호출하여 힙의 일부 영역에 대한 포인터를 받으면, 그 메모리 영역은 대응하는 free()를 통해 반환될 때까지 프로그램이 소유하게 되고, 라이브러리에 의해 다른 위치로 옮겨질 수 없음
   - 단편화 해결에 유용하게 사용되는 빈 공간의 압축은 이 경우 사용이 불가능 (C 프로그램에게 메모리 청크를 가리키는 포인터를 전달하면, 그 영역을 가리키는 포인터를 모두 알아내는 것은 어려움 : 다른 변수 혹은 심지어 실행 중에 레지스터에 저장되어 있을 수 있기 때문임)
   - 운영체제가 세그먼트를 구현할 때는 단편화 해결을 위해 압축을 사용할 수는 있음
  
