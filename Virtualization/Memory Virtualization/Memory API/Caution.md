-----
### 흔한 오류
-----
1. malloc()과 free()를 사용하는데 흔히 발생하는 오류가 많음
2. 많은 새로운 언어들은 자동 메모리 관리(Automatic Memory Management)를 지원하는데, 메모리 할당을 위해 malloc()과 유사한, new 또는 새 객체를 할당하기 위해 비슷한 루틴을 호출하는 반면에, 공간을 해제 하기 위해서는 아무것도 호출하지 않음 (Garbage Collector가 실행되어 참조되지 않은 메모리를 찾아서 알아서 해제)
3. 메모리 할당 잊어버리기
   - 많은 루틴은 자신이 호출되기 전 필요한 메모리가 미리 할당되었다고 가정
   - 예를 들어 strcpy(dst, src) 루틴은 소스 포인터에서 목적 포인터로 문자열을 복사
<div align="center">
<img src="https://github.com/user-attachments/assets/7f3e61ca-4271-4e1b-ae2c-f706ff8f7c4e">
</div>

   - 이 코드를 실행하면 세그멘테이션 폴트(Segmentation Fault)가 발생할 가능성이 높음
   - 올바른 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/a2b3bd9f-2ceb-4eb8-b85c-6d98eed27658">
</div>

4. 메모리를 부족하게 할당받기
   - 버퍼 오버플로우(Buffer Overflow)라고 불리며, 목적지 버퍼 공간을 약간 부족하게 할당받는 것
<div align="center">
<img src="https://github.com/user-attachments/assets/e92c879b-e541-40e8-8879-9e7429b4818f">
</div>

5. 할당받은 메모리 초기화하지 않기
   - malloc()을 제대로 호출했지만 새로 할당받은 데이터 타입에 특정 값을 넣는 것을 잊는 것
   - 초기화하지 않으면, 프로그램은 결국 초기화되지 않은 읽기(Uninitialized Read), 즉, 힙으로부터 알 수 없는 값을 읽는 일이 발생

6. 메모리 해제하지 않기
   - 메모리 누수(Memory Leak)라고도 하며, 메모리 해제를 잊었을 때 발생
   - 장시간 실행되는 응용프로그램이나 운영체제 자체와 같은 시스템 프로그램에서는 큰 문제
   - 메모리가 천천히 누수되면 결국 메모리가 부족하게 되고 시스템을 재시작할 수 밖에 없음
   - 따라서, 메모리 청크의 사용이 끝나면 반드시 해제해야함
   - 쓰레기 수집 기능이 있는 언어도 이 문제에는 도움이 되지 않음 (메모리 청크에 대한 참조가 존재하면, 어느 가비지 컬렉터도 그 청크를 해제하지 않을 것이며, 여전히 문제가 됨)
   - 경우에 따라 free()를 호출하지 않는 것이 타당할 수 있음 : 예를 들어, 프로그램 실행 시간이 짧아 실행 시작 후 곧 종료하는 경우
     + 이 경우 프로세스가 죽으면 운영체제는 할당된 모든 페이지를 정리하고 메모리 누수는 발생하지 않음
     + 하지만 이 전략은 매우 조심해서 사용해야 함

7. 메모리 사용이 끝나기 전 메모리 해제하기
   - 프로그램은 메모리 사용이 끝나기 전 메모리를 해제하는 경우가 존재하는데 이를, Dangling Pointer라고 불리며 심각한 실수
   - 차후 그 포인터를 사용하면 프로그램을 크래시하거나 유효 메모리 영역을 덮어쓸 수 있음
   - 예를 들어, free() 호출 후, 다른 용도로 malloc()을 호출하면 잘못 해제된 메모리를 재사용

8. 반복적으로 메모리 해제하기
   - 프로그램은 가끔씩 한 번 이상 해제하며 이를 이중 해제(Double Free)라고 부름

9. free() 잘못 호출하기
    - free()는 malloc() 받은 포인터만 전달될 것으로 예상하고, 그 외의 값을 전달하면 문제 발생
    - 유효하지 않은 해제는 매우 위험함

10. 참고 : 프로세스가 종료하면 메모리 누수가 일어나지 않는 이유
    - 시스템이 실제 두 단계로 메모리를 관리
    - 메모리 관리 첫 번째 단게 : 운영체제에 의해 수행
      + 프로세스가 실행할 때 메모리를 프로세스에게 건네주고 프로세스를 종료하거나 다른 이유로 죽을 때 메모리를 되돌려 받음
    - 메모리 관리 두 번쨰 단계 : 각 프로세스 내에서, 예를 들면 malloc()과 free()를 호출할 때 힙 내에서 수행
      + free()를 호출하지 못했더라도, 그래서 메모리가 누수되었더라도 프로세스가 종료할 때, 운영체제는 프로세스의 모든 메모리를 회수
      + 프로세스의 코드, 스택 등 모든 페이지가 포함
      + 프로세스 주소 공간의 힙이 어떤 상태가 되더라도, 운영체제는 프로세스가 죽을 때 그 모든 페이지를 회수하므로 메모리가 누수되지 않음
      
