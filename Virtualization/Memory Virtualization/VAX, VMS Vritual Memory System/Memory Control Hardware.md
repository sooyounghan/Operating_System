-----
### 메모리 관리 하드웨어
-----
1. VAX-11은 프로세스마다 512바이트 페이지 단위로 나누어진 32비트 가상 주소 공간을 제공
   - 가상 주소는 23비트 VPN과 9비트 오프셋으로 구성
   - VPN의 상위 두 비트는 페이지가 속한 세그먼트를 나타내기 위해 사용
   - 페이징과 세그멘테이션 하이브리드 구조를 가지고 있음

2. 주소 공간의 하위 절반은 프로세스 공간으로 알려져 있으며, 각 프로세스마다 다르게 할당
   - 프로세스 공간의 첫 번째 절반(P0)에 사용자 프로그램과 힙(Heap)이 존재
     + 힙은 주소가 큰 쪽으로 증가
   - 프로세스 공간의 두 번째, 즉 큰 쪽 절반(P1)은 주소가 작은 방향으로 증가하는 스택(Stack)이 존재
   - 주소 공간의 상위 절반은 그 중 반만 사용되며 시스템 공간(S)으로 불리며, 운영체제의 보호된 코드와 데이터가 이 곳에 존재하며, 이 방식으로 여러 프로세스가 운영체제를 공유

3. VMS은 작은 VAX 하드웨어 페이지 크기(512바이트)를 해결하기 위해, 페이지 테이블로 인한 메모리 압박 정도를 경감하기 위해 두 가지 방법 사용
   - VAX-11은 사용자 주소 공간을 두 개 세그먼트로 나누어 프로세스마다 (P0과 P1) 각 영역을 위한 페이지 테이블을 가지도록 함
   - 스택과 힙 사이 사용되지 않은 주소 영역을 위한 페이지 테이블 공간이 필요 없게 됨
   - 베이스와 바운드 레지스터는 예상하는 그대로 방식으로 사용 (베이스 레지스터는 해당 세그먼트의 페이지 테이블의 주소를 담고 있으며, 바운드는 그 크기를 나타냄(즉, 페이지 테이블의 항목 수)

4. 운영체제는 사용자 페이지 테이블들을(P0과 P1, 즉 프로세스 마다 두 개) 커널의 가상 메모리에 배치하여 메모리 압박을 더 줄일 수 있었음
   - 페이지 테이블을 할당하거나 크기를 키울 때 커널은 자신의 가상 메모리, 세그먼트 S 내 공간을 할당
   - 메모리가 고갈되면, 커널은 페이지 테이블의 페이즈들을 디스크로 스왑하여 물리 메모리를 다른 용도로 사용할 수 있게 함

5. 커널 가상 메모리에 페이지 테이블을 넣으면 주소 변환 과정이 더욱 복잡해짐
   - 예를 들어, P0과 P1 내의 가상 주소를 변환하기 위해서는 하드웨어가 먼저 페이지 테이블(그 프로세스의 P0 또는 P1 페이지 테이블)에서 해당 페이지 테이블 항목을 찾아야함
   - 그러나 이 과정 중에 하드웨어는 시스템 페이지 테이블(물리 메모리에 존재)을 먼저 검색해야 할 수 있음
   - 변환이 완료되면 하드웨어는 페이지 테이블 페이지 주소를 알게 되며, 최종적으로 원하는 메모리 접근에 대한 주소를 알게 됨
   - 다행히 이 모든 과정은 VAX 하드웨어 TLB에 의해 빠르게 처리
