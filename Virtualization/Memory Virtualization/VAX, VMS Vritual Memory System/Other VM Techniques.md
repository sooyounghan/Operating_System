-----
### 그 외의 VM 기법들
-----
1. 요청 시 0으로 채우기(Demand Zeroing)
   - 단순한 구현에서는 힙에 페이지를 추가하는 요청이 오면 운영체제는 물리 메모리에서 페이지를 찾아 0으로 채움 (보완을 위해 필요, 그렇지 않으면 프로세스가 이전에 사용했던 페이지 내용을 알 수 있음)
   - 그런 후 주소 공간에 그 페이지를 매핑 (즉, 물리 페이지는 원하는 대로 참조할 수 있도록 페이지 테이블 설정)
   - 하지만, 이 경우 해당 페이지를 사용하지 않으면 너무 많은 비용을 지불하는 것
   - 페이지가 주소 공간에 추가되는 시점에는 거의 하는 일이 없음
     + 페이지 테이블에 접근 불가능 페이지라고 표기하고 항목을 추가하며, 프로세스가 추가된 페이지를 읽거나 쓸 때 운영체제로 트랩이 발생
     + 트랩을 처리하면서 운영체제는 Demand Zeroing 할 페이지라는 것을 알게 됨 (일반적으로는 페이지 테이블 항목의 운영체제를 위해 예약된 부분에 일정 비트로 표기)
     + 이 시점에서 운영체제는 물리 페이지를 0으로 채우고 프로세스의 주소 공간으로 매핑하는 등의 필요한 작업을 함
     + 프로세스가 해당 페이지를 전혀 접근하지 않으면, 이 모든 작업을 피할 수 있으며, 이것이 바로 장점임
      
2. 쓰기 시 복사(Copy-On-Write, COW)
   - 운영체제가 한 주소 공간에서 다른 공간으로 페이지를 복사할 필요가 있을 때, 복사를 하지 않고 해당 페이지를 대상 주소 공간으로 매핑하고 해당 페이지의 페이지 테이블 엔트리를 양쪽 주소 공간에서 읽기 전용으로 표시
   - 만약 양쪽 주소 공간이 페이지를 읽기만 한다면, 더 이상 조치는 필요 없으며, 운영체제는 실제로 데이터 이동 없이 빠른 복사만 할 수 있게 됨
   - 두 주소 공간 중 하나가 페이지 쓰기를 시도한다면, 운영체제로 트랩이 발생
   - 운영체제는 그 때 해당 페이지가 COW 페이지라는 것을 파악하고, 이후 새로운 페이지를 (게으르게) 할당하고, 데이터를 채우고, 이 새로운 페이지 폴트를 일으킨 페이지 주소 공간에 매핑
   - 프로세스는 독자적인 페이지 사본을 가지게 됨

3. COW의 유용성
   - 공유 라이브러리들을 여러 프로세스들의 주소 공간에 copy-on-write로 매핑하여 메모리 공간을 절약할 수 있음
   - UNIX 시스템에서는 fork()와 exec()의 시멘틱 때문에 COW가 훨씬 더 중요해짐
     + fork()는 호출자의 주소 공간과 정확히 동일한 사본을 생성하며, 주소 공간이 크면 복사본을 만드는데 시간이 오래 걸리고 짧은 시간에 많은 데이터를 접근해야 함
     + exec() 호출에 의해 대부분의 주소 공간이 덮어 쓰이게 되는 문제가 발생하는데, 즉, 곧 실행될 프로그램의 주소 공간으로 호출한 프로세스의 주소 공간의 내용을 덮어쓰게 됨
   - copy-on-write fork()를 수행하게 되면 운영체제는 상당한 불필요한 복사를 피할 수 있고, 성능을 개선하면서 정확한 시멘틱 유지 가능
    
