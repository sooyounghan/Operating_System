-----
### 실제 주소 공간
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/08b834e3-f0cc-4081-aa25-c27c1e06e8b3">
</div>

1. VMS의 좋은 점은 실제 주소 공간 구축 상황을 볼 수 있음
2. 코드 세그먼트는 절대로 페이지 0에서 시작하지 않음
   - 대신 이 페이지는 접근 불가능 페이지로 마킹되어 있으며 널-포인터(Null-Pointer) 접근을 검출할 수 있게 함
   - 주소 공간 설계 시 한가지 고려해야 할 사항은 효과적인 디버깅 지원 여부인데, 접근 불가능한 페이지 0은 그런 지원의 한 형태

3. 커널의 가상 주소 공간(즉, 커널의 자료 구조와 코드)이 사용자 주소 공간의 일부임
   - 문맥 교환이 발생하면 운영체제는 P0과 P1 레지스터를 다음 실행될 프로세스 페이지 테이블을 가리키도록 변경
   - 하지만, S 베이스와 바운드 레지스터는 변경하지 않으므로 결과적으로 동일한 커널 구조들이 각 사용자 주소 공간에 매핑

4. 커널은 여러 주소 공간들로 매핑
   - 예를 들어, 운영체제가 사용자 프로그램으로부터(예) write() 시스템 콜에서) 포인터를 전달받았다면, 그 포인터로부터 데이터를 자신의 구조로 그냥 복사하면 됨
   - 운영체제는 접근하는 데이터가 어디에서 오는지 고려할 필요 없이 자연스럽게 작성되고 컴파일될 수 있음
   - 만약 커널이 전부 물리 메모리에만 존재한다면, 페이지 테이블의 페이지들을 디스크로 스왑하는 등의 작업은 상당히 어려웠을 것
   - 커널이 자체 주소 공간을 가진다면 사용자 프로그램들과 커널 간의 데이터 이동이 매우 복잡하고 고통스러울 것
  
5. 운영체의 자료를 보호하기 위해서 하드웨어가 페이지 별로 보호 수준을 다르게 설정할 수 있어야 하는데, 이를 위해 VAX는 페이지 테이블의 Protectio Bit에 보호 수준을 지정
   - 즉, 특정 페이지 접근을 위해 필요한 CPU의 권한 수준이 기록
   - 시스템 데이터와 코드는 사용자 데이터의 코드보다 더 높은 보호 수준으로 지정
   - 사용자 코드가 더 높은 보호 수준의 자료를 접근하려고 시도하면 운영체제로 트랩이 걸릴 것이며, 트랩을 일으킨 프로세스는 종료

-----
### 널 포인터 접근
-----
1. 프로세스는 다음과 같은 동작을 통해 가상 주소 0번지를 만들어냄
```c
int *p = NULL; // p = 0 설정
*p = 10; // 가상 주소 0에 10을 저장 시도
```

2. 하드웨어는 TLB에서 VPN(여기서 0) 검색을 시도하지만 TLB 미스
   - 페이지 테이블이 검색되며 VPN 0에 대한 항목이 무효로 표시되어 있는 것을 알게 됨
   - 무효한 접근이 발생했으므로 운영체제로 제어가 전달
   - 그러면 운영체제는 해당 프로세스를 종료할 것 (UNIX 시스템에서는 이런 폴트에 대해 대응할 수 있도록 프로세스에게 시그널 전달되며, 시그널을 캐치하지 않으면 프로세스는 종료)
