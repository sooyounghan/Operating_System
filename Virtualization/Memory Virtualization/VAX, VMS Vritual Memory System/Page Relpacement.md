-----
### 페이지 교체
-----
1. VAX의 페이지 테이블 항목(PTE)은 다음과 같은 비트를 가짐
   - 유효(Valid) 비트
   - 보호 필드(Protection Field, 4비트)
   - 변경(Modify 또는 더티(Dirty)) 비트
   - 운영체제가 사용하기 위해 예약해놓은 필드 (5비트)
   - 물리 메모리 페이지의 위치를 저장하기 위해 물리 프레임 번호 (VPN)
   - Reference Bit는 없음 : 따라서, VMS 교체 알고리즘은 어떤 페이지가 자주 사용중인지를 하드웨어 지원 없이 판단하여야 함

2. 메모리 호그(Memory Hog)는 메모리를 너무 많이 사용하는 프로그램을 의미
   - 이러한 프로세스에 대한 대비책이 없음
   - 예를 들어, LRU는 프로세스 간 공정한 메모리 분배는 고려하지 않는 전역적(Global) 정책

3. 세그먼트된 FIFO
   - 각 프로세스는 상주 집합 크기(Resident Set Size, RSS)라고 불리는 메모리에 유지할 수 있는 최대 페이지 개수를 지정받음
   - 각 페이지들은 FIFO 리스트에 보관되며, 페이지 개수가 RSS보다 커지면 가장 먼저 들어있던 페이지가 나가게 되며, FIFO는 하드웨어 지원이 필요 없으므로 구현이 간단
   - 순수한 FIFO 성능은 좋지 않으므로, FIFO 성능을 개선하기 위해 VMS는 전역 클린-페이지 프리 리스트(Global Clean-Page Free List)와 더티 페이지 리스트(Dirty Page List)라고 하는 두 개의 Second-Change List를 도입
     + 이 리스트는 전역 자료 구조로서, 메모리에서 제거되기 전 페이지가 보관되는 리스트
     + 프로세스 P가 자신의 RSS를 넘긴다면 자신의 FIFO에서 페이지가 제거되며, 제거된 페이지가 클린 상태(수정 안된)라면, 클린-페이지 리스트에, 더티 상태라면 (변경된) 더티-페이지 리스트에 추가
     + 다른 프로세스 Q에 빈 페이지가 필요하면 전역 클린 리스트에서 첫 번쨰 프리 페이지를 꺼내며, 원래의 프로세스 P가 해당 페이지가 회수 되기 전 그 페이지에 대해 폴트를 발생시키면, P는 프리(또는 더티) 리스트에서 페이지를 가져와서 다시 사용하게 됨
   - 이런 식으로 디스크 접근을 피하며, 전역 Second-Change List의 크기가 클수록 세그먼트된 FIFO 알고리즘은 LRU와 유사하게 동작

4. 페이지 클러스터링
   - VMS 작은 페이지 크기를 극복하는 방법
   - 페이지 크기가 작을수록 스왑할 때 디스크 I/O가 비효율적이 됨 (디스크는 전송 단위가 클수록 성능이 좋아짐)
   - 스왑할 때 I/O 효율을 개선하기 위해 VMS는 몇 가지 최적화 기법 도입
     + 그 중 가장 중요한 것은 클러스터링(Clustering)이며, 이 기법을 써서 VMS는 전역 더티 리스트에 있는 페이지들을 작업 묶음을 만들어서 한 번에 디스크로 보냄 (그렇게 해서 클린 상태로 만듬)
     + 운영체제는 스왑 공간 어디에든 페이지들을 자유롭게 배치할 수 있으므로, 페이지들을 그룹으로 묶어서 쓰는 것이 가능
     + 쓰기 횟수를 줄이고 한 번에 쓰는 양을 늘려서 성능을 향상시키므로 클러스터링은 현대 시스템에서 사용
