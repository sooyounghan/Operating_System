-----
### 동적(하드웨어-기반) 재배치
-----
1. 1950년대 후반 첫 번째 시분할 컴퓨터에서 베이스와 바운드(Base and Bound)라는 간단한 아이디어 채택
   - 동적 재배치(Dynamic Relocation)라고도 함

2. 각 CPU마다 2개의 하드웨어 레지스터가 필요
   - 베이스(Base) 레지스터
   - 바운드(Bound) 레지스터 또는 한계(Limit) 레지스터
   - 이 두 쌍은 우리가 원하는 위치에 주소 공간을 배치할 수 있게 하며, 배치와 동시에 프로세스가 오직 자신의 주소 공간에만 접근한다는 것을 보장

3. 이 설정에서 각 프로그램은 주소 0에 탑재되는 것처럼 작성되고 컴파일
   - 프로그램 시작 시, 운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정하고 베이스 레지스터로 그 주소를 지정
   - 위 예에서 운영체제는 프로세스를 물리 주소 32 KB에 저장하기로 결정하고, 베이스 레지스터를 이 값으로 설정
   - 프로세스가 실행되면서, 프로세스에 의해 생성되는 모든 주소가 다음과 같은 방법으로 프로세서에 의해 변환
```
physical address = virtual address + base
```
   - 💡 프로세스가 생성하는 메모리 참조는 가상 주소이며, 하드웨어는 베이스 레지스터의 내용을 이 주소에 더하여 물리 주소를 생성
   - 이를 이해하기 위해 명령어가 실행될 때의 상황
```
128: movl 0x0(%EBX), % eax
```
   - 프로그램 카운터(PC)는 128로 설정
   - 하드웨어가 이 명령어를 반입할 때, 먼저 PC 값을 베이스 레지스터 값 32KB(32768)에 더해 32896의 물리 주소를 얻음
   - 그런 후 하드웨어는 해당 물리 주소에서 명령어를 가져옴
   - 그리고 프로세서는 명령어의 실행을 시작
   - 얼마 후 프로세스는 가상 주소 15 KB의 값을 탑재하라는 명령어를 내림
   - 이 주소를 프로세서가 받아 다시 베이스 레지스터(32KB)를 더하고 물리 주소 47KB에서 원하는 내용을 탑재
   - 위 상황이 바로 가상 주소에서 물리 주소로의 주소 변환을 의미

4. 하드웨어는 프로세스가 참조하는 가상 주소를 받아들여 데이터가 실제로 존재하는 물리 주소로 변환
   - 이 주소의 재배치는 실행 시에 일어나고, 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있으므로, 동적 재배치라고도 불림

5. 바운드 레지스터는 보호를 지원하기 위해 존재
   - 프로세서는 먼저 메모리 참조가 합법적인가 확인을 위해 가상 주소가 바운드 안에 있는지 확인
   - 위의 예에서 바운드 레지스터는 항상 16KB로 설정
   - 프로세스가 바운드보다 큰 가상 주소 또는 음수인 가상 주소를 참조하면 CPU는 예외를 발생시키고 프로세스는 종료될 것
   - 바운드의 요점은 프로세스가 생성한 모든 주소가 합법적이고 프로세스의 범위에 있다는 것을 확인하는 것

6. 베이스와 바운드 레지스터는 CPU 칩 상 존재하는 하드웨어 구조 (CPU 당 1쌍)
   - 주소 변환에 도움을 주는 프로세서 일부 : 메모리 관리 장치(Memory Management Unit, MMU)
   - 더 정교한 메모리 관리 기법을 개발할수록 MMU에 더 많은 회로를 추가하게 될 것

7. 바운드 레지스터는 두 가지 방식 중 하나로 정의될 수 있음
   - 한 가지 방법은 주소 공간의 크기를 저장하는 방식으로, 하드웨어는 가상 주소를 베이스 레지스터에 더하기 전 먼저 바운드 레지스터와 비교
   - 두 번째 방법은 주소 공간의 마지막 물리 주소를 저장하는 방식으로, 하드 웨어는 먼저 베이스 레지스터를 더하고 그 결과가 바운드 안에 있는 검사
   - 두 방법 모두 논리적으로 동일함

8. 예제
   - 주소 공간 크기가 4KB인 프로세스가 물리 주소 16 KB에 탑재되었다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/8dee71e8-9c7b-429b-b5d8-78aee111b2bf">
</div>

   - 물리 주소를 얻기 위해서는 간단히 가상 주소에 베이스 주소를 더하면 됨
   - 가상 주소를 주소 공간 내에서의 오프셋을 나타낸다고 생각할 수 있음
   - 가상 주소가 너무 크거나 음수일 경우 폴트를 일으키고 예외가 발생하게 됨

-----
### 소프트웨어-기반 재배치 (정적 재배치, Static Relocation)
-----
1. 초창기 하드웨어 지원이 제공되기 전 일부 시스템은 소프트웨어만으로 재배치 수행
2. 로더(Loader)라 불리는 소프트웨어가 실행하고자 하는 실행 파일의 모든 주소를 원하는 물리 메모리 오프셋으로 변경
3. 예를 들어, 명령어가 주소 1000번지로부터 레지스터로 탑재하는 경우(예) movl 1000, %eax) 그리고 프로그램 주소 3000부터 탑재되었다면(프로그램이 생각하는 주소 0이 아닌), 로더는 명령어의 모든 주소를 3000씩 이동한 주소로 다시 작성 (예) movl 4000, %eax)
4. 즉, 간단하게 프로세스 주소 공간의 정적 재배치가 이루어짐
5. 문제점
   - 보호 기능이 없음 : 잘못된 주소를 생성하여 다른 프로세스나 운영체제의 메모리를 불법적 접근 가능 (제대로 보호하기 위해 하드웨어 지원 필요)
   - 한 번 배치되면 추후 주소 공간 재배치가 어려움

-----
### 하드웨어 기반 동적 재배치
-----
1. 베이스 레지스터는 프로그램에 의해 생성된 가상 주소를 물리 주소로 변환하는 데 사용
2. 바운드(또는 한계) 레지스터는 이 가상 주소가 주소 공간의 범위 내 있다는 것을 보장
3. 두 레지스터는 함께 간단하고 효율적인 메모리 가상화 제공
