-----
### 요약
-----
1. 주소 변환을 사용하면 운영체제는 프로세스의 모든 메모리에 접근을 제어할 수 있고, 접근이 항상 주소 공간의 범위 내에서 이루어지도록 보장할 수 있음 (하드웨어 지원)
   - 하드웨어 지원은 프로세스가 이해하는 메모리인 가상 주소를 실제 메모리 모습인 물리 주소로 변환하며 이 변환을 빠르게 수행
   - 이 모든 것은 재배치된 프로세스에게 투명한 방식으로 이루어짐

2. 베이스와 바운드(Base-and-Bound) 또는 동적 재배치로 알려진 가상화의 한 형태
   - 베이스 레지스터를 가상 주소에 더하고 생성된 주소가 바운드를 벗어나는지 검사하기 위한 간단한 하드웨어 회로만 추가하면 되므로 Base-and-Bound 가상화는 매우 효율적
   - 또한 보호 기능도 제공
   - 운영체제와 하드웨어는 협력하여 프로세스가 자신의 주소 공간 이외 밖 메모리를 참조할 수 없도록 함 (보호는 운영체제의 가장 중요한 목표 중 하나)

3. 동적 재배치는 비효율적
   - 재배치된 프로세스는 32 ~ 48 KB까지의 물리 메모리를 사용함
   - 그러나 프로세스 스택과 힙이 아주 크지 않으므로, 둘 사이의 공간이 단순히 낭비되고 있음
   - 할당된 영역의 내부 공간이 사용되지 않으므로, 즉 단편화가 발생되어 낭비 : 이런 유형의 낭비를 내부 단편화(Internal Fragmentation)
     + 현재 접근 방식에서 비록 더 많은 프로세스를 탑재할 수 있는 충분한 물리 메모리가 있더라도, 고정 크기 슬롯에 주소 공간을 배치해야하므로 내부 단편화가 발생   
     + 다른 해결책은 고정 크기 스택을 코드 바로 아래 배치하고, 힙을 그 아래에 배치하여 힙이 아래쪽으로 배치하는 방법이 있지만, 이 방법은 재귀 호출과 함수 호출의 중첩이 길면 구현을 어렵게 만들어짐
   - 따라서, 물리 메모리의 이용률을 높이고 내부 단편화 방지를 위한 더 정교한 기법이 필요
     + Base-and-Bound 일반화된 기법을 세그멘테이션(Segmentation)이라 부름
