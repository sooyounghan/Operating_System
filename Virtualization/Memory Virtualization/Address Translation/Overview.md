-----
### 주소 변환의 원리
-----
1. 제한적 직접 실행(LDE)의 원리
   - 대부분의 경우 프로그램은 하드웨어에서 직접 실행
   - 그러나 프로세스가 시스템 콜을 호출하거나 타이머 인터럽트가 발생할 때 특정 순간에는 운영체제가 개입하여 문제가 발생하지 않도록 함
   - 운영체제는 약간의 하드웨어 지원을 받아 효율적인 가상화를 제공하기 위해 프로그램에게 방해가 되지 않도록 최선을 다함
   - 즉, 중요한 순간에 운영체제가 관여하여 하드웨어를 직접 제어

2. 메모리 가상화도 역시 비슷한 전략을 추구
   - 가상화를 제공하는 동시에 효율성(Efficiency)과 제어(Control) 모두 추구
   - 효율성을 높이려면 하드웨어 지원을 활용할 수 밖에 없음
   - 제어는 응용 프로그램이 자기자신의 메모리 이외에 다른 메모리에 접근하지 못한다는 것을 운영체제가 보장하는 것을 의미
   - 프로그램을 다른 프로그램으로부터 보호하고 운영체제를 프로그램으로부터 보호하기 위해 하드웨어 도움이 필요
   - 유연성 측면에서도 VM 시스템에 필요한 사항이 있는데, 프로그래머가 원하는 대로 주소 공간을 사용하고, 프로그래밍하기 쉬운 시스템을 만들기 원함

3. 하드웨어-기반 주소 변환(Hardware-based Address Translation) 또는 주소 변환(Address Translation)
   - 주소 변환을 통해 하드웨어는 명령어 반입, 탑재, 저장 등 가상 주소를 정보가 실제 존재하는 물리 주소로 변환
   - 프로그램의 모든 메모리 참조를 실제 메모리 위치로 재지정하기 위해 하드웨어가 주소를 변환
   - 물론, 하드웨어만으로 메모리 가상화를 구현할 수 없으며, 하드웨어를 셋업하기 위해 운영체제가 관여해야 함
   - 운영체제는 메모리의 빈 공간과 사용 중인 공간을 항상 알고 있어야 하고, 메모리 사용을 제어하고 관리

4. 목표
   - 프로그램이 자신의 전용 메모리를 소유하고 그 안에 자신의 코드와 데이터가 있다는 환상을 만드는 것
   - CPU가 실행 중인 한 프로그램에서 다음 프로그램으로 전환하는 것처럼, 많은 프로그램이 메모리를 공유

-----
### 가정
-----
1. 당분간 사용자 주소 공간은 물리 메모리에 연속적으로 배치되어야 한다고 가정
2. 단순화를 위해 주소 공간의 크기가 너무 크지 않다고 가정
3. 주소 공간은 물리 메모리 크기보다 작으며, 또한 각 주소 공간의 크기는 같다고 가정

-----
### 사례
-----
1. 주소 변환 구현을 위해 필요한 것과 필요한지에 대한 사례
2. 프로세스가 다음과 같이 있다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/997e7ef1-63b2-4853-ab1a-795d55d43668">
</div>

   - 코드는 메모리에서 값을 탑재하고, 3을 증가시키고, 다시 메모리에 저장하는 짧은 코드
```c
void func() {
  int x = 3000;
  x = x + 3; // 우리가 관심있는 코드
}
```

   - 컴파일러는 이 코드를 어셈블리 코드로 변환하고 그 결과는 x86 어셈블리로 다음과 같음
```
128: movl 0x0(\%ebx) , \%eax ; 0+ebx를 eax에 저장
132: addl \$0x03 , \%eax ; eax 레지스터에 3 더함
135: movl \%eax , 0x0(\%ebx) ; eax를 메모리에 다시 저장
```

   - x의 주소는 레지스터 ebx에 저장되어 있다고 가정하고, 이 주소에 저장되어 있는 값을 movl 명령어(예) longword를 이동하는 명령어)를 사용하여 범용 레지스터 eax에 넣음
   - 다음 명령은 eax에 3을 더함
   - 마지막 명령은 eax의 값을 같은 위치의 메모리에 저장

   - 세 개 명령어 코드는 주소 128에 위치하고, 변수 x의 값은 주소 15KB(아래쪽 스택)에 위치하며, x의 초기값은 3000(스택 영역 참조)
   - 이 명령어가 실행되면 프로세스 관점에서 다음과 같은 메모리 접근 발생
     + 주소 128 명령어 반입
     + 이 명령어 실행 (주소 15KB에서 탑재)
     + 주소 132의 명령어 반입
     + 이 명령어 실행 (메모리 참조 없음)
     + 주소 135의 명령어 반입
     + 이 명령어 실행 (15KB에 저장)

3. 프로그램 관점에서 주소 공간은 주소 0부터 시작하여 최대 16KB까지이며, 프로그램이 생성하는 모든 메모리 참조는 이 범위 내 있어야 함
   - 메모리 가상화를 위해 운영체제는 프로세스를 물리 메모리 주소 0이 아닌 다른 곳에 위치시키고 싶음
   - 즉, 프로세스 모르게 메모리를 다른 위치에 재배치를 해야함
   - 프로세스 주소 공간이 메모리에 배치되었을 때 가능한 물리 메모리 배치 예
<div align="center">
<img src="https://github.com/user-attachments/assets/6b3bff09-f2e4-440b-914b-812fc61daf58">
</div>

   - 물리 메모리의 첫 번째 슬롯은 운영체제 자신이 사용
   - 프로세스는 물리 주소 32 KB에서 시작하는 슬롯에 재배치 (다른 두 슬롯 16 ~ 32 KB, 48 ~ 64 KB은 비어 있음)
