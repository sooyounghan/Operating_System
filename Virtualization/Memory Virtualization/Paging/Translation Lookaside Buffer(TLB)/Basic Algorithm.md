-----
### TLB 기본 알고리즘
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/24ab0cf5-d186-4278-b633-fa334b3a7552">
</div>

1. 주소 변환부가 단순한 선형 페이지 테이블(Linear Page Table, 즉 배열로 이루어진 페이지 테이블)과 하드웨어로 관리되는 TLB(하드웨어가 페이지 테이블 접근에 대한 대부분 책임을 관리)
2. 먼저, 가상 주소에서 가상 페이지 번호 (VPN)을 추출한 후, 해당 VPN의 TLB 존재 여부를 검사
   - 존재 : TLB 히트
     + TLB가 변환 값을 가지고 있다는 것을 뜻함
     + 해당 TLB 항목에서 페이지 프레임 번호(Page Frame Number, PFN)을 추출
     + 해당 페이지에 대한 접근 권한 검사가 성공하면, 그 정보를 원래 가상 주소의 오프셋과 합쳐서 원하는 물리 주소(PA)를 구성하고, 메모리에 접근할 수 있음

   - 존재하지 않음 : TLB 미스
     + 하드웨어가 변환 정보를 찾기 위해 페이지 테이블에 접근
     + 프로세스가 생성한 가상 메모리 참조가 유효하고 접근 가능하다면, 해당 변환 정보를 TLB로 읽어들임 (매우 시간이 많이 소요되는데, 페이지 테이블 접근을 위한 메모리 참조 때문임)
     + TLB가 갱신되면 하드웨어는 명령어를 재실행하고, TLB 변환 정보가 존재함으로 메모리 참조가 빠르게 처리

3. TLB는 주소 변환 정보가 대부분의 경우 캐시에 있다(즉, 캐시 히트)라는 가정을 전제로 만들어짐
   - TLB는 프로세싱 코어와 가까운 곳에 위치하고 있고, 매우 빠른 하드웨어로 구성되어있으므로, 주소 변환 작업은 부담스러운 작업이 아님
   - 단, 미스가 발생하는 경우, 페이징 비용이 커지며, 페이지 테이블에 접근하여 변환 정보를 찾아야함
     + 메모리 참조(또는 페이지 테이블이 복잡하다면)가 많이 추가
     + 이 상황이 자주 발생하면 프로그램은 상당히 느려지게 됨 (메모리 접근 연산은 다른 CPU 연산(예) 곱하기, 더하기 등)에 비해 매우 시간이 오래 걸림
   - TLB 미스가 많이 발생할수록, 접근 횟수가 많아지며, 따라서 TLB 미스를 최대한 피해야 함
