-----
### TLB의 문제 : 문맥 교환
-----
1. TLB를 사용하게 되면 프로세스 간 (주소 공간들로 인해) 문맥 교환시 새로운 문제 발생
   - TLB에 있는 가상 주소와 실제 주소 간 변환 정보는 해당 프로세스에서만 유효하며, 다른 프로세스들에게 의미가 없음
   - 즉, 새로운 프로세스에서는 이전 실행하던 프로세스 변환 정보를 사용하지 않도록 주의해야함

2. 예) 하나의 프로세스 (P1)가 실행중이라고 가정하며, 이 프로세스는 TLB가 자신에게 유효한 변환 정보를 캐싱하고 있다고 가정
   - 즉, P1의 페이지 테이블의 내용을 가지고 있다고 가정하며, P1의 10번째 가상 페이지가 물리 프레임 100에 매핑되었다고 가정
   - 또 다른 프로세스 P2가 존재하며, 운영체제가 곧 문맥 교환을 수행하기로 결정하여 이 프로세스를 실행시키려고 가정하며, P2의 10번쨰 가상 페이지는 물리 프레임 170에 매핑되었다고 가정
   - 문제 : VPN 10에 대한 변환 정보가 두 개 존재
     + 10번 VPN이 PFN 100(P1)와 PFN 170(P2)으로 변환될 수 있음
     + 하지만, 어떤 프로세스를 위 항목인지 알 수 있는 방법이 없으므로, TLB가 정확하고 효율적인 멀티 프로세스 간 가상화 지원을 위한 추가적 기능이 필요
<div align="center">
<img src="https://github.com/user-attachments/assets/11135303-98a5-4171-9ba4-c3bfd73c6092">
</div>

   - 이 문제는 여러 가지 해법 가능
     + 문맥 교환을 수행할 때 다음 프로세스가 실행되기 전 기존 TLB 내용을 비우는 것 : 소프트웨어 기반 시스템에서는 특별한(특권을 갖는) 하드웨어 명령어를 사용해 목적 달성 가능
     + 하드웨어로 관리되는 TLB는 페이지 테이블 베이스 레지스터가 변경될 때 비우기를 시작할 수 있음 (운영체제는 문맥 교환을 할 때 PTBR를 변경해야 함)
     + 둘 중 어느 경우든 비우는 작업은 모든 Valid Bit를 0으로 설정하는 것
     + 문맥 교환을 할 때, TLB를 비우면 잘못된 변환 정보를 사용하는 상황을 방지할 수 있지만, 비용이 발생 (새로운 프로세스가 실행될 때, 데이터와 코드 페이지에 대한 접근으로 인한 TLB 미스가 발생하게 되고, 문맥 교체가 빈번히 발생하면, 이 또한 성능에 큰 부담을 가져올 수 있음)

   - 이 부담 개선을 위해 몇몇 시스템에서는 문맥 교환이 발생하더라도 TLB을 보존할 수 있는 하드웨어 기능 추가
     + TLB 내 주소 공간 식별자(Address Space Identifier, ASID)필드를 추가하는 것 (프로세스 식별자(Process Identifier, PID)와 대략적으로 유사)
     + 단, ASID는 좀 더 적은 비트를 가지고 있음 (ASID는 8비트, PID는 32비트)

   - TLB 공간에 ASID 정보를 추가하면, TLB 공간을 프로세스들이 공유 가능
<div align="center">
<img src="https://github.com/user-attachments/assets/3191f91f-7bdc-4d20-a4b7-fa2a62d6a08a">
</div>

   - 주소 공간 식별자를 사용하면, 프로세스 별로 TLB 변환 정보를 구분할 수 있음
     + 올바른 주소 변환을 위해 하드웨어는 현재 어떤 프로세스가 실행 중인지 파악하고 있어야 함
     + 이를 위해, 문맥 전환 시, 운영체제는 새로운 ASID 값을 정해진 레지스터에 탑재

   - TLB의 두 항목이 매우 유사한 경우
     + 예) 두 개의 다른 VPN을 갖는 두 개의다른 프로세스들의 두 항목이 모두 동일한 물리 페이지를 가리키는 경우
<div align="center">
<img src="https://github.com/user-attachments/assets/b89a2dfa-f422-487f-b4c1-527a2da25dc8">
</div>

   - 두 개의 프로세스들이 하나의 페이지(코드 페이지)를 공유하고 있을 때 발생이 가능 (프로세스 1이 물리 페이지 101을 프로세스 2와 공유)
     + P1은 이 페이지를 자신의 주소 공간의 10번째 페이지에 매핑
     + P2는 자신의 주소 공간의 50번째 페이지에 매핑
     + 코드 페이지를 공유하는 것은 (바이너리 또는 공유 라이브러리) 사용되는 물리 페이지 수를 줄일 수 있으므로 유용하고, 메모리 부하도 줄일 수 있음
