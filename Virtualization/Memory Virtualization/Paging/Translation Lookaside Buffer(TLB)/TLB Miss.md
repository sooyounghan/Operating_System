-----
### TLB 미스 처리
-----
1. 하드웨어와 소프트웨어(운영체제)가 담당
2. 과거 하드웨어는 복잡한 명령어로 구성 : CISC(Complex Instruction Set Computing)
   - TLB 미스를 하드웨어가 처리하도록 설계하였고, 이를 위해 하드웨어가 페이지 테이블에 대한 명확한 정보를 가지고 있어야 함
   - 메모리 상 위치(Page-Table Base Register)와 정확한 형식을 파악하고 있어야 함
   - 미스 발생 시 하드웨어의 동작
     + 페이지 테이블에서 원하는 페이지 테이블 엔트리를 찾음
     + 필요한 변환 정보 추출
     + TLB를 갱신
     + 💡 TLB 미스가 발생한 명령어를 재실행
   - 인텔 x86 CPU가 하드웨어로 관리되는 것을 사용


3. CISC보다 최근에 등한 컴퓨터 구조 : RISC (Reduced Instruction Set Computing)
<div align="center">
<img src="https://github.com/user-attachments/assets/f7663fea-9b5a-4515-8ed6-cfdb641099db">
</div>

   - 소프트웨어 관리 TLB를 사용
   - RISC 기반 컴퓨터에서 TLB 미스 처리 과정
     + TLB에서 주소를 찾는 것을 실패하면, 하드웨어는 예외(Exception) 시그널을 발생
     + 예외 시그널을 받은 운영체제는 명령어 실행을 잠정 중지하고, 실행 모드를 커널 모드로 변경하여 커널 코드 실행을 준비
     + 실행 모드를 커널 모드로 변경하는 작업은 커널 주소 공간을 접근할 수 있도록 특권 레벨(Privilege Level)로 상향 조정하는 것
     + 커널 모드로 변경이 되면 트랩 핸들러(Trap Handler)를 실행하며, 트랩 핸들러는 TLB 미스의 처리를 담당하는 운영체제 코드로, 페이지 테이블을 검색하여 변환 정보를 찾고, TLB 접근이 가능한 특권 명령어를 사용해 TLB를 갱신 후 리턴
     + 💡 트랩 핸들러가 리턴되면 하드웨어 명령어가 재실행
     + 트랩 핸들러가 TLB를 갱신했으므로 TLB 히트

4. TLB 미스를 처리하는 트랩 핸들러는 시스템 콜 호출 시 사용되는 트랩 핸들러와 차이 존재
   - 시스템 콜 : 트랩 핸들러에서 리턴 후 시스템 콜을 호출한 명령어의 다음 명령어를 실행 (일반적인 프로시저 콜과 동일 : 프로시저 콜이 리턴되면, 프로시저를 호출한 다음 라인부터 시행이 시작됨)
   - TLB : TLB 미스 처리의 경우, 트랩에서 리턴하면 트랩을 발생시킨 명령을 다시 실행해야하며, 재실행 시에는 TLB에서 히트가 발생
     + 즉, 트랩이 발생하면 운영체제는 트랩 핸들러가 종료되었을 때, 다시 실행을 계속할 명령어 주소(Program Counter 값)를 저장
   - 💡 운영체제는 트랩 발생의 원인에 따라 현재 명령어의 PC 값 또는 다음 명령어의 PC 값 저장

5. TLB 미스 핸들러를 실행할 때, TLB 미스가 무한 반복되지 않도록 주의해야 함
   - TLB 미스 핸들러를 접근하는 과정에서 TLB 미스가 발생하는 상황
   - TLB 미스 핸들러를 물리 메모리에 위치시키는 해결 방법 : TLB 미스 핸들러의 주소는 핸들러의 물리 주소로 표시되며, 이 경우 해당 TLB 미스 핸들러는 unmap되어 있으며 주소 변환이 필요 없음
   - TLB 일부를 핸들러 코드 주소를 저장하는데 영구히 할당 : TLB 핸들러는 항상 TLB에서 히트되며, 연결(Wired) 변환이라고 함

6. TLB를 소프트웨어에서 관리하는 방식의 주된 장점 : 유연성 및 단순함
   - 운영체제는 하드웨어 변경없이 페이지 테이블 구조를 자유로이 변경할 수 있음
   - TLB 제어 흐름이 미스가 발생하였을 때 하드웨어는 할 일이 별로 없으며, 에외가 발생하면 운영체제의 TLB 미스 핸들러가 나머지 일 처리
