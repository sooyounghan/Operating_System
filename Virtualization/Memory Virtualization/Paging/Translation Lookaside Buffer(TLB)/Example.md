-----
### 예제 : 배열 접근
-----
1. TLB의 작동 과정 : 간단한 가상 주소 트레이스를 대상으로 TLB로 인한 성능 개선 예시
2. 가상 주소 100번지부터 10개 4바이트 크기의 정수 배열이 존재
   - 가상 주소 공간은 8비트이며, 페이지 크기는 16바이트
   - 가상 주소는 4비트 VPN(16개의 가상 페이지 표현)과 4바이트 오프셋(각 페이지는 16바이트 크기를 가짐)으로 구성
   - 16개의 페이지로 구성된 가상 주소 공간
<div align="center">
<img src="https://github.com/user-attachments/assets/44c385b0-104e-41b8-82d7-b3eae0660f59">
</div>

   - 배열의 첫 항목(a[0])은 (VPN = 06, 오프셋 = 04)에서 시작
   - 세 개의 4바이트 정수가 페이지에 들어갈 수 있음
   - 배열은 다음 페이지(VPN = 07)에서 계속 되며, a[3], ..., a[6]의 네 항목이 존재
   - 배열의 마지막 3개 항목은 (a[7], ..., a[9])는 주소 공간(VPN = 08)에 시작하는 다음 페이지에 들어가 있음

3. 배열 원소의 합을 구하는 코드
```c
int sum = 0;

for (i = 0; i < 10; i++) {
    sum += a[i];
}
```

4. 메모리 접근 단순화를 위해 변수 i, sum 그리고 명령어를 위한 메모리 접근은 무시하고, 정수 배열에 대한 메모리 접근만 확인
   - 첫 번째 배열의 항목(a[0])이 접근
     + 가상 주소 100번이며, 하드웨어는 VPN을 추출하며, VPN은 06번
     + 하드웨어는 TLB에서 해당 VPN을 검색 (TLB는 완전히 초기화되어있다고 가정)
     + 첫 접근이므로 VPN 미스가 발생하고, 미스가 발생하면 해당 VPN 06에 대한 물리 페이지 번호를 찾아 TLB에 갱신

   - a[1]을 읽음
     + TLB 히트로서, 두 번쨰 항목은 첫 번째 항목과 같은 페이지에 존재
     + 첫 번째 항목을 읽을 때, 이미 해당 페이지를 접근하였으므로 필요한 변환 정보가 TLB에 이미 탑재
     + 두 번째 항목을 읽을 때, TLB 히트가 발생
     + a[2]에 대한 접근도 동일 (같은 페이지에 존재)

   - a[3]은 TLB 미스, a[4] ~ a[6]은 메모리 내 같은 페이지에 있으믈 TLB 히트
   - a[7]를 접근할 때 마지막 TLB 미스가 발생
     + 하드웨어는 페이지를 테이블을 참고하여 가상 페이지에 해당하는 물리 메모리를 파악한 후 TLB를 갱신
     + 마지막 두 접근(a[8], a[9])은 이미 갱신된 TLB에서 주소 변환 정보를 얻어 TLB 히트가 두 번 발생

   - TLB 동작 정리 : 미스 / 히트 / 히트 / 미스 / 히트 / 히트 / 히트 / 미스 / 히트 / 히트가 됨
     + 히트 횟수를 총 접근 횟수로 나누어 얻음 : TLB 히트 비율 (70%)
     + 배열이 처음으로 접근되었지만, TLB은 공간 지역성(Spatial Locality)으로 인해 성능을 개선할 수 있음
     + 배열의 항목들이 페이지 내에서 서로 인접해있기 때문에, 페이지에서 첫 번째 항목을 접근할 때만 TLB 미스 발생

5. 페이지 크기는 TLB 효용성에 매우 중요한 역할을 함
   - 페이지 크기가 2배가 되면(16이 아니라 32바이트), TLB 미스 횟수는 더 줄어듬
   - 일반적인 경우 페이지는 4KB이며, 정수 배열을 연속적으로 접근하는 프로그램의 경우에는 특히 TLB 사용은 큰 성능 개선 효과를 가져옴 (페이지 접근 시 한 번의 미스만 발생)

6. 만약 예제 프로그램 종료 후에도 배열을 사용한다면, 성능이 더욱 개선
   - 모든 주소 변환 정보가 TLB에 탑재되어 있으므로, TLB가 모든 주소 변환 정보를 저장할 정도로 충분히 크다면 모두 히트를 얻음
   - 이 경우에는 시간 지역성(Temporal Locality)로 인해 TLB 히트율이 높아짐 (시간 지역성 : 한 번 참조된 메모리 영역이 짧은 시간 내 다시 참조되는 현상)

7. 다른 캐시와 마찬가지로 TLB의 성공 여부는 프로그램의 공간 지역성과 시간 지역성 존재 여붕 ㅔ따라 달려 있음
   - 만약 프로그램이 공간 혹은 시간 지역성을 보이는 경우, TLB 사용 효과가 더욱 두드러지게 나타날 것이며, 실제 많은 프로그램이 공간 지역성이나 시간 지역성을 띠고 있음

-----
### 참고 : 가능한 캐싱을 사용
-----
1. 캐싱은 컴퓨터 시스템에서 사용되는 가장 근본적인 성능 개선 기술들 중 하나
2. 일반적인 경우를 빠르게 하기위해 오랜 시간 적용되어온 방법으로, 하드웨어 캐시 사용의 근본 취지는 데이터 참조에 있어서 지역성을 활용하는 것
3. 시간 지역성 : 최근에 접근된 명령어 또는 데이터는 곧 다시 접근될 확률이 높다는 사실에 근거 (for, while문의 경우 반복문에 사용되는 변수나 명령어들은 일정 시간 동안 반복적으로 접근)
4. 공간 지역성 : 프로그램 메모리 주소 x를 읽거나 쓰면, x와 인접한 메모리 주소를 접근할 확률이 높다는 사실에 근거 (배열을 순차적으로 읽는 프로그램)
5. 모든 하드웨어 캐시의 목적은 필요한 메모리 내용을 매우 빠른 CPU 칩 내의 메모리에 위치시키고, 접근 지역성을 최대한 활용하는 것
   - 이 원리는 명령어 캐시, 데이터 캐시, 그리고 주소 변환 캐시 등 모든 하드웨어 캐시에 적용
   - CPU가 메모리 내용을 참조할 때, (느린) 메모리 참조가 아닌 우선 캐시에 사본이 있는지 확인하고, 캐시에 원하는 내용이 존재하면 프로세서는 원하는 내용을 빠르게 접근할 수 있으며,(즉, 몇 CPU 사이클 내) 메모리 접근을 위한 시간 절약
  
