-----
### 메모리 트레이스
-----
1. 현대 운영체제 메모리 관리 서브 시스템에서 가장 중요한 자료 구조 중 하는 페이지 테이블
   - 일반적으로 페이지 테이블은 가상-물리 주소 변환 (Virtual-to-Physical Address Translation)을 저장하여 주소 공간의 각 페이지의 물리 메모리 위치를 알 수 있게 함
   - 각 주소 공간은 변환을 필요로 하므로 페이지 테이블은 프로세스마다 하나씩 존재
    
2. 간단한 메모리 액세스 예를 통해 페이징을 사용했을 때 발생하는 모든 메모리 접근 확인
   - array.c
```c
int array[1000];

...

for (i = 0; i < 1000; i++)
    array[i] = 0;
```
   - 실행
```
prompt> gcc −o array array . c −Wall −O
prompt> ./array
```
  - 루프 안에서 배열을 초기화하기 위해 어떤 어셈블리 명령어가 실행되는지 보기 위해 결과 이진 파일을 디스어셈블(Disassemble)해야함 (Linux는 objdump, Mac은 otool 사용)
    + 어셈블리 코드
```
0x1024 movl $0x0, (%edi, %eax, 4)
0x1028 incl %eax
0x102c cmpl $0x03e8, %eax
0x1030 jne 0x1024
```
  - 첫 번째 명령어 : 값 0($0x0)을 가상 메모리 주소로 옮기며, 0 값이 저장될 가상 메모리 주소는 %edi의 값을 %eax의 4배에다 더해서 계산
    + %edi : 배열의 시작 주소를 저장
    + %eax : 배열 인덱스(i) 저장
    + 배열은 정수 배열이고 정수의 크기는 4바이트이므로 4를 곱함

  - 두 번째 명령어 : %eax에 저장된 배열 인덱스를 증가

  - 세 번째 명령어 : %eax의 값과 16진수 0x03e8 또는 십진수 1000을 비교
  - 네 번째 명령어 : 두 값이 같지 않다면 (jne 명령어는 검사하는 명령어), 루프의 상단으로 다시 분기

3. 이 명령어 시퀀스가 (가상 및 물리 수준 모두에서) 어떤 메모리 접근을 생성하는지 이해하기 위해서, 코드와 배열의 가상 메모리 주소와 페이지 테이블 위치에 대한 가정 필요
   - 이 예에서 크기가 64KB인 가상 주소 공간을 가정
   - 페이지 크기는 1KB
   - 페이지 테이블의 내용과 위치 : 선형(배열 기반)페이지 테이블이고, 물리 주소 1KB(1024)에 위치한다고 가정
   - 코드가 상주하는 가상 페이지
     + 페이지 크기가 1KB이므로, 가상 주소 1024는 가상 주소 공간의 두 번쨰 페이지(VPN = 1, VPN = 0은 첫 번째 페이지)에 상주
     + 이 가상 페이지가 물리 프레임(4)에 매핑된다고 가정(VPN 1 → PFN 4)
   - 배열 자체
     + 크기는 4000바이트(1000개의 정수)이고, 가상 주소 40000에서부터 44000까지 (마지막 바이트 미 포함) 존재한다고 가정
     + 이 범위에 해당하는 가상 페이지는 VPN = 39, VPN = 40, VPN = 41, VPN = 42
     + 이 페이지에 대한 매핑은 다음과 같이 가상-대-물리 주소 매핑으로 된다고 가정 : (VPN 39 → PFN 7), (VPN 40 → PFN 8), (VPN 41 → PFN 9), (VPN 42 → PFN 10)

4. 💡 프로그램이 실행되면, 각 명령어의 반입 시 메모리가 두 번 참조
   - 명령어의 위치를 파악하기 위해 페이지 테이블 접근 한 번
   - 명령어 자체에 한 번
     + mov 명령어는 메모리를 참조를 한 번 실행하며, 이 명령도 먼저 페이지 테이블 접근 한 번(배열의 가상 주소를 올바른 물리 주소로 변환하기 위해 사용)과 다음 배열 자체에 접근하기 위해 한 번의 참조가 필요

   - 처음 다섯 번의 루프 반복에 대한 전체 과정
<div align="center">
<img src="https://github.com/user-attachments/assets/ff8839fe-375a-452a-94a6-30e852e98395">
</div>

   - 맨 위의 그래프는 페이지 테이블 메모리 접근 (페이지 테이블은 물리 주소만 존재)
   - 중앙 그래프는 배열에 대한 접근 (왼쪽 : 가상 주소, 오른쪽 : 물리 주소)
   - 가장 아래쪽 그래프는 명령어 메모리 참조 (왼쪽 : 가상 주소, 오른쪽 : 물리 주소)
   - 💡 전체 트레이스에서 x축은 루프가 처음 다섯번 반복되는 과정에서의 메모리 접근을 보임
     + 루프당 10번의 메모리 접근이 존재 ((4번의 명령어 반입 + 1번의 메모리 갱신) + ((4번의 반입) + (1번의 명시적인 갱신을 위한 주소 변환)[5번의 페이지 테이블 접근))
    
