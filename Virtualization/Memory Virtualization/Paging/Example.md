-----
### 페이징 예제
-----
1. 총 크기가 64바이트이면서 4개의 16바이트 페이지로 구성된 (가상 페이지 1, 2, 3, 4) 작은 주소 공간의 예
<div align="center">
<img src="https://github.com/user-attachments/assets/57f80781-97d8-4a9e-855a-64847e22499d">
</div>

   - 물론 실제 주소 공간의 훨씬 커서 32비트의 경우 4GB, 64비트의 경우 그보다 훨씬 큼

2. 물리 메모리 : 고정 크기 슬롯들로 구성
<div align="center">
<img src="https://github.com/user-attachments/assets/8e12d204-8243-4664-a064-927de25d4df6">
</div>

   - 8개의 페이지 프레임, 총 128바이트의 비현실적으로 작은 물리 메모리
   - 가상 주소 공간의 페이지들은 물리 메모리 전체에 분산 배치되어있음
   - 운영체제가 자기자신을 위해 물리 메모리 일부를 사용함

3. 장점
   - 유연성 : 페이징을 사용하면 프로세스 주소 공간 사용 방식과는 상관없이 효율적으로 주소 공간 개념을 지원할 수 있음 (예) 힙과 스택이 어느 방향으로 커지는가, 어떻게 사용되는가에 대한 가정을 하지 않아도 됨)
   - 빈 공간 관리의 단순함
     + 예를 들어, 64바이트 주소 공간을 8페이지 물리 메모리에 배치하기를 원한다고 가정할 때, 운영체제는 비어 있는 네 개의 페이지만 찾으면 됨
     + 운영체제는 모든 비어 있는 페이지의 빈 공간 리스트를 유지하고 리스트의 첫 네 개 페이지를 선택
     + 운영체제는 주소 공간의 페이지를 물리 프레임 3에, 가상 페이지 1을 물리 프레임 7에, 페이지 2를 물리 프레임 5에, 그리고 페이지 3을 물리 프레임 2에 배치 (따라서, 물리 페이지 프레임 1, 4, 6은 현재 비어있음)

4. 주소 공간의 각 가상 페이지에 대한 물리 메모리 위치 기록을 위해 운영체제는 프로세스마다 페이지 테이블(Page Table)이라는 자료 구조 유지
   - 주소 공간의 가상 페이지 주소 변환(Address Translation) 정보를 저장
   - 즉, 각 페이지가 저장된 물리 메모리 위치가 어디인지 알려줌
   - 위 예에서 페이지 테이블은 4개의 항목을 가짐 : (가상 페이지 0 → 물리 프레임 3), (가상 페이지 1 → 물리 프레임 7), (가상 페이지 2 → 물리 프레임 5), (가상 페이지 3 → 물리 프레임 2)
   - 💡 페이지 테이블은 프로세스마다 존재함
     + 즉, 다른 프로세스를 실행해야 한다면, 운영체제는 프로세스를 위한 다른 페이지 테이블이 필요
     + 새 프로세스의 가상 페이지는 다른 물리 페이지에 존재하기 때문임 (공유 중인 페이지가 없다면)

5. 주소 변환 과정 (가정 : 작은 주소 공간 (64비트)을 가진 프로세스가 다음과 같은 메모리 접근 수행 시작)
```
movl <virtual address> , %eax
```
   - 구체적으로 주소 ```<virtual address>```의 데이터를 eax 레지스터에 탑재
   - 💡 프로세스가 생성한 가상 주소 변환을 위해 먼저 가상 페이지 번호(Virtual Page Number, VPN)와 페이지 내 오프셋 2개의 구성 요소로 분할
     + 가상 주소 공간의 크기가 64바이트 : 가상 주소 비트는 6비트가 필요 ($2^{6} = 64$)이므로, 가상 주소를 개념적으로 다음과 같이 생각 가능
<div align="center">
<img src="https://github.com/user-attachments/assets/7317498a-6d04-45c6-93d9-6b85de56ecb9">
</div>

   - Va5는 가상 주소의 최상위 비트이며, Va0은 최하위 비트
   - 페이지 크기(16바이트)를 알고 있으며, 가상 주소는 다음과 같이 나눠짐
<div align="center">
<img src="https://github.com/user-attachments/assets/f1c6126d-8f6c-45f2-abe2-50ee78668e49">
</div>

   - 페이지 크기는 64바이트 주소 공간에서 16바이트이며, 따라서 4페이지를 선택할 수 있어야 하므로 주소의 최상위 2비트가 그 역할을 함
   - 2비트 가상 페이지 번호(VPN)를 가지게 되며, 나머지 비트는 페이지 내에서 원하는 바이트의 위치를 나타내는데, 이를 오프셋이라 함
   - 프로세스가 가상 주소를 생성하면 운영체제와 하드웨어가 의미있는 물리 주소로 변환
     + 예를 들어, 탑재 명령어의 가상 주소가 21이라고 가정
```
movl 21, %eax
```
   - 21을 이진 형식으로 변환하면 010101이고, 가상 주소를 검사하고 가상 페이지 번호와 오프셋으로 나누면 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/39e4dfbc-355a-496d-84c9-044366be7389">
</div>

   - 따라서, 가상 주소 21은 가상 페이지(01)의 5번째(0101 번째) 바이트
   - 이 가상 페이지 번호를 가지고 페이지 테이블의 인덱스로 사용하여 가상 페이지 1이 어느 물리 프레임에 저장되어있는지 찾을 수 있음
   - 💡 페이지 테이블에서 물리 프레임 번호 (Physical Frame Number, PFN) 혹은 물리 페이지 번호 (Physical Page Number, PPN)는 7(이진 형식으로 111)
     + VPN을 PFN으로 교체하여 가상 주소를 변환할 수 있음
     + 그런 후, 물리 메모리에 탑재 명령어를 실행
<div align="center">
<img src="https://github.com/user-attachments/assets/0b6eb9ab-fcd9-43d2-ad5d-f1cba6c10894">
</div>

   - 💡 오프셋은 동일 (변환되지 않음)
     + 오프셋은 페이지 내 우리가 원하는 위치 정보이기 때문임
   - 최종적으로 계산된 물리 주소는 1110101 (십진수 117)이며, 탑재할 데이터가 저장된 정확한 위치
