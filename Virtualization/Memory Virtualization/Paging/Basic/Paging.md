-----
### 페이징
-----
1. 페이지 테이블 크기가 메모리 상에서 매우 크게 증가할 수 있으며, 페이지 테이블로 인해 처리 속도가 저하될 수 있음
2. 예시
```
movl 21, %eax
```
  - 주소 21에 대한 참조만 고려하고 명령어 반입에 대해서는 고려하지 않기로 하며, 하드웨어가 주소 변환을 담당한다고 가정
  - 원하는 데이터를 가져오기 위해 먼저 시스템은 가상 주소(21)를 정확한 물리적 주소(117)로 변환해야 함
    + 주소 117에서 데이터를 반입하기 전 시스템은 프로세스 페이지 테이블에서 적절한 테이블 항목을 가져와야하고, 변환 수행 후 물리 메모리에서 데이터를 탑재
    + 따라서, 하드웨어는 현재 실행중인 프로세스 페이지 테이블 위치를 알아야 하며, 여기서는 하나의 페이지 테이블 베이스 레지스터(Page Table Base Register)가 페이지 테이블의 시작 주소(물리 주소)를 저장한다고 가정
    + 원하는 PTE를 찾기 위해 하드웨어는 다음과 같은 연산 수행
```c
VPN = (VirtualAddress & VPN_MASK) >> SHIFT
PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))
```

  - VPN_MASK는 0x30(이진수 30 또는 이진수 110000)으로 설정 : 전체 가상 주소에서 VPN 비트만 추출
  - SHIFT는 4로 설정(오프셋 비트 수) : 올바른 정수 가상 페이지를 형성하기 위해 VPN 비트를 오른쪽으로 이동
  - 가상 주소 21(010101)을 마스킹 하면 010000이 되고 (쉬프트는 01 또는 원하는 가상 페이지 1로 변환), 이 값을 페이지 테이블 베이스 레지스터가 가리키는 PTE 배열에 대한 인덱스로 사용
  - 이 이 물리 주소가 알려지면 하드웨어는 메모리에서 PTE를 반입할 수 있고, PFN을 추출하고, 가상 주소의 오프셋과 연결하여 물리 주소를 만듬
  - 구체적으로, SHIFT 만큼 왼쪽 쉬프트 연산을 수행하고, 오프셋과 논리적 OR 연산을 통해 최종 주소를 형성
```c
offset = VirtualAddress & OFFSET_MASK
PhysAddr = (PFN << SHIFT) | offset
```

  - 하드웨어는 메모리에서 원하는 데이터를 가져와 eax 레지스터에 넣을 수 있음

3. 각 메모리 참조 시 일어나는 세부 동작
<div align="center">
<img src="https://github.com/user-attachments/assets/7b3ecef6-06fd-42ee-a025-2269475084a2">
</div>

   - 모든 메모리 참조에 대해(명령어 반입 또는 load 또는 store 명령어 실행 등) 먼저 페이지 테이블에서 변환 정보를 반입해야하므로 반드시 한 번의 추가적인 메모리 참조가 필요
   - 따라서, 엄청난 양의 작업이 실행되며, 메모리 참조는 비용이 비싸고 프로세스는 2배 이상 느려짐

4. 문제점
   - 하드웨어와 소프트웨어의 신중한 설계 없이는 페이지 테이블로 인해 시스템이 매우 느려질 수 있음
   - 너무 많은 메모리를 차지함
  
