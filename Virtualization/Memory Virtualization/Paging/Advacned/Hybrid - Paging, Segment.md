-----
### 페이징과 세그먼트 
-----
1. 페이징과 세그멘테이션을 결합하여 페이지 테이블의 크기를 줄이는 방법
   - 선형 페이지 테이블의 동작을 분석하면, 페이징과 세그멘테이션을 효과적으로 결합할 수 있음
   - 힙과 스택에서 실제로 전체 공간 중 작은 부분만 사용되는 경우 예) 1KB 크기의 페이지를 갖는 16KB의 주소 공간을 가지는 예
<div align="center">
<img src="https://github.com/user-attachments/assets/16fb2dae-99a8-4a7f-94d4-699f299bc87f">
</div>

<div align="center">
<img src="https://github.com/user-attachments/assets/92f907ee-f010-44e7-b8d6-c68bd98576a0">
</div>

   - 한 개의 코드 페이지(VPN 0)가 물리 페이지 10번, 한 개의 힙 페이지(VPN 4)가 23번 물리 페이지에 매핑
   - 가상 주소 공간의 끝 부분에 두 개의 스택 페이지(VPN 14와 15)가 물리 페이지 28번과 4번에 매핑
   - 그리고 페이지 테이블 대부분이 비어있으므로, 엄청난 낭비가 발생 (16 KB 크기 아주 작은 주소 공간에서 발생한 상황)
     + 하나의 페이지 테이블을 두는 대신, 논리 세그먼트마다 따로 페이지 테이블을 두는 방식 (예제에서는 세 개의 페이지 테이블 존재 가능 : 코드 / 힙 / 스택 세그먼트에 대해 페이지 테이블)

2. 세그멘테이션에서는 세그먼트의 물리 주소 시작 위치를 나타내는 베이스(Base) 레지스터, 크기를 나타내는 바운드(Bound) 또는 한계(Limit) 레지스터 존재
   - 결합 방식에서도 MMU에 비슷한 구조를 사용
   - 💡 베이스 레지스터는 세그먼트의 시작 주소를 가리키는 것이 아닌 세그먼트의 페이지 테이블의 시작 주소를 가짐
   - 바운드 레지스터는 페이지 테이블의 끝을 나타내기 위해 사용

3. 예) 4KB 페이지를 갖는 32비트 가상 주소 공간이 4개의 세그먼트로 나누어졌다고 가정 (이 예에서는 세 개의 세그먼트만 사용 : 스택 / 코드 / 힙)
   - 소속 세그먼트를 나타내기 위해 상위 두 비트 사용 (미사용 세그먼트 : 00 / 코드 : 01 / 힙 : 10 / 스택 : 11)
   - 가상 주소 표현
<div align="center">
<img src="https://github.com/user-attachments/assets/e935da1d-9258-43fe-84c2-b863cdabaf76">
</div>

   - 하드웨어의 세 개의 베이스 / 바운드 레지스터 쌍이 코드와 힙 그리고 스택을 위해서 존재한다고 가정
     + 실행 중인 프로세서에서 각 세그먼트 베이스 레지스터는 각 세그먼트 페이지 테이블의 시작 물리 주소를 가짐
     + 이 시스템에서 모든 프로세스들은 세 개의 페이지 테이블을 가지며, 문맥 교환 시, 이 레지스터들은 새로 실행되는 프로세스의 페이지 테이블 위치 값으로 변경

   - TLB 미스가 발생하면(하드웨어 기반 TLB로 가정, 즉, TLB 미스를 하드웨어가 처리), 하드웨어는 세그먼트 비트(SN)를 이용해 어떤 베이스와 바운드 쌍을 사용할지 결정
     + 하드웨어는 그 레지스터에 들어있는 물리 주소를 VPN과 다음과 같은 형식으로 조작하여 페이지 테이블 항목(PTE) 주소를 얻음
<div align="center">
<img src="https://github.com/user-attachments/assets/60f88cf6-966f-4f68-a837-59e12163f9bf">
</div>

   - 선형 페이지 테이블의 작동과 거의 동일하며, 유일한 차이는 하나의 페이지 테이블 베이스 레지스터를 사용하는 대신 세 개 중 하나의 세그먼트 베이스 레지스터를 사용하는 것

4. 하이브리드 기법의 핵심은 세그먼트마다 바운드 레지스터가 따로 존재한다는 것
   - 각 바운드 레지스터 값은 세그먼트의 최대 유효 페이지 개수를 나타냄
   - 예) 첫 세 개의 페이지(0, 1, 2)을 코드 세그먼트로 사용한다면, 코드 세그먼트 페이지 테이블은 세 개의 항목만 할당 받을 수 있고, 바운드 레지스터는 3으로 설정
   - 해당 세그먼트 범위가 넘어가는 곳에 대한 메모리 접근은 예외를 발생시키고, 해당 프로세스는 종료될 것
   - 이와 같은 방식으로 하이브리드 기법은 선형 페이지 테이블에 비해 메모리 사용을 개선할 수 있으며, 스택과 힙 사이 할당되지 않은 페이지들은 페이지 테이블 상 유효하지 않다는 것을 표시하기 위해 더 이상 공간을 차지하지 않아도 됨

5. 문제점
   - 여전히 세그멘테이션을 사용 : 세그멘테이션은 주소 공간 사용에 있어 특정 패턴을 가정하기 때문에 원하는 만큼 유연하지 못하며, 큰 공간은 문제가 없지만 드문드문 사용되는 힙의 경우에는 여전히 페이지 테이블의 낭비가 발생 가능
   - 외부 단편화를 유발 : 페이지 테이블 크기에 제한이 없으며 다양한 크기를 가지지만, 페이지 테이블 크기는 페이지 테이블 항목 크기의 정수배가 되어야 하므로, 메모리 상에서 페이지 테이블용 공간을 확보하는 것이 더 복잡
