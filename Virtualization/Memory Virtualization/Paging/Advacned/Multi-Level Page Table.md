-----
### 멀티 레벨 페이지 테이블
-----
1. 선형 페이지 테이블을 트리 구조로 표현하며, 매우 효율적이므로 현대 시스템에서 많이 사용
2. 페이지 테이블을 페이지 크기 단위로 나눈 뒤, 페이지 테이블의 페이지가 유효하지 않은 항목만 있으면 해당 페이지를 할당하지 않음
3. 페이지 디렉토리(Page Directory)라는 자료 구조를 사용하여 페이지 테이블 각 페이지의 할당 여부와 위치를 파악하며, 페이지 디렉토리는 페이지 테이블을 구성하는 각 페이지의 존재 여부와 위치 정보를 가지고 있음
4. 예제
<div align="center">
<img src="https://github.com/user-attachments/assets/c871bec9-7883-46d5-b9c6-55057cf30983">
</div>

  - 좌측 그림 : 전형적인 선형 페이지 테이블
    + 페이지 테이블 중앙부에 해당하는 주소 공간은 사용되지 않고 있음
    + 그러나 페이지 테이블에서 항목들이 할당되어 있음 (페이지 테이블의 가운데 두 페이지)

  - 우측 그림 : 동일한 주소 공간을 다루는 멀티 레벨 페이지 테이블
    + 페이지 디렉터리에는 두 개의 유효한 페이지 존재(첫 번째와 마지막)
    + 유효 페이지 두 개는 메모리에 존재
   
  - 선형 페이지 테이블에서 사용되었던 페이지들이 더 이상 필요없고, 페이지 디렉토리를 이용하여 페이지 테이블의 어떤 페이지들이 할당되었는지 관리

5. 2단계 테이블
   - 페이지 디렉토리 각 항목은 페이지 테이블의 한 페이지를 나타냄
   - 페이지 디렉토리는 페이지 디렉토리 항목(Page Directory Entries, PDE)들로 구성
     + 각 항목(PDE) 구성은 페이지 테이블의 각 항목(Page Table Entry)과 유사
     + 유효(Valid) 비트와 페이지 프레임 번호(Page Frame Number, PFN)을 갖고 있으며, 실제 구현에 따라 추가 구성 요소 존재 가능
     + PDE 항목이 유효하다는 것은 그 항목을 가리키고 있는 (PFN을 통해) 페이지들 중 최소한 하나가 유효하다는 것을 의미
     + 즉, PDE가 가리키고 있는 페이지 내 하나의 PTE의 Valid Bit가 1로 설정되어 있음
     + 만약, PDE 항목이 유효하지 않다면(0이라면), PDE는 실제 페이지가 할당되어 있지 않은 것

6. 멀티 레벨 페이지 테이블의 장점
   - 멀티 레벨 테이블은 사용된 주소 공간 크기에 비례하여 페이지 테이블 공간 할당 : 보다 작은 크기의 페이지 테이블로 주소 공간 표현 가능
   - 페이지 테이블을 페이지 크기로 분할함으로써 메모리 관리가 유용
     + 페이지 테이블을 할당하거나 확장할 때, 운영체제는 free 페이지 풀에 있는 빈 페이지를 가져다 쓰면 됨

7. 선형 페이지 테이블의 각 항목은 해당 가상 페이지의 물리 페이지 주소를 가지고 있음(즉, 디스크로 스왑되지 않음)
   - 선형 페이지 테이블은 연속된 물리 메모리 공간을 차지하며, 큰 페이지 테이블(4MB라고 할 경우)의 경우, 해당 크기의 연속된 빈 물리 메모리를 찾는 것이 어려움
   - 멀티 레벨 페이징에서는 페이지 디렉토리를 사용해 각 페이지 테이블 페이지들의 위치를 파악
   - 페이지 테이블의 각 페이지들이 물리 메모리에 산재해있더라도, 페이지 디렉토리를 이용해 그 위치를 파악할 수 있으므로, 페이지 테이블을 위한 공간 할당이 매우 유연

8. 유의사항
   - 멀티 레벨 테이블에는 추가 비용이 발생
     + TLB 미스 시, 주소 변환을 위해 두 번의 메모리 로드 발생 (페이지 디렉토리와 PTE 접근을 위해 각 한 번씩)
     + 선형 페이지 테이블에서는 한 번의 접근만으로 주소 정보를 TLB에 탑재
     + 멀티 레벨 테이블은 시간(페이지 테이블 접근 시간)과 공간(페이지 테이블 공간)을 상호 절충(Time Space Trade-Offs)한 예
     + TLB 히트 시(대부분 메모리 접근은 TLB 히트) 성능은 동일하지만, TLB 미스 시 2배의 시간 소요
   - 복잡도
     + 페이지 테이블 검색이 단순 선형 페이지 테이블 경우보다 더욱 복잡
     + 검색을 하드웨어로 구현하느냐 혹은 운영체제로 구현하느냐 여부와 무관
     + 대부분의 경우, 성능 개선이나 부하 경감을 위해, 복잡한 기법 도입
     + 멀티 레벨 페이지 테이블 경우, 메모리 자원 절약을 위해 페이지 테이블 검색을 좀 더 복잡하게 만듬

-----
### 멀티 레벨 페이징 예제
-----
1. 64바이트 페이지를 갖는 16KB 크기의 작은 주소 공간 (14비트의 가상 주소 공간)
   - VPN에는 8비트, 페이지 오프셋은 6비트가 필요
   - 선형 페이지 테이블은 $2^{8} = 256$개의 엔트리로 구성
     + 주소 공간에서 작은 부분만 사용된다 하더라도, 선형 페이지 테이블의 크기는 변하지 않음
<div align="center">
<img src="https://github.com/user-attachments/assets/df41cd72-976e-47f9-8451-cccb143cb17c">
</div>

   - 가상 페이지 0과 1은 코드 / 가상 페이지 4와 5는 힙 / 가상 페이지 254와 255는 스택으로 사용되며, 주소 공간의 나머지 페이지들은 미사용

2. 이 주소 공간을 2단계 페이지 테이블로 구성
   - 선형 페이지 테이블을 페이지 단위로 분할 : 전체 테이블은 총 256개의 항목을 갖고 있으며, 각 PTE는 4바이트라 가정했으므로, 총 페이지 크기는 1KB (256 x 4 바이트)
   - 페이지가 64바이트라고 했으므로, 1KB 페이지 테이블은 16개의 64바이트 페이지들로 분할되므로, 각 페이지에는 16개의 PTE가 존재 (1024 / 16)
   - VPN으로부터 페이지 디렉토리 인덱스를 추출하고 페이지 테이블의 각 페이지 위치를 파악하는 법
     + 페이지 디렉터리, 페이지 테이블 페이지 모두 항목의 배열이며, VPN을 이용하여 인덱스를 구성하는 법을 찾아야 함
     + 먼저 페이지의 디렉터리 인덱스를 생성 : 예제의 작은 페이지 테이블은 256개의 항목으로 16개의 페이지로 나뉘어 있으며, 페이지 디렉토리는 페이지 테이블의 각 페이지마다 하나씩 있어야 하므로 총 16개 항목이 있어야 함
       * 결과적으로 VPN의 4개의 비트를 사용해 디렉토리를 구성하며, VPN의 상위 4비트를 다음과 같이 사용
<div align="center">
<img src="https://github.com/user-attachments/assets/c95481fc-8464-4299-8247-d3a3cb928d8e">
</div>

   - VPN에서 페이지-디렉터리 인덱스(Page-Directory Index, 짧게 PDIndex)를 추출하고 나면 PDEAddr = PageDirBase + (PDIndex * sizeof(PDE))라는 간단한 식을 이용해 페이지 디렉토리 항목(Page Directory Entry, PDE)의 주소를 찾을 수 있음
     + 페이지 디렉토리 구성이 되며, 이를 활용해 주소 변환 과정을 분석

   - 페이지-디렉토리의 해당 항목이 무효(Invaild)라고 표시되어 있으며, 이 주소 접근은 유효하지 않으며, 예외가 발생
   - 해당 PDE가 유효하다면 추가 작업을 진행
     + 페이지 디렉토리 항목이 가리키고 있는 페이지 테이블의 페이지에서 원하는 페이지 테이블 항목(Page Tavle Entry, PTE)을 읽어들이는 것이 ㅁ고표
     + PTE를 찾기 위해 VPN의 나머지 비트 사용
<div align="center">
<img src="https://github.com/user-attachments/assets/167f2915-c10a-492f-8746-1a58d5719fd7">
</div>

   - 페이지-테이블 인덱스(Page-Table Index, PTIndex)는 페이지 테이블 자체 인덱스로 사용
     + 다음과 같이 계산 : PTEAddr = (PDE.PFN << SHIFT) + (PTIndex * sizeof(PTE))
     + PTE 주소를 생성하기 위해 페이지-디렉토리 항목에서 얻은 페이지-프레임 번호(Page Frame Numer, PFN)을 먼저 좌측 쉬프트 연산하고, 그 값을 페이지 테이블 인덱스에 합산
     + 위 예제에서는 주소 공간에 두 개의 유효한 영역이 있으며(처음과 끝), 그 사이는 무효한 매핑들이 존재

<div align="center">
<img src="https://github.com/user-attachments/assets/17d63d94-c14e-4694-b106-1edc23872296">
</div>

   - 물리 페이지 100에 (페이지 테이블의 0번쨰 페이지의 물리 프레임 번호), 페이지 테이블의 첫 16개 항목이 존재
     + 이 항목들은 가상 주소 공간의 첫 16개 페이지에 대한 물리 주소를 가짐 (위 그림에서 가운데 열이 해당 페이지 내용)

   - 페이지 테이블의 첫 번째 페이지에는 첫 16개의 VPN과 물리 페이지 주소가 존재
     + 이 예제에서는 VPN 0과 1이 유효하고(코드 세그먼트), 4와 5도 유효(힙)
     + 그러므로 테이블에는 각 페이지들의 매핑 정보 존재
     + 나머지 엔트리들은 무효로 표기

   - PFN 101에는 다른 유효 페이지들에 대한 정보가 존재
     + 이 페이지는 가상 주소 공간의 마지막 16개의 VPN에 대한 매핑이 담겨있는데, 우측이 그 내용
     + VPN 254와 255가 유효 페이지이며, 스택에 해당

   - 이 예제를 통해서 멀티 레벨 인덱스 구조가 공간을 얼만큼 절약할 수 있는지 확인 가능
     + 선형 페이지 테이블의 열 여섯개의 페이지들을 모두 할당 하는 대신 3개만 할당 (페이지 디렉토리를 위한 한 페이지, 그리고 유효한 매핑 정보를 갖고 있는 페이지 테이블 내 두 부분을 위해 두 페이지 할당)
     + 더 큰 (32비트 또는 64비트) 주소 공간에서는 더 많은 공간 절약

   - 최종 주소 변환
     + VPN 254의 0번째 바이트를 가리키는 주소 : 0x3F80 또는 이진수로 11 1111 1000 0000
     + 페이지 디렉토리 내 각 항목을 가리키기 위해 VPN의 상위 4비트 사용 (1111) : 즉, 1111은 페이지 디렉토리의 마지막 엔트리(0부터 시작했으면 15번째), 페이지 디렉토리 15번째 엔트리는 물리 프레임 주소 101이 저장
     + VPN의 다음 4비트 (1110)를 인덱스를 사용하여, 페이지 테이블의 해당 페이지에서 원하는 PTE를 찾음 : 1110은 101번 페이지의 16개 항목 중 마지막에서 두 번째 항목이며, 55가 저장
     + 종합하면 가상 페이지 주소 254 (1111 1110)는 물리 페이지 55에 존재하며, 오프셋 000000과 PFN 55(0x37)를 결합하여 물리주소를 구할 수 있음 : PhysAddr = (PTE.PFN << SHIFT) + offset = 00 1101 1100 0000 = 0x0DC0

3. 2단계 이상 사용하기
   - 지금까지는 멀티 레벨 페이지 테이블은 페이지 디렉토리와 페이지 테이블의 2개 단계로 가정
   - 경우에 따라 트리 단계를 더 증가시키는 것도 가능
   - 예제) 512바이트 페이지와 30비트 가상 주소 공간 가정
     + 가상 주소는 21비트 가상 페이지 번호와 9비트의 오프셋을 가지게 됨
     + 멀티 레벨 테이블에서 몇 단계를 둘지 정하기 위해서는 먼저 한 페이지에 몇 개의 페이지 테이블 항목을 저장할 수 있을지 계산해야 함
     + 페이지 크기가 512바이트이고, PTE 크기가 4바이트라고 가정하면, 한 페이지에 128개의 PTE를 넣을 수 있음
     + 페이지 테이블의 페이지를 인덱스로 쓰려면, VPN의 하위 7비트($log_{2} 128$)가 필요
<div align="center">
<img src="https://github.com/user-attachments/assets/a1517ee8-a470-46d0-95e3-d1b3fd35c3c4">
</div>

   - 페이지 디렉토리를 위해서 몇 개의 비트를 남아있는지 위 그림을 통해 알 수 있음 : 14개의 비트가 남아있으며, 2단계 페이지를 사용한다면 페이지 디렉토리에 $2^{14}$개 항목이 있게 됨
   - 페이지 디렉토리를 위해 128 페이지 분량의 연속된 메모리가 필요하며, 페이지 테이블을 페이지 단위로 나누어 배치할 수 있도록 하는 멀티 레벨 페이지 테이블의 근본 취지가 훼손된 셈

4. 페이지 디렉토리 자체를 멀티 페이지들로 나눠서 트리의 단계를 늘리는 방법도 존재
   - 그리고 페이지 디렉터리의 페이지들을 가리킬 수 있도록 그 위에 새로운 페이지 디렉토리를 추가 : 결과적으로 다음과 같이 가상 주소를 분할 가능
<div align="center">
<img src="https://github.com/user-attachments/assets/8f05fbc7-dd87-4296-b0a1-e943c05c2c32">
</div>

   - 가상 주소의 최상위 비트들을(PD Index 0) 사용하여 상위 단계 페이지 디렉토리에서 엔트리를 찾음
   - 이 인덱스를 사용하여 상위 단계 페이지 디렉토리에서 페이지 디렉토리 항목을 가져오며, 만약 유효하다면, 상위 단계 페이지 디렉토리에서 얻은 물리 주소와 두 번째 단계의 페이지 디렉토리 인덱스(PD Index 1)를 결합하여 페이지 테이블 인덱스가 존재한 물리 페이지를 구함
   - 해당 페이지가 유효할 경우, PTE 주소는 2번째 단계의 페이지 디렉토리 항목에서 얻은 페이지 테이블의 물리 주소와 페이지 테이블 인덱스를 결합하여 구함

5. 2단계 페이지 테이블 상요 시, 전체 주소 변환 과정 알고리즘
<div align="center">
<img src="https://github.com/user-attachments/assets/a83d60d2-4c54-4c0b-82aa-a3e866013a96">
</div>

   - 하드웨어 기반 TLB 가정
   - 복잡한 멀티 레벨 페이지 테이블 접근을 거치기 전, 우선 TLB를 검사
   - 히트가 되면, 페이지 테이블을 참조없이 물리 주소로 직접 구성
   - TLB 미스 시에만, 멀티 레벨 페이지 테이블의 모든 단계를 거쳐 물리 주소를 구하게 됨
   - 이 알고리즘을 통해 TLB 미스 발생 시, 전통적인 2단계 페이지 테이블 주소 계산 비용을 볼 수 있으며, 주소 변환을 위해 2번의 추가 메모리 접근이 발생
