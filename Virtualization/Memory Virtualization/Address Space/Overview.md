-----
### 주소 공간 - 초기 시스템
-----
1. 메모리 관점에서 초기 컴퓨터는 많은 개념을 사용자에게 제공하지 않았으며, 당시 물리 메모리는 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/a68d22aa-091f-4d68-987b-0c877b6fc23a">
</div>

2. 운영체제는 메모리에(이 예에서는 물리 주소 0부터) 상주하는 루틴의 집합
3. 물리 메모리에 하나의 실행 중인 프로그램(프로세스)이 존재하였고(예에서 물리 주소 64KB부터 시작), 나머지 메모리를 사용

-----
### 멀티프로그래밍과 시분할
-----
1. 시간이 흐른 후, 멀티프로그래밍(Multi-Programming) 시대가 도래
   - 여러 프로세스가 실행 준비 상태에 있고, 운영체제는 이들을 전환하면서 실행
   - 예를 들어, 한 프로세스가 입출력을 실행하면, CPU는 다른 프로세스로 전환
   - 이런 전환은 CPU의 이용률을 증가

2. 컴퓨터를 더 많이 사용하길 원하면서 시분할(Time-Sharing) 시대가 시작
   - 일괄처리 방식(Batch Computing) 컴퓨팅의 한계를 인식하였고, 많은 사용자가 동시에 컴퓨터를 사용하고, 현재 실행 중인 작업으로부터 즉시 응답을 원하기 때문에 대화식 이용(Interactivity) 개념이 중요하게 됨
  
3. 시분할을 구현하는 한 가지 방법은 하나의 프로세스를 짧은 시간동안 실행시키는 것
   - 해당 기간 동안 프로세스에게 모든 메모리를 점근할 권한이 주어짐
   - 이후, 이 프로세스를 중단하고, 중단 시점의 모든 상태를 디스크 종류 장치(모든 물리 메모리 포함)에 저장하고 다른 프로세스의 상태를 탑재하여 또 짧은 시간 동안 실행
   - 이 방법은 그러나 너무 느리게 동작하며, 특히 메모리가 커질수록 느리게 됨
   - 레지스터 상태를 저장하고 복원하는 것은 빠르지만 메모리의 내용 전체를 디스크에 저장하는 것은 엄청나게 느림
   - 따라서, 프로세스 전환 시 프로세스를 메모리에 그대로 유지하면서, 운영체제가 시분할 시스템을 효율적으로 구현할 수 있게 하는 것이 중요

4. 세 개의 프로세스(A, B, C)가 있고, 각 프로세스는 512 KB 물리 메모리에서 각기 작은 부분을 할당받음
   - 하나의 CPU를 가정할 때, 운영체제는 실행할 한 개의 프로세스(A라 가정)를 선택하고, 다른 프로세스들(B와 C)는 준비 큐에서 실행을 기다림
<div align="center">
<img src="https://github.com/user-attachments/assets/b52fa1f6-fe28-43ce-aede-52c0b820c29f">
</div>

5. 시분할 시스템이 대중화되면서 운영체제에게 새로운 요구 사항이 부과 : 여러 프로그램이 메모리에 동시에 존재하려면 보호(Protection)가 중요한 문제가 됨 (즉, 한 프로세스가 다른 프로세스의 메모리를 읽거나 혹은 더 안좋게는 쓸 수 있는 상황을 원치 않음)
