-----
### 주소 공간
-----
1. 운영체제는 사용하기 쉬운 메모리 개념을 만들어야 하는데, 이것이 바로 주소 공간
   - 즉, 실행 중인 프로그램이 가정하는 메모리 모습

2. 주소 공간은 실행 프로그램의 모든 메모리 상태를 가지고 있음
   - 예를 들어, 프로그램의 코드(Code, 명령어)는 반드시 메모리에 존재해야 하고, 따라서 주소 공간에 존재
   - 스택은 함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자와 반환 값등을 저장하는데 사용
   - 마지막으로 힙(Heap)은 동적으로 할당되는 메모리를 위해 사용 (예) C언어의 malloc(), C++나 Java 같은 객체 지향 언어의 new를 통해 메모리 동적 할당 가능)
   - 주소 공간 구성 요소는 정적으로 초기화된 변수 등 다른 것도 존재하지만 위 세개로 우선 가정

3. 16 KB의 아주 작은 주소 공간
<div align="center">
<img src="https://github.com/user-attachments/assets/37ef0c28-3387-4d1a-9f86-4ee5f7184141">
</div>

   - 프로그램 코드는 주소 공간 위쪽에 위치하며, 주소 0부터 시작하고 주소 공간의 첫 1KB를 차지
     + 코드는 정적이므로 메모리에 저장되기 쉬우며, 따라서 주소 공간 상단에 배치하고, 프로그램이 실행되면서 추가 메모리를 필요로 하지 않음
   - 프로그램 실행과 더불어 확장되거나 축소될 수 있는 두 종류 주소 공간 존재
     + 주소 공간 상단에 존재하는 힙 
     + 주소 공간 하단에 존재하는 스택
     + 두 메모리 영역은 확장할 수 있어야하므로 이런 방식으로 배치하고, 주소 공간 양 끝단에 배치해야 두 영역 모두 확장이 가능함
     + 두 영역은 확장 방향이 반대일 수 밖에 없으며, 힙은 코드 바로 뒤 1KB부터 시작하고, 아래 방향으로 확장 (예) 사용자가 malloc() 함수를 통해 더 많은 메모리 요청)
     + 스택은 16KB부터 시작하고 위쪽 방향으로 확장 (예) 사용자가 프로시저 호출)
     + 스택과 힙의 이러한 배치는 관례일 뿐이며, 원한다면 주소 공간을 다른 방식으로 배치할 수 있으며, 주소 공간에 여러 쓰레드가 공존할 때는 이런 식으로 주소 공간을 나누면 동작하지 않음
    
4. 주소 공간을 설명할 때, 운영체제가 실행중인 프로그램에게 제공하는 개념(Abstraction)
   - 실제로 프로그램이 물리 주소 0에서 16 KB에 존재하는 것이 아니며, 임의의 물리 주소에 탑재
   - 즉, 운영체제가 메모리를 가상화(Virtualization Memory)한다고 말함
   - 실행 중인 프로그램은 자신의 특정 주소의 메모리에(예) 0) 탑재되고, 매우 큰 주소 공간(예) 32비트 또는 64비트) 가지고 있다고 생각하기 때문임
   - 예를 들어, 프로세스 A가 주소 0으로부터(가상 주소) load 연산을 수행할 때, 운영체제는 하드웨어 지원을 통해 물리 주소 0이 아닌 물리 주소 320 KB (A가 탑재된 메모리)를 읽도록 보장해야 함
