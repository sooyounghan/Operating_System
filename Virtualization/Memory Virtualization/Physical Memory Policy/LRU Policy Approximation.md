-----
### LRU 정책 근사
-----
1. Use Bit(Reference Bit)라고 하는 하드웨어 지원이 필요
   - 시스템의 각 페이지마다 하나의 Use Bit를 가지고 있음
   - 페이지가 참조될 때마다(즉, 읽히거나 기록되면) 하드웨어 의해서 Use Bit가 1로 설정
   - 하드웨어는 이 비트를 절대로 지우지 않음(즉, 0으로 설정하지 않으며, 0으로 바꾸는 것은 운영체제의 몫)

2. 운영체제는 LRU에 가깝게 구현하기 위해 Use Bit를 시계 알고리즘(Clock Algorithm)을 활용
   - 시스템이 모든 페이지들이 환형 리스트를 구성한다고 가정
   - 시계 바늘(Clcok Hand)이 특정 페이지를 가리킨다고 가정
   - 페이지를 교체해야할 때, 운영체제는 현재 바늘이 가리키고 있는 페이지 P의 Use Bit가 1인지 0인지 검사
     + 1이라면, 페이지 P는 최근에 사용되었으며 바람직한 교체 대상이 아니므로, P의 Use Bit는 0으로 설정되고(지워짐) 시계 바늘은 다음 페이지 P + 1로 이동
     + 알고리즘은 Use Bit가 0으로 설정되엉있는, 즉 최근에 사용된적 없는, 페이지를 찾을 때까지 반복(최악의 경우 모든 페이지들이 사용된 적이 있어서 모든 페이지들을 모두 탐색하면서 Use Bit를 전부 0으로 설정해야 할 수 있음)

3. 이 방법 외에도 주기적으로 Use Bit를 지우고, 교체 대상 페이지 선택을 위해 Use Bit가 1과 0인 페이지를 구분할 수 있으면 됨
   - Corbato 알고리즘은 미사용 페이지를 찾기 위해 매번 모든 메모리를 검사하지 않아도되는 좋은 특성을 가진 초기 방법

4. 변형된 시계 알고리즘 동작
<div align="center">
<img src="https://github.com/user-attachments/assets/b3401879-c99d-4e88-a918-0c515b405713">
</div>

   - 이 변형 방식은 교체할 때 페이지들을 랜덤하게 검사
   - Reference Bit가 1로 설정되어 있는 페이지를 만나게 되면 비트를 지움(즉, 0으로 설정)
   - Reference Bit가 0으로 설정되어 잇는 페이지를 만나면 그 페이지를 교체 대상으로 선정
   - 완벽한 LRU만큼 좋은 성능을 보이지는 않지만 과거 정보를 고려하지 않는 다른 기법에 비해서는 성능이 더 좋음
