-----
### 세그먼트 종류 파악
-----
1. 하드웨어는 변환을 위해 세그먼트 레지스터 사용
2. 가상 주소의 최상위 몇 비트를 기준으로 주소 공간을 여러 세그먼트로 나눔 (VAX/VMS 시스템에서 사용)
   - 앞의 예에서는 3개의 세그먼트가 존재
   - 주소 공간을 세그먼트로 나누기 위해 2비트가 필요
   - 즉, 세그먼트를 표시하기 위해 가상 주소 14비트 중 최상위 2비트를 사용하는 경우 가상 주소 모양은 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/f6a0d0c8-7ee1-47fc-92a9-fef1bd1b4b6a">
</div>

3. 최상위 2비트가 00이면 하드웨어는 가상주소가 코드 세그먼트를 가리키며, 코드 세그먼트의 베이스와 바운드 쌍을 이용해 주소를 정확한 물리 메모리에 재배치
4. 최상위 2비트가 01이면 하드웨어는 주소가 힙 세그먼트라는 것을 인지하며, 힙의 베이스와 바운드를 사용
5. 예) 힙에 해당하는 가상 주소(4200) 변환
   - 가상 주소 4200에 해당하는 이진 형식
<div align="center">
<img src="https://github.com/user-attachments/assets/2fe9d956-b21b-400e-93f4-4b1510c68b34">
</div>

   - 최상위 2비트(01)는 하드웨어에게 참조하는 세그먼트의 종류를 알려줌
   - 하위 12비트는 세그먼트 내 오프셋 (0000 0110 1000 또는 16진수 0x068 또는 10진수 104)
   - 하드웨언느 세그먼트 레지스터를 파악하는 데 처음 2비트를 이용하고, 세그먼트 오프셋으로부터 다음 12비트를 취함
   - 오프셋에 베이스 레지스터 값을 더하여 하드웨어는 최종 물리 주소를 계산
   - 오프셋은 바운드 검사도 쉽게 가능 : 오프셋이 바운드보다 작은지 여부만 검사하면 되며, 작지 않다면 주소가 잘못된 것
  
6. 베이스와 바운드 쌍을 배열 형식으로 저장할 경우(세그먼트 당 하나의 항목), 원하는 물리 주소를 얻기 위해 다음과 같은 작업 수행
<div align="center">
<img src="https://github.com/user-attachments/assets/f0c45025-4d0d-4df5-a1a2-69aea92bae49">
</div>

   - 사용된 상수 값
     + SEG_MASK : 0x3000
     + SEG_SHIFT : 12
     + OFFSET_MASK : 0xFFF

   - 세그먼트 종류를 나타내는데 최상위 2비트를 사용하고 주소 공간에는 세 개의 세그먼트(코드, 힙, 스택)만 존재하므로 지정 가능한 세그먼트 하나는 미사용으로 남음
   - 즉, 전체 주소 공간의 1/4은 사용이 불가능
   - 이 문제 해결을 위해 일부 시스템은 코드와 힙을 하나의 세그먼트에 저장하고 세그먼트 선택을 위해 1비트만 사용

7. 특정 주소의 세그먼트를 하드웨어적으로 파악하는 다른 방법 : 묵시적 접근 방식
   - 주소가 어떻게 형성되었냐를 관찰하여 세그먼트를 결정
   - 예를 들어, 주소가 프로그램 카운터에서 생성되었다면 (즉, 명령어 반입) 주소는 코드 세그먼트 내에 있을 것
   - 주소가 스택 또는 베이스 포인터에 기반을 둔다면 주소는 스택 세그먼트 내에 있고, 다른 주소는 모두 힙에 있어야 함
