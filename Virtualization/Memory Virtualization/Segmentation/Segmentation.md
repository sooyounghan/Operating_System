-----
### 세그멘테이션 : 베이스 / 바운드 (Base / Bound)의 일반화
-----
1. MMU 안에 오직 하나의 베이스와 바운드 쌍만 존재하는 것이 아니라 주소 공간의 논리적인 세그먼트(Segment) 마다 베이스와 바운드 쌍이 존재
2. 세그먼트는 특정 길이를 가지는 연속적인 주소 공간
   - 따라서, 주소 공간에는 코드, 스택, 힙의 세 종류의 세그먼트가 존재
   - 세그멘테이션을 사용하면 운영체제는 각 세그멘트를 물리 메모리의 각기 다른 위치에 배치할 수 있고, 사용되지 않는 가상 주소 공간이 물리 메모리를 차지하는 것 방지 가능


3. 다음 주소 공간을 물리 메모리에 배치
<div align="center">
<img src="https://github.com/user-attachments/assets/5ca6389d-91c4-4738-a428-5805fac07419">
</div>

   - 각 세그먼트의 베이스와 바운드 쌍을 이용하여 세그먼트들을 독립적으로 물리 메모리에 배치할 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/4818b66b-eae3-42ca-9dae-10be8770162e">
</div>

   - 64 KB 물리 메모리에 3개의 세그먼트와 운영체제용으로 예약된 16 KB 영역이 존재
   - 사용 중인 메모리에만 물리 공간이 할당되며, 사용되지 않은 영역이 많은 대형 주소 공간(드문드문 사용되는 주소 공간(Sparse Address Space)을 수용할 수 있음

4. 세그먼트 지원을 위한 MMU 하드웨어 구조
   - 3쌍의 베이스와 바운드 레지스터 집합이 필요
   - 해당하는 각 레지스터의 값
<div align="center">
<img src="https://github.com/user-attachments/assets/1156b64e-0e94-4f9c-b6f5-6710d7c821e8">
</div>

   - 💡 각 바운드 레지스터는 세그먼트의 크기를 저장
   - 코드 세그먼트가 물리 주소 32 KB에 배치되고 크기는 2 KB이며, 힙 세그먼트가 34 KB에 배치되고 크기는 2 KB
   - 주소 변환 예
<div align="center">
<img src="https://github.com/user-attachments/assets/5ca6389d-91c4-4738-a428-5805fac07419">
</div>

   - 가상 주소 100번지를 참조한다고 가정
     + 가상 주소 100번지는 코드 세그먼트에 속하며, 참조가 일어나면 하드웨어는 베이스 값에 이 세그먼트 오프셋(이 경우, 100)을 더해 물리 주소는 100 + 32 KB = 32868이 됨
     + 그 후, 주소가 범위 내 있는지 검사하고(100은 2KB보다 작음), 범위 내에 있을 경우 물리 메모리 주소 32868을 읽음

   - 💡 가상 주소 4200의 힙을 참조한다고 가정
     + 가상 주소 4200의 힙의 베이스 (34 KB)에 더하면 물리 주소 39016를 얻지만 이 주소는 올바른 주소가 아님
     + 💡 힙 안에서 오프셋, 즉, 주소가 참조하는 바이트가 세그먼트 시작으로부터 몇 번째 바이트인지 알아내야 함 : 힙은 가상 주소 4 KB(4096)에서 시작하므로 오프셋 4200은 4200 - 4096 = 104가 됨
     + 이 오프셋(104)을 베이스 레지스터 물리 주소 (34 KB)에 더해 원하는 결과 34920를 얻게 됨

5. 만일 힙의 마지막을 벗어난 7KB와 같은 잘못된 주소에 접근하려한다면, 하드웨어가 그 주소가 범위를 벗어났다는 것을 감지하고 운영체제에 트랩 발생하여 문제 프로세스를 종료시킬 가능성이 큼
   - 이를 세그먼트 위반(Segement Violation) 또는 세그먼트 폴트(Segement Fault) : 즉, 세그먼트 사용 시스템에서 불법적인 주소 접근 시 발생하는 것 (이 경우 코드 오류 원인을 알 수 없음)
