-----
### 운영체제 지원
-----
1. 시스템이 각 주소 공간 구성 요소를 별도로 물리 메모리에 재배치하기 때문에 주소 공간이 하나의 베이스-바운드 쌍을 가지는 간단한 방식에 비해 물리 메모리에 엄청나게 절약할 수 있음
   - 구체적으로는 스택과 힙 사이 사용하지 않는 공간에 물리 메모리를 할당할 필요가 없으므로 같은 크기의 물리 메모리에 더 많은 주소 공간 탑재 가능

2. 세그먼트의 레지스터의 저장과 복원의 문제
   - 각 프로세스는 자신의 가상 주소 공간을 가지며, 운영체제는 프로세스를 다시 실행하기 전에 올바르게 레지스터들을 설정해야 함

3. 미사용 중인 물리 메모리 공간의 관리
   - 새로운 주소 공간이 생성되면, 운영체제는 이 공간의 세그먼트를 위한 비어있는 물리 메모리 영역을 찾을 수 있어야 함
   - 각 주소 공간 크기가 동일하다고 가정했는데, 물리 메모리는 프로세스가 탑재될 슬롯의 집합이라 볼 수 있음
   - 따라서, 물리 메모리가 빠르게 작은 크기의 빈 공간들로 채워지게 되면, 이 작은 빈 공간들은 새로이 생겨나는 세그멘트에 할당하기도 힘들며, 세그먼트 확장에 도움이 되지 않는데, 이를 '외부 단편화(External Fragmentation)'

4. 외부 단편화 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/4477abee-e289-43e2-b2fd-dad36bcd9056">
</div>

   - 새로운 프로세스가 생성되어 20 KB를 할당하려 한다고 가정
   - 위 예에서 24 KB의 빈 공간이 존재하지만 하나의 연속된 공간이 아닌 세 개의 청크(Chunk)로 나눠짐
   - 운영체제는 20 KB 요청을 충족시킬 수 없음
   - 해결책 중 한가지는 기존 세그먼트를 정리하여 물리 메모리를 압축(Compact)하는 것
     + 예를 들어, 운영체제는 현재 실행 중인 프로세스를 중단하고, 그들의 데이터를 하나의 연속된 공간에 복사하고, 세그먼트 레지스터가 새로운 물리 메모리 위치를 가리키게 하여, 자신이 작업할 큰 빈 공간을 확보할 수 있음
     + 따라서, 운영체제는 새로운 할당 요청을 충족시킬 수 있음
     + 하지만, 세그먼트 복사는 메모리에 부하가 큰 연산이고 일반적으로 상당량의 프로세서 시간을 사용하므로 압축은 비용이 많이 듬

   - 간단한 방법은 빈 공간 리스트를 관리하는 알고리즘 사용 : 할당 가능한 메모리 영역들을 리스트 형태로 유지
     + 최적 적합(Best-Fit), 최악 적합(Worst-Fit), 최초 적합(First-Fit), 버디 알고리즘(Buddy Algorithm)과 고전적 알고리즘 방식을 포함하여 수백 개 방식 존재
     + 이 중 최적 적합은 빈 공간 리스트에서 요청된 크기와 가장 비슷한 크기의 공간을 할당
     + 외부 단편화를 해결하는 유일한 최선책은 존재하지 않으며, 가장 좋은 해결책은 가변 길이 할당을 허용하지 않음으로 아예 문제가 생기지 않게 하는 것
