-----
### 교착 상태의 예방
-----
1. 순환 대기 (Circular Wait)
   - 순환 대기가 절대 발생하지 않도록 락 코드를 작성하는 것으로, 가장 간단한 방법은 락 획득을 하는 전체 순서(Total Ordering)을 정하는 것
   - 예를 들어, L1과 L2라는 두 개의 락만이 시스템에 존재하면 L1을 무조건 L2 전에 획득하도록 하면 교착 상태를 피할 수 있음
   - 이 순서를 따르면 순환 대기는 발생하지 않고 따라서 교착 상태도 발생하지 않음
   - 좀 더 복잡한 시스템의 경우, 두 개 이상의 락이 존재할 것이고, 전체 락의 요청 순서를 정의하는 것이 어렵거나 불필요할 수 있음
   - 교착 상태를 피하기 위해 부분 순서(Partial Ordering)을 제공하는 것이 락 획득 구조를 만드는 데 유용할 것임 (Linux의 메모리 매핑 코드가 부분 순서를 제공 받아 락을 획득하는 방식에 대한 좋은 예)
   - 전체 또는 부분 순서를 제공하기 위해서는 세심하게 락 획득 전략을 설계해야 함
   - 더 나아가 순서라는 것은 단순히 관례이므로 숙련되지 않은 개발자들이 이 관례를 무시하고 코드를 개발할 경우, 교착 상태에 발생할 수 있음 : 따라서, 락의 순서를 정의하기 위해서는 코드와 다양한 루틴 간의 상호 호출 관계를 이해해야 하며, 작은 실수라 할지라도 교착 상태로 시작하는 문제를 만날 수 있음

2. 점유 및 대기 (Hold-And-Wait)
   - 점유 및 대기는 원자적으로 모든 락을 단번에 획득하도록하면 예방 가능
```c
1 lock(prevention);
2 lock(L1);
3 lock(L2);
4 ...
5 unlock(prevention);
```
   - 제일 먼저 prevention 락을 획득하여, 락을 획득하는 과정 중에 쓰레드 문맥 교환이 발생하는 것을 방지하고, 결과적으로 교착 상태의 발생 가능성을 차단
   - 쓰레드가 락을 획득하려면 전역 prevention 락을 먼저 획득해야 하며, 다른 쓰레드가 L1과 L2를 다른 순서로 획득하려고 한다하더라도 괜찮음 : 그 쓰레드가 prevention 락을 이미 획득한 후 나머지 락을 요청하기 때문임
   - 문제점 : 캡슐화와 관련된 사항
     + 필요한 락들을 정확히 파악해야하고, 그 락들을 미리 획득해야 함
     + 락이 실제로 필요할 때, 요청하는 것이 아니라 미리 모든 락을 (단번에) 획득하기 때문에 병행성이 저하되는 문제도 있음
    
3. 비선점(Non-Preemption)
   - 일반적으로 락을 해제하기 전까지는 락을 보유하는 것으로 보므로, 여러 락을 획득하는 것은 문제의 소지가 있음 : 왜냐하면, 락을 이미 보유하고 있는 채로 다른 락을 대기하기 때문임
   - 많은 쓰레드 라이브러리들은 이러한 상황을 피하도록 유연한 인터페이스 집합을 제공 : trylock() 루틴의 경우 (획득 가능하다면) 락을 획득하거나 현재 락이 점유된 상태이니 락을 획득하기 원한다면 나중에 다시 시도하라는 것을 알리는 -1 값을 리턴
   - trylock()을 이용하면 교착 상태 가능성이 없고, 획득 순서에 영향을 받지 않는 락 획득 방법을 만들 수 있음
```c
1 top:
2     lock(L1);
3         if (trylock(L2) == −1) {
4             unlock(L1);
5             goto top;
6         }
```
   - 다른 쓰레드가 같은 프로토콜을 사용하면서 락을 다른 순서(L2 먼저 L1 그 다음)로 획득하려고 해도 역시 교착 상태는 발생하지 않음
   - 그렇지만 무한 반복(Livelock)이라는 새로운 문제가 발생
     + 두 개의 쓰레드가 이 순서대로 시도하기를 반복하면서 락 획득에 실패하는 것도 (대체적으로 그럴리는 없지만) 가능
     + 두 쓰레드 모두 이 코드를 반복 실행하겠지만 (교착 상태는 아니지만), 실제 진척이 있는 것이 아니므로 무한 반복의 상황
     + 해법 : 반복문에 지연 시간을 무작위로 조절하여 경쟁하는 쓰레드 간의 반복 간섭을 줄일 수 있음

   - trylock()의 어려운 부분 : 캡슐화
     + 만약 사용하려는 락이 호출되는 루틴 깊숙한 곳에 존재한다면 처음 부분으로 되돌아가도록 구현하는 것이 쉽지 않음
     + 만약에 코드가 실행 과정에서 (L1가 아닌 다른) 자원을 획득했다면, 그 자원 역시 반납해야 하며, 예를 들어, L1 획득 후 코드에서 메모리 영역을 할당하였다면, L2 획득 실패 시 처음으로 돌아가서 전체 순서를 다시 시작하기 전 할당받았던 메모리도 같이 반납해야 함
     + 하지만, 제한된 경우에만 이러한 접근이 제대로 동작할 것

4. 상호 배제 (Mutual Exclusion)
   - 상호 배제 자체를 없애는 방법인데, 일반적 코드는 모두 임계 영역을 포함하고 있으므로 어려움
   - Herlihy는 대기 없는 (Wait-Free) 자료 구조를 고안 : 명시적 락이 필요 없는 강력한 하드웨어 명령어를 사용해 자료 구조를 만들면 됨
   - 예) Compare-And-Swap 명령어를 가정 (하드웨어가 지원하는 원자적 명령어)
```c
1 int CompareAndSwap(int *address , int expected , int new) {
2       if (*address == expected) {
3           *address = new;
4           return 1; // 성공
5       }
6       return 0; // 실패
7 }
```
   - 어떤 한 값을 원자적으로 임의의 크기만큼 증가하는 경우
```c
1 void AtomicIncrement(int *value , int amount) {
2     do {
3         int old = *value;
4     } while (CompareAndSwap(value , old , old + amount) == 0);
5 }
```
   - 락을 획득하여 값을 갱신한 후 락을 해제하는 대신, 이 코드에서는 Compare-And-Swap 명령어를 사용하여 값에 새로운 값을 갱신하도록 반복적 시도
   - 이 방식을 사용하면 락 획득이 필요가 없으며, 교착 상태가 발생할 수 없으나, 다만 무한 반복은 발생 가능성 존재

   - 예) 좀 더 복잡한 리스트에 삽입 예제
   - 리스트 헤드에 개체를 삽입하는 코드
```c
1 void insert(int value) {
2     node_t *n = malloc(sizeof(node_t));
3     assert(n != NULL);
4     n−>value = value;
5     n−>next = head;
6     head = n;
7 }
```
   - 간단한 삽입문을 실행하는 이 코드가 만약 여러 쓰레드에 의해 동시 호출되면 경쟁 조건(Race Condition) 발생
   - 따라서, 삽입문 앞 뒤에 락 획득과 해제 코드를 두어 해결하는 방법
```c
1 void insert(int value) {
2     node_t *n = malloc(sizeof(node_t));
3     assert(n != NULL);
4     n−>value = value;
5     lock(listlock); // 임계 영역 시작
6     n−>next = head;
7     head = n;
8     unlock(listlock); // 임계 영역의 끝
9 }
```
   - 이 해법은 전형적 방식으로 락을 사용
   - 단순히 Compare-And-Swap 명령어를 사용하여 대기 없이 명령어 처리
```c
1 void insert(int value) {
2     node_t *n = malloc(sizeof(node_t));
3     assert(n != NULL);
4     n−>value = value;
5     do {
6         n−>next = head;
7     } while (CompareAndSwap(&head , n−>next , n) == 0);
8 }
```
   - 이 코드는 next 포인터가 현재의 헤드를 가리키도록 갱신하고 새로 생성된 노드는 리스트의 헤드가 되도록 동작
   - 이 코드를 처리하는 도중 만약 어떤 쓰레드가 새로운 헤드에 성공적으로 성공하였다면, Compare-And-Swap는 실패하고, 쓰레드는 삽입 과정을 재시도
   - 유용한 리스트를 만드는 것 외에는 삽입 동작 외에 여러 가지 필요 : 대기없는 방식으로 삽입과 삭제 그리고 검색할 수 있도록 리스트를 만드는 것은 쉽지 않음

5. 스케줄링으로 교착 상태 회피하기
   - 어떤 시나리오에서는 교착 상태를 예방하는 대신 회피하는 것이 유용할 수 있음
   - 회피하기 위해서는 실행 중인 여러 쓰레드가 어떠 락을 획득하게 될 것인지 전반적으로 파악하고 있어야 하며, 이를 바탕으로 쓰레드들을 스케줄링하여 교착 상태가 발생하지 않도록 보장해야 함
   - 예) 쓰레드 4개가 프로세스 2개에서 스케줄링 된다고 가정
     + 추가로 쓰레드 1(T1)이 L1과 L2 락을, (실행 중일 때 임의의 순서로 획득), T2도 L1과 L2 락을, T3은 L2를 필요로 하고, T4는 락을 필요로 하지 않는다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/6b7369f5-2914-47a1-853e-c6c6d039e5e0">
</div>

   - T1과 T2만 동시에 실행하지 않는다면 교착 상태는 절대로 발생하지 않음
<div align="center">
<img src="https://github.com/user-attachments/assets/6b7369f5-2914-47a1-853e-c6c6d039e5e0">
</div>

   - (T3과 T1) 또는 (T3과 T2) 끼리는 겹쳐서 실행이 되도 괜찮음
   - T3이 절대로 교착 상태를 유발하지 않는 이유는 단 하나의 락만 필요하기 때문임

   - 예) 동일한 자원에 대해 경쟁이 심해졌다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/f9836256-4587-4ca7-89cf-a76b581a2c01">
</div>

   - 쓰레드 T1, T2 그리고 T3이 실행 중 어느 시점에 모두 L1과 L2 락을 획득하는 경우
   - 그런 경우 교착 상태가 절대로 발생하지 않도록 하는 가능한 스케줄링
<div align="center">
<img src="https://github.com/user-attachments/assets/0f11d2d9-72c3-4f71-a589-cfe37bab853a">
</div>

   - 정적 스케줄링은 T1, T2 그리고 T3이 모두 한 프로세서에서 실행되도록 보수적인 방법을 선택했으므로, 전체 작업이 끝나기까지 상당히 오랜 시간 소요
   - 병행이 가능할 수 있겠지만, 교착 상태가 발생할 수 있기 때문에 성능 하락을 수반
   - 유명한 예롤 Dijkstra 은행원 알고리즘(Banker's Algorithm)이 있음

6. 발견 및 복구
   - 교착 상태 발생을 허용하고, 교착 상태를 발견하면 복구하는 방법
   - 예를 들어, 운영체제가 일 년에 한 번 멈춘다고 했을 때 재부팅을 하고 다시 작업을 처리
   - 많은 데이터베이스 시스템들이 교착 상태를 발견하고 회복하는 기술 사용
     + 교착 상태 발견은 주기적으로 실행되며, 자원 할당 그래프를 그려 사이클이 생겼는지 검사
     + 사이클이 발생하는 경우(교착 상태 경우) 시스템은 재부팅 되어야 함
     + 자료 구조에 대한 복잡한 복구가 필요할 경우 사람이 직접 복구 작업을 수행할 수 있음
     
7. 참고 : 락 주소를 사용하여 락 요청 순서를 강제하기
   - 어떤 경우엔 함수가 두 개 또는 그 이상의 락을 획득하려하기 때문에 주의하지 않으면 교착 상태가 발생할 수 있음
   - 예) do_something(mutex_t *m1, mutex_t *m2)과 같이 호출되는 함수가 있다고 가정
     + 이 코드가 m1을 m2 전에 (또는 그 반대 순서로) 항상 획득한다면 교착 상태가 될 수 있음
     + 한 쓰레드가 do_something(L1, L2)이라고 호출하고 다른 쓰레드가 do_something(L2, L1)을 호출할 수 있기 때문임
     + 이러한 경우릎 피하기 위해서는 주소의 값을 사용해 락 획득 순서를 정하기도 함 : 오름차순이나 내림차순으로 주소를 정렬하여 락 획득 순서를 정하면 어떤 순서로 넣어도 락 획득 순서는 변하지 않음
     + 이 간단한 기법을 사용하면 개발자는 멀티 락 획득 상황에서 간단하고 효율적으로 교착 상태 방지 가능
```c
if (m1 > m2) { // 락을 주소의 내림차순으로 획득하기
    pthread_mutex_lock(m1);
    pthread_mutex_lock(m2);
} else {
    pthread_mutex_lock(m2);
    pthread_mutex_lock(m1);
} // 코드는 m1 != m2를 가정함 (서로 같은 락이 아님)
```
