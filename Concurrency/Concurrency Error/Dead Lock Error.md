-----
### 교착 상태 오류
-----
1. 병행성 관련 오류 외 복잡한 락 프로토콜을 사용하는 다수의 병행 시스템에서 교착 상태(Deadlock)라는 고전적 문제가 발생
   - 예를 들어 락 L1을 갖고 있는 쓰레드 1이 또 다른 락 L2를 기다리는 상황에서 락 L2를 갖고 있는 쓰레드가 락 L1이 해제 되기를 기다리고 있을 때 교차 상태 발생
```c
Thread 1:     Thread 2:
lock(L1);     lock(L2);
lock(L2);     lock(L1);
```

   - 이 코드에서는 교착 상태가 발생할 수 있음
     + 쓰레드 1이 락 L1을 획득하고 난 후 문맥 교환이 발생하여 쓰레드 2가 실행
     + 쓰레드 2가 락 L2를 획득하고 락 L1를 획득하려고 시도
     + 이 때, 교착 상태가 발생하며, 각 쓰레드가 상대방이 소유하고 있는 락을 대기하고 있으므로 누구도 실행할 수 없게 됨
<div align="center">
<img src="https://github.com/user-attachments/assets/9cce5419-9c3e-49ac-a42d-bcb3cad4aefd">
</div>

   - 그래프에서 싸이클(Cycle)은 교착 상태 발생 가능성을 의미

2. 교착 상태가 발생하는 원인
   - 교착 상태의 상황은 쓰레드 1과 쓰레드 2가 같은 순서로 획득한다면 교착 상태는 절대 발생하지 않음
   - 발생하는 이유는 코드가 많아지면서 구성 요소 간 복잡한 의존성이 발생하기 때문임 (예) 운영체제에서는 가상 메모리 시스템이 디스크 블럭을 가져오기 위해 파일 시스템에 접근하는데, 파일 시스템은 디스크 블럭을 메모리에 탑재하기 위해 메모리 페이지를 확보하고, 이를 위해 가상 메모리 시스템에 접근하는데, 이처럼 자연스럽게 존재하는 순환 의존성이 교착 상태를 야기하는데, 이를 방지하기 위해 대형 시스템의 락 사용 전략은 매우 신중하게 설계되어야 함)
   - 또 다른 이유는 캡슐화(Encapsulation)의 성질 때문임 : 소프트웨어 모듈화가 개발을 쉽게 하므로 소프트웨어 개발자들은 상세한 구현 내용은 감추지만, 모듈화와 락은 잘 조화되지 않음
     + 예) 자바의 Vector 클래스에서 AddAll() 메서드의 경우 다음과 같이 호출
```java
Vector v1, v2;
v1.AddAll(v2);
```
   - 이 메서드의 경우 멀티 쓰레드에 안전해야 하므로, 내부적으로 v1에 더해지는 벡터 뿐 아니라 인자로 전달되는 v2에 대한 락도 같이 획득해야 함
   - 이 루틴은 v2의 내용을 먼저 v1에 더하기 위해 임의의 순서로 말한 락들을 획득하는데, 여기서는 v1을 먼저 획득하고 v2를 획득한다고 가정 : 어떤 쓰레드가 v2.AddAll(v1)을 거의 동시에 호출하면 교착 상태가 발생하기 쉬움 (이런 모든 상황은 호출한 응용 프로그램 모르게 진행)

3. 교착 상태 발생 조건 : 총 네 가지 조건이 충족되어야 함
   - 상호 배제(Mutual Exclusion) : 쓰레드가 자신이 필요로 하는 자원에 대한 독자적인 제어권을 주장 (예) 쓰레드가 락을 획득함)
   - 점유 및 대기(Hold-and-Wait) : 쓰레드가 자신에게 할당된 자원 (예) 이미 획득한 락)을 점유한 채로 다른 자원(예) 획득하고자 하는 락)을 대기
   - 비 선점 (No Preemption) : 자원(락)을 점유하고 있는 쓰레드로부터 자원을 강제적으로 뺏을 수 없음
   - 환형 대기 (Circular Wait) : 각 쓰레드는 다음 쓰레드가 요청한 하나 또는 그 이상의 자원(락)을 갖고 있는 쓰레드들의 순환 고리가 있음
   - 이 네 가지 조건 중 하나라도 만족시키지 않으면, 교착 상태가 발생하지 않음
