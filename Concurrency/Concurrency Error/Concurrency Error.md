-----
### 병행성 관련 오류의 종류
-----
1. DBMS의 MySQL, 웹 서버로 잘 알려진 Apache, 유명한 웹 브라우저인 Mozilla, 실제로 많이 사용하는 MS 오피스 모음인 OpenOffice를 토대로 분석 (이들 코드에서 발견된 병행성 관련 오류에 대해 정량적 분석)
2. 정리한 오류의 통계
<div align="center">
<img src="https://github.com/user-attachments/assets/1fc0af0c-d674-4b2c-a1d2-f16f2966b32f">
</div>

   - 총 105개의 오류가 있고, 대부분(74개) 오류는 교착 상태와 무관
   - 나머지 31개 오류들이 교착 상태와 관련있음
   - 각 응용 프로그램 오류 수에 대한 결과에서 알 수 있는 것은 OpenOffice는 총 8개의 병행성 오류가 있었고, Mozilla는 거의 60개 관련 오류가 존재

-----
### 비 교착 상태 오류
-----
1. 비 교착 상태 오류 중 가장 대표적인 두 종류 오류 : 원자성 위반(Atomicity Violation) 오류와 순서 위반(Order Violation) 오류
2. 원자성 위반 오류
   - MySQL에서 발견한 간단한 예제
<div align="center">
<img src="https://github.com/user-attachments/assets/73c4cfee-9e1e-456a-8709-0bb3428a6550">
</div>

   - 이 예제에서는 thd 자료 구조의 proc_info 필드의 두 개의 다른 쓰레드가 접근
     + 첫 번째 쓰레드는 그 값이 NULL인지 검사하고 값을 출력
     + 두 번쨰 쓰레드는 값을 NULL로 설정

   - 첫 번째 쓰레드가 검사를 완료한 후 fputs를 호출하기 전 인터럽트로 인해서 두 번째 쓰레드가 그 사이 실행될 수 있는데, 두 번쨰 쓰레드가 실행되면 필드의 값은 NULL로 설정하기 떄문에 fputs의 함수는 NULL 포인터 역 참조를 하게 되어 프로그램은 크래시 발생
   - 원자성 위반 : 다수의 메모리 참조 연산들 간에 있어 예상했던 직렬성(Serialization)이 보장되지 않음 (즉, 코드 일부에 원자성이 요구되었으나, 실행 시 그 원자성이 위반되었음)
     + 위 예에서는 proc_info 필드의 NULL 값 검사와 fputs() 호출 시 proc_info를 인자로 사용하는 동작이 원자적으로 실행되는 것을 가정
     + 하지만, 이 가정이 깨지면, 코드는 의도한대로 동작하지 않으므로, 가정은 깨짐

   - 락을 추가하여 어느 쓰레드든 proc_info 필드 접근 시, proc_info_lock 이라는 락 변수를 획득하도록 해야 함 (물론, 이 자료 구조를 사용하는 다른 모든 코드들도 락으로 보호해야 함)
<div align="center">
<img src="https://github.com/user-attachments/assets/1c796730-c671-409d-b7ac-ca6913913d24">
</div>

3. 순서 위반 오류
<div align="center">
<img src="https://github.com/user-attachments/assets/3215034e-47a4-41e4-934e-ecdda9473694">
</div>

  - 쓰레드 2의 코드는 mThread 변수가 이미 초기화(그리고 NULL이 아닌 것으로)가 가정하고 있음
  - 하지만, 만약 쓰레드 1이 먼저 실행되지 않았다면, 쓰레드 2는 NULL 포인터를 사용하기 때문에 크래시될 것(mThread 값이 초기에 NULL이었다고 가정, 그게 아니라면 쓰레드 2가 임의의 메모리 주소에 접근하게 됨)
  - 순서 위반의 정의 : 두 개의 (그룹의) 메모리 참조 간의 순서가 바뀜 (즉, A가 항상 B보다 먼저 실행되어야 하지만, 실행 중 그 순서가 지켜지지 않음)
  - 오류 수정 방법은 순서를 강제시키는 것으로, 컨디션 변수를 사용
<div align="center">
<img src="https://github.com/user-attachments/assets/619de075-68bc-43ee-a640-3e44c694fd85">
</div>

   - 수정된 코드에서는 mtLock이라는 락, 그에 대한 컨디션 변수 mtCond, 그리고 상태 변수 mtInit 추가
   - 초기화 코드가 실행되면 mtInit의 상태를 1로 설정하고 초기화를 완료했다고 시그널을 보냄
   - 만약 쓰레드 2가 이 시점 전에 실행된다면 상태가 변경되기를 기다림
   - 이후 다시 쓰레드 2가 실행되면 상태 값 초기화 여부를 검사 후, (즉, mtInit이 1로 설정되었는지 검사) 올바르게 계속 진행
   - 쓰레드 간 순서가 문제가 되면 컨디션 변수(또는 세마포어)를 사용해 해결 가능

4. 정리
   - 비 교착 상태 오류의 대부분(97%)은 원자성 또는 순서 위반에 대한 것
   - 이러한 오류 패턴에 유의하면 관련 오류들을 줄일 수 있으며, 더 나아가, 자동화된 코드 검사 도구들이 개발될수록 비 교착 상태 오류들에 초점을 맞출 것임
   - 비 교착 상태 오류가 전체 오류 분포 중 많은 비중을 차지
   
