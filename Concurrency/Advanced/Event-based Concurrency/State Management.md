-----
### 문제점 : 상태 관리
-----
1. 이벤트 기반 접근법의 또 다른 문제점은 쓰레드 기반 코드보다 일반적으로 더 작성하기 복잡함
   - 이벤트 핸들러가 비동기 I/O를 발생시킬 떄, I/O 완료 시 사용할 프로그램 상태를 정리해 놓아야 함
   - 이 작업은 쓰레드 기반 프로그램에서는 불필요함 (이미 쓰레드 스택에 그 정보들이 존재함)

2. Adya 등은 이것을 수동 스택 관리(Manual Stack Management)라고 부르며 이벤트 기반 프로그래밍에서는 기본

3. 예) 쓰레드 기반 서버
   - 이 서버는 파일 디스크럽터 (fd)로 명시된 파일에서 데이터를 읽어들여, 해당 데이터들을 네트워크 소켓 디스크럽터 (sd)로 전송
   - (오류 처리는 무시한) 코드
```c
int rc = read(fd, buffer, size);
rc = write(sd, buffer, size);
```
   - 이러한 작업은 멀티 쓰레드 프로그램에서는 매우 간단 (read()가 리턴되면, 전송할 네트워크 소켓에 관한 정보가 스택에 존재)

4. 이벤트 기반 시스템에서는 상황이 간단하지 않음
   - 같은 일을 하려면 AIO 호출들을 사용해 read()를 비동기로 요청해야 함
   - aio_error()를 사용해 주기적으로 읽기가 종료되었는지 확인한다고 가정
     + Continuation을 사용 : 이벤트를 종료하는데 필요한 자료들을 한 곳에 저장해두고, 이벤트가 발생하면(디스크 I/O가 완료되면), 저장해 놓은 정보들을 활용해 이벤트를 처리

   - 앞서 사용한 예의 해법은 소켓 디스크럽터(sd)를 파일 디스크럽터(fd)가 사용하는 자료 구조(예) 해시 테이블)에 저장해 놓는 것
     + 디스크 I/O가 완료되면 이벤트 핸들러가 파일 디스크럽터에서 다음 할 일을 파악하여 호출자에게 소켓 디스크럽터의 값을 반환하도록 함
     + 이 시점에서 (최종적으로), 서버는 소켓에 데이터를 기록하는 마지막 동작을 할 수 있게 됨
     
