-----
### 중요 API : select(), poll()
-----
1. 이벤트는 대부분 시스템은 select() 또는 poll() 시스템 콜을 기본 API로서 제공
2. 인터페이스의 기능
   - 도착한 I/O들 중 주목할 만한 것이 있는지 검사
   - 예를 들면, 웹 서버 같은 네트워크 응용 프로그램이 자신이 처리할 패킷의 도착 여부를 검사하는 것
   - 이 시스템 콜들이 정확히 해당 역할을 함

3. 예) select()
```c
1 int select(int nfds,
2             fd_set *restrict readfds,
3             fd_set *restrict writefds,
4             fd_set *restrict errorfds,
5             struct timeval *restrict timeout);
```
   - select()는 readfds, writefds, errorfds를 통해 전달된 I/O 디스크립터(Descriptor) 집합들을 검사해서, 각 디스크립터들에 해당하는 입출력 디바이스가 읽은 준비가 되었는지, 쓸 준비가 되었는지, 처리해야 할 예외 조건이 발생했는지 등 파악
   - 각 집합의 첫 번째 nfds개의 디스크럽터들, 즉, 0부터 nfds - 1까지 디스크럽터를 검사
   - select는 집합을 가리키는 각 포인터들을 준비된 디스크럽터들의 집합으로 교체하며, 전체집합에서 준비된 디스크럽터의 총 개수를 반환

4. 알아두어야 할 사항
   - select()를 이용하면 디스크럽터에 대한 읽기 가능 여부, 쓰기 가능 여부를 검사할 수 있음
     + 전자는 처리해야할 패킷의 도착 여부를 파악할 수 있으며, 후자는 서비스가 응답 전송이 가능한 시점(예를 들어 아웃바운드(Outbound) 큐가 가득 차지 않았음)을 파악하도록 해줌
   - timeout 인자의 존재
     + 일반적으로 NULL로 설정하는데, select()는 디스크럽터가 준비될 때까지 무한정 대기
     + 하지만, 오류에 대비하도록 설계된 서버들의 경우 timeout 값을 설정하기도 함
     + 널리 사용되는 방법으로는 timeout 값을 0으로 설정하여 select()가 즉시 리턴되도록 함

5. poll() 시스템 콜도 유사
6. 이런 기본 함수로 Non-Blocking Event Loop를 만들어, 패킷 도착을 확인하고, 소켓에서 메세지를 읽고 필요에 따라 응답할 수 있도록 해줌

-----
### 차단(Blocking)과 비차단(Non-Blocking) 인터페이스
-----
1. 차단(또는 동기(Synchronous)) 인터페이스는 호출자에게 리턴하기 전 자신의 작업을 모두 처리
2. 비차단(또는 비동기(Asynchronous)) 인터페이스는 작업을 시작하기는 하지만, 즉시 반환하므로 처리되어야 하는 일이 백그라운드에서 완료
3. 차단 호출은 주로 I/O 때문에 발생하며, 예를 들어, 작업 완료를 위해서 디스크에서 읽어야 하는 자료가 있다면, 디스크에 요청한 I/O 요청을 대기해야 함
4. 비차단 인터페이스는 모든 프로그래밍(예) 멀티 쓰레드 프로그래밍) 스타일에서 사용될 수 있음
   - 하지만, 이벤트 기반 프로그래밍 방식에서는 필수적
   - 차단 방식의 시스템 콜이 전체 시스템을 멈출 수 있기 때문임

-----
### select()의 사용
-----
1. 어떤 네트워크 디스크럽트에 메시지가 도착했는지 파악하는 경우
<div align="center">
<img src="https://github.com/user-attachments/assets/a3b0ab9a-6c0c-4bfc-a3c1-2ef2a52ceb66">
</div>

   - 초기화 이후 서버는 무한 루프에 들어감
   - 그 루프 내에서 FR_ZERO() 매크로를 사용해 파일 디스크럽터를 초기화 한 후, FD_SET()를 사용해 minFD에서부터 maxFD까지 파일 디스크럽터 집합에 포함
   - 이 집합은 서버가 보고 있는 모든 네트워크 소켓 같은 것들을 나타낼 수 있음
   - 마지막으로 서버는 select()를 호출하여 데이터가 도착한 소켓이 있는지 검사
   - 반복문 내 FD_ISSET()를 사용하여 이벤트 서버는 어떤 디스크럽터들이 준비된 데이터를 갖고 있는지 알 수 있으며 도착하는 데이터를 처리할 수 있게 됨

2. 물론, 실제 서버는 이보다 더 복잡함
   - 디스크 작업이나 메세지를 보내는 시점, 그 외 세부사항들을 결정하는 로직이 필요
  
3. 참고 : 이벤트 기반 서버 내에서는 블럭을 사용하지 말 것
   - 이벤트 기반 서버는 작업의 스케줄링을 정밀하게 제어 가능
   - 하지만, 정밀한 제어를 위해서는 호출자가 실행한 것을 차단할 수 있는 어떤 호출도 있어서는 안 됨 (이를 지키지 않으면 서버가 멈추게 됨)

-----
### 간단한 이유 : 락이 필요 없음
-----
1. 매순간에 단 하나의 이벤트만 다루기 때문에 락을 획득하거나 해제할 필요가 없음
2. 이벤트 기반의 서버는 단 하나의 쓰레드만 갖고 있으므로 다른 쓰레드에 의해 인터럽트가 걸릴 수 없음
3. 따라서, 쓰레드 프로그램에서 흔한 병행성 버그는 기본적인 이벤트 기반 접근법에서는 나타지 않음
