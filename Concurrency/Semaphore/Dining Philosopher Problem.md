-----
### 식사하는 철학자 문제
-----
1. Dijkstra가 제기한 식사하는 철학자(Dining Philosopher)라는 유명한 문제가 존재
<div align="center">
<img src="https://github.com/user-attachments/assets/0e1120b5-2417-44ce-b60e-3ed1e0bd7188">
</div>

  - 다섯 명의 철학자가 식탁 주위에 둘러앉아있음
  - 총 다섯 개 포크가 철학자와 철학자 사이에 하나씩 놓여 있으며, 철학자는 식사하는 때가 있고, 생각하는 때가 존재
  - 생각 중일 때는 포크가 필요 없음
  - 식사 중일 때는 자신의 왼쪽과 오른쪽에 있는 포크를 들어야 식사를 할 수 있음
  - 이 포크를 잡기 위한 경쟁과 그에 따른 문제가 병행 프로그래밍에서 다루는 철학자 문제

2. 각 철학자의 기본 동작
```c
while (1) {
    think();
    getforks();
    eat();
    putforks();
}
```
  - 주요 쟁점은 getforks()와 putforks()의 루틴을 작성하되 교착 상태에 발생을 방지
  - 어떤 철학자도 못 먹어서 굶주리면 안 되며, 병행성이 높아야 함 (즉, 가능한 많은 철학자가 동시에 식사를 할 수 있어야 함)

3. 문제 해결을 위한 몇 가지 함수 사용
```c
int left(int p) { return p; }
int right(int p) { return (p + 1) % 5; }
```
  - 철학자 p가 자신의 왼쪽에 있는 포크를 잡기 원한다면 left(p)를 호출
  - 마찬가지로 철학자 p가 자신의 오른쪽에 있는 포크를 잡기 원한다면 right(p) 호출
  - 마지막 철학자(p = 4)가 자신의 오른쪽의 포크인 포크 0을 잡으려고 할 경우를 위해 나머지(Modulo) 연산 사용
  - 이 문제를 해결하기 위해 세마포어가 필요 : 각 포크마다 한 개씩 총 다섯개가 있고 sem_t fork(5)로 정의

4. 불완전한 해답
   - forks 배열에 있는 각 포크에 대한 세마포어를 1로 초기화
   - 각 철학자는 자신의 순번(p)을 알고 있다고 가정
   - getforks()와 putforks()의 루틴
<div align="center">
<img src="https://github.com/user-attachments/assets/d9d1ae75-3789-49ca-b95f-e3c6b9912732">
</div>

   - 포크가 필요할 때 단순하게 하나의 락을 획득
   - 먼저 왼쪽의 것을 잡고, 다음에 오른쪽 것을 잡음
   - 그리고 식사가 끝나면 잡은 순서대로 놓음

   - 문제점 : 교착 상태
     + 각 철학자가 만약 자신의 왼쪽의 포크를, 다른 철학자가 자신의 오른쪽 포크를 잡기 전에 먼저 잡았다면, 각 철학자는 하나의 포크만 들고서 다른 하나의 포크를 잡을 수 있게 되기를 평생 기다려야 함
     + 구체적으로 살펴보면, 철학자 0이 포크 0을 잡고, 철학자 1이 포크 1, 철학자 2가 포크 2, 철학자 3은 포크 3, 철학자 4는 포크 4를 잡음
     + 모든 포크는 누군가 다 잡고 있으므로, 모든 철학자는 다른 철학자가 갖고 있는 포크를  기다리며 대기

5. 해답 : 의존성 제거
   - 최소한 하나의 철학자는 다른 순서로 포크를 잡도록 설정 (Dijkstra의 해결책)
   - 가장 높은 순번의 철학자 4가 포크를 다른 순서로 획득한다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/7f2785fa-d647-4cd8-b528-24409ed1f647">
</div>

   - 마지막 철학자가 오른쪽의 포크를 먼저 잡기 때문에 각 철학자가 하나의 포크를 든채로 기다리는 대기 상황을 발생하지 않음 (환형 대기 상태가 끊어짐)

6. 이와 유사한 문제 : 흡연가의 문제 (Cigarette Smoker Problem) 또는 잠자는 이발사의 문제 (Sleeping Barber Problem)
