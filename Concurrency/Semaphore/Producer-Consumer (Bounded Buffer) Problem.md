-----
### 생산자 / 소비자 (유한 버퍼) 문제
-----
1. 첫 번째 시도
   - empty와 full이라는 두 개의 세마포어 사용
   - 쓰레드는 empty와 full을 사용하여 버퍼 공간이 비었는지, 채워졌는지 확인
   - put()과 get() 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/87dfcca8-1e07-4d23-8407-0cfdb0a7d261">
</div>

  - 생산자 / 소비자 문제를 해결하기 위해 시도한 해법
<div align="center">
<img src="https://github.com/user-attachments/assets/27673bea-d436-498a-8cf5-0113326d51fb">
</div>

  - 이 예제에서는 생산자는 버퍼가 비워져서 데이터를 넣을 수 있기를 기다리고, 마찬가지로 소비자는 데이터를 꺼내기 위해 버퍼가 채워지기를 기다림
<div align="center">
<img src="https://github.com/user-attachments/assets/73af59e4-d6c5-45ad-9e04-7779774cd9aa">
</div>

  - MAX = 1인 상황(버퍼의 크기가 1인 경우)
    + 생산자와 소비자 쓰레드가 각 하나씩 있고, CPU도 하나인 상황
    + 소비자가 먼저 실행했다고 가정하면 소비자 쓰레드가 그림에서 C1 라인에 먼저 도달하여 sem_wait(&full)을 호출
    + 변수 full 값은 0으로 초기화되었기 때문에 해당 명령으로 인해 full 값은 -1로 감소하고, 소비자는 대기
    + 다른 쓰레드가 sem_post()를 호출해서 full 변수가 증가하길 기다려야 함
    + 그런 이후 생산자 쓰레드가 P1 라인에서 sem_wait(&empty) 루틴을 호출
    + empty 변수가 MAX(여기서는 1)로 설정되었으므로 소비자와 다르게 생산자는 다음 문장을 계속 실행
    + empty 변수는 감소하여 0이 되고 생산자가 데이터 값을 버퍼의 첫 번째 공간에 넣음 (P2)
    + 그런 후 생산자는 P3 라인의 sem_post(&full)를 호출하여 세마포어의 full의 세마포어의 값을 -1에서 0으로 변경하고 소비자 쓰레드를 깨움 (대기 상태에서 준비 상태로 변경)

2. 문제점
   - 생산자가 계속 실행한다면 반복문을 돌아 P1 라인을 다시 실행
   - empty 세마포어의 값이 0이므로 대기 상태에 들어감
   - 생산자 프로세스가 인터럽트에 걸리고 소비자 쓰레드가 실행된다면 sem_wait(&full)문 (C1 라인)을 호출하면서 버퍼가 가득찼다는 걸 발견하고 데이터 소비

3. MAX 값이 1보다 크고(MAX = 10), 생산자와 소비자 쓰레드들이 여러 개 있다고 가정
   - 경쟁 조건이 발생
   - 두 개의 생산자 Pa와 Pb가 있는데, 두 쓰레드가 거의 동시에 put()을 호출했다고 가정
   - Pa가 먼저 실행되어서 버퍼에 첫 공간에 값을 넣기 시작(f1 라인에서 fill = 0)
   - Pa 쓰레드가 fill 카운터 변수가 1로 변경하기 전에 인터럽트가 걸림
   - 생산자 Pb가 실행되고, f1 라인에서 마찬가지로 버퍼의 첫 번째 공간에 데이터를 삽입
   - 그러면, Pa가 기록한 이전 값은 새로운 값으로 대체 (즉, 생산자의 데이터가 사라짐)

4. 해답 : 상호 배제 추가
   - 버퍼를 채우고 버퍼에 대한 인덱스를 증가하는 동작은 임계 영역이므로 신중하게 처리해야 함
   - 세마포어와 몇 개의 락을 추가
<div align="center">
<img src="https://github.com/user-attachments/assets/d9dd3b20-057b-42b9-931b-0c9e437bc003">
</div>

   - put() / get() 코드에 락을 추가했으며 추가된 라인은 추가됨으로 표기
   - 하지만, 교착 상태에 봉착

5. 교착 상태의 방지
   - 생산자와 소비자 쓰레드가 각 하나씩 있다고 가정
   - 소비자가 먼저 실행되었으며, mutex(c0 라인)를 획득하고 full 변수에 대해 sem_wait()(c1 라인)를 호출
   - 아직 데이터가 없으므로 소비자는 대기해야 하고 CPU를 양보해야 하는데, 소비자가 아직 락을 획득하고 있음
   - 생산자가 실행되면서, 실행이 가능한 데이터를 생성하고 소비자 쓰레드를 깨울 것임
   - 불행하게도 이 쓰레드는 먼저 mutex 세마포어에 대해 sem_wait()를 실행 (p0 라인)
   - 이미 락은 소비자가 획득한 상태이므로 생산자 역시 대기로 진입
   - 즉, 순환 고리가 생겼는데, 소비자는 mutex를 갖고 있으면서 다른 full 시그널을 발생시키기를 대기하고 있어야 하는데, full 시그널을 발생시켜야 하는 생산자는 mutex에서 대기 중
   - 즉, 소비자와 생산자가 서로를 기다리는 전형적인 교착 상태

6. 최종
   - 락의 범위(Scope)를 줄여야 함
<div align="center">
<img src="https://github.com/user-attachments/assets/a7aee965-ea6a-4ef7-9cf4-14c07ccf190f">
</div>

   - mutex를 획득하고 해제하는 코드를 임계 영역 바로 이전과 이후로 이동
   - full이나 empty 관련 코드는 mutex 밖으로 배치
   - 그 결과, 멀티 쓰레드 프로그램에서 사용 가능한 유한 버퍼를 만듬
