-----
### Reader-Writer 락
-----
1. 다양한 자료 구조를 접근하는 데 여러 종류 락 기법이 필요
   - 리스트에 삽입하고 간단한 검색을 하는 것과 같은 병행 연산이 여러 개 있다고 가정
   - 삽입 연산은 리스트의 상태를 변경하고 (전통적인 임계 보호 방식으로 해결 가능) 검색은 자료 구조를 단순히 읽기만 함
   - 삽입 연산이 없다는 보장만 된다면 다수의 검색 작업을 동시에 수행 가능 : 이와 같은 경우를 위해 만들어진 락을 Reader-Writer 락

2. 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/08e43d8c-d2c3-40e6-b78b-95b2cba134a5">
</div>

  - 자료 구조를 갱신하려면 새로운 동기화 연산 쌍을 사용
  - 락을 획득하기 위해서 rwlock_acquire_writelock()을 사용하고, 해제하기 위해 rwlock_release_writelock()을 사용
  - 내부적으로는 writelock 세마포어를 사용하여 하나의 쓰기 쓰레드만이 락을 획득할 수 있도록 하며, 임계 영역 진입 후 자료 구조를 갱신

3. 읽기 락(Reader Lock)의 획득과 해제
   - 읽기 락을 획득 시 읽기 쓰레드(Reader)가 먼저 락을 획득하고 읽기 중인 쓰레드의 수를 표현하는 reader 변수를 증가시킴
   - 첫 번째 읽기 쓰레드가 읽기 락을 획득할 때 중요 과정
     + 읽기 락을 획득 시 writelock 세마포어에 대해 sem_wait()를 호출하여 쓰기 락을 함께 획득
     + 획득한 쓰기 락은 읽기 락을 해제 할 때, sem_post()로 다시 해제
   - 이 과정을 통해 락을 획득하고 난 후, 다른 읽기 쓰레드들이 읽기 락을 획득할 수 있도록 함
   - 다만, 쓰기 락을 획득하려는 쓰기 쓰레드(Writer)들은 모든 읽기 쓰레드가 끝날 떄까지 대기하여야 함
   - 임계 영역을 빠져나오는 마지막 읽기 쓰레드가 writelock에 대한 sem_post()를 호출하여 대기 중인 쓰레드가 락을 획득할 수 있도록 함

4. 단점
   - 공정성 : 쓰기 쓰레드가 상대적 불리
     + 쓰기 쓰레드에게 기아 현상이 발생하기 쉬움

   - 읽기-쓰기 락을 사용할 때 주의가 필요
     + 기법이 정교할 수록 오버헤드가 커지기 때문에, 항상 성능이 좋은 것이 아님
