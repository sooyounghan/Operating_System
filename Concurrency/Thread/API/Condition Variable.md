-----
### 컨디션 변수
-----
1. 한 쓰레드가 계속 진행하기 전에 다른 쓰레드가 무언가를 해야 쓰레드 간 일종의 시그널 교환 메커니즘이 필요한데, 이런 경우 컨디션 변수가 사용
   - 두 개의 기본 루틴
```c
int pthread_cond_wait(pthread_cond_t *cond , pthread_mutex_t *mutex);
int pthread_cond_signal(pthread_cond_t *cond);
```

2. 💡 컨디션 변수를 사용하기 위해서는 이 컨디션 변수와 연결된 락이 반드시 존재해야 함
   - 위의 루틴 중 하나를 호출하기 위해서는 그 락을 가지고 있어야 함

3. pthread_cond_wait()는 호출 쓰레드를 수면(Sleep) 상태로 만들고 다른 쓰레드로부터 시그널을 대기
   - 현재 수면 중인 쓰레드가 관심 있는 무언가가 변경되면 시그널을 보냄
```c
1 pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
2 pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
3
4 Pthread_mutex_lock(&lock);
5 while (ready == 0)
6     Pthread_cond_wait(&cond , &lock);
7 Pthread_mutex_unlock(&lock);
```
   - 연관된 락과 컨디션 변수를 초기화한 후에는 쓰레드는 ready 변수가 0인지 검사
   - ready 변수가 0이라면, 다른 쓰레드가 깨워줄 때까지 잠들기 위해 대기 루틴 호출
   - 다른 쓰레드에서 실행될 잠자는 쓰레드를 깨우는 코드
```c
Pthread_mutex_lock(&lock);
ready = 1;
Pthread_cond_signal(&cond);
Pthread_mutex_unlock(&lock);
```
   - 유의사항
     + 시그널을 보내고 전역 변수 ready를 수정할 때 반드시 락을 가지고 있어야하며, 이를 통해 경쟁 조건이 발생하지 않는다는 것을 보장
     + 시그널 대기 함수에서는 락을 두 번쨰 인자로 받고 있지만, 시그널 보내기 함수에서는 조건만을 인자로 받는 것에 유의해야 함
     + 이런 차이의 이유는 호출 쓰레드를 재우는 것 외에 락도 반납(Release)해야 하기 때문임
     + pthread_cond_wait()는 깨어나서 리턴하기 직전에 락을 다시 획득하며, 처음 락을 획득한 떄부터 마지막에 락을 반납하기 전까지 pthread_cond_wait()를 실행한 쓰레드를은 항상 락을 획득한 상태로 실행된다는 것을 보장

4. 특이사항
   - 대기하는 쓰레드가 조건을 검사할 때 if문을 사용하는 대신 while문을 사용
   - while문을 사용하는 것이 일반적으로 간단하고 안전함
     + pthread 라이브러리에서 실수 또는 부주의하게 변수를 제대로 갱신하지 않고 대기하던 쓰레드를 깨울 수 있음
     + 이런 경우 재검사를 하지 않는다면, 대기하던 쓰레드는 조건이 변경되지 않았더라도 변경되었다고 생각할 것
     + 떄문에 시그널의 도착은 변경 사실을 알리는 것이 아니라, 변경된 것 같으니 검사해보라는 정도의 힌트로 간주하는 것이 더 안전
    
   - 두 쓰레드 간 시그널을 주고받아야 할 때, 락과 컨디션 변수를 사용하는 대신 간단한 플래그를 사용하여 구현하고 싶은데, 예를 들어 대기 코드를 다음과 같이 작성할 수 있음
```c
while (ready == 0)
    ; // 회전
```
   - 상응하는 시그널 보내기 코드
```c
ready = 1;
```
   - 이러한 방법은 성능이 좋지 않음 : 조건 검사를 위해 오랫동안 반복문을 실행하여 검사하는 것은 CPU 사이클의 낭비 초래
   - 오류가 발생하기 쉬움 : 쓰레드 간 동기화를 위해 플래그를 사용할 때 실수하기가 쉬움
