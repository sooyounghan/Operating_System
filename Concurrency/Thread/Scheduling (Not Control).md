-----
### 제어 없는 스케줄링
-----
1. counter 갱신을 위한 컴파일러가 생성한 코드의 실행 순서 (카운터에 단순히 1이라는 숫자는 더하는 과정 예시)
   - x86에서 counter를 증가하는 코드
```
mov 0x8049a1c , %eax
add $0x1 , %eax
mov %eax , 0x8049a1c
```

   - 이 예제에서 사용하는 counter 변수의 위치 주소 : 0x8049a1c라고 가정
   - 먼저 x86의 mov 명령어가 명시한 메모리 주소 값을 읽어들인 후 eax 레지스터에 넣음
   - 그리고 1 (0x1)을 eax 레지스터의 값에 더하는 연산
   - 마지막으로 eax에 저장되어 있는 값을 메모리 원래 주소에 다시 저장

2. 두 개의 쓰레드 중 쓰레드 1이 counter를 증가시키는 코드 영역에 진입하여 counter의 값을 1 증가시키려는 상황 가정
   - counter에 있는 값은 50이었다고 하면, 50을 eax 레지스터에 넣음
   - 쓰레드 1에 있어서 eax = 50이 되며, 그 후에 레지스터 값에 1을 더하여 eax = 51이 됨
   - 만약, 타이머 인터럽트가 발생하여 운영체제가 실행 중인 쓰레드의 PC 값을 eax를 포함하는 레지스터들의 현재 상태를 쓰레드의 TCP에 저장
   - 쓰레드 2가 선택되고 counter 값을 증가시키는 똑같은 코드 영역에 진입
   - 첫 번째 명령어를 실행하여 counter 값을 얻어온 후 eax에 넣음
   - 쓰레드는 개별적으로 쓰레드 전용 레지스터를 가지고 있으며, 사용 중이던 레지스터들을 저장하고 복구하는 문맥 교환 코드에 의해 이 레지스터들은 가상화됨
   - counter 값은 아직 50을 나타내고 있어서 쓰레드 2의 eax 값은 50이며, 쓰레드 2가 다음 두 문장을 실행한다면 eax 값을 1 증가시키고 (eax = 51) 난 후에, eax 값을 counter(주소 0x8049a1c)에 저장
   - 전역 변수인 counter는 이제 51 값을 가짐
   
3. 최종적으로 또 한 번의 문맥 교환이 발생하면 쓰레드 1이 리턴하여 실행됨
   - 쓰레드 1은 mov와 add 동작을 실행하였고 이제 마지막의 mov 명령어를 수행하려는 중임
   - eax = 51이었으며, 따라서 mov 명령어가 실행되면 메모리의 레지스터 값을 저장하여 counter 값은 51이 됨

4. 즉, counter 값을 증가시키는 코드가 두 번 수행이 되었지만 50에서 시작한 counter 값을 증가시키는 코드가 두 번 수행되었지만 50에서 시작한 counter 값은 1 증가한 51
   - 정확하게 동작하도록 작성된 프로그램이라면 counter의 값은 52

5. 실행의 흐름
   - 이 예제에서 다음에 나타난 것과 같이 코드 메모리 주소가 100에 저장되었다고 가정
   - RISC 유사 명령어 집합에 대해 x86은 명령어들의 길이는 가변적이며, mov 명령은 5바이트 메모리 사용, add는 3바이트 메모리 사용
```
100 mov 0x8049a1c , %eax
105 add $0x1 , %eax
108 mov %eax , 0x8049a1c
```
<div align="center">
<img src="https://github.com/user-attachments/assets/8f82c62e-b8e1-406b-b038-9a97dccc9ddb">
</div>

   - counter의 값은 50에서 시작한다고 가정
   - 경쟁 조건 (Race Condition) : 명령어의 실행 순서에 따라 결과가 달라지는 상황
     + 문맥 교환이 때에 맞지 않게 실행되는 경우 잘못된 결과를 얻음
     + 사실, 경쟁 조건에 처한 경우에는 실행할 때마다 다른 결과를 얻음
     + 컴퓨터의 작동에서 일반적으로 발생하는 결정적 결과와 달리 결과가 어떠할지 알지 못하거나 실행할 때마다 다른 결과일 경우 비결정적(Indeterminate)인 결과라고 부름

   - 멀티 쓰레드가 같은 코드를 실행할 때 경쟁 조건이 발생하므로 이러한 코드 부분을 임계 영역(Critical Section)이라고 함
     + 공유 변수(또는 더 일반적으로는 공유 자원)를 접근하고 하나 이상의 쓰레드에서 동시에 실행하면 안되는 코드를 임계 영역이라고 함

   - 상호 배제(Mutual Exclusion)가 필요 : 하나의 쓰레드가 임계 영역 내의 코드를 실행 중일 때는 다른 쓰레드가 실행할 수 없도록 보장해줌
