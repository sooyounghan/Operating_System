-----
### 큐의 사용 : 스핀 대신 잠자기
-----
1. 이전 방법들의 근본 문제 : 너무 많은 부분을 운에 맡김
   - 스케줄러가 다음으로 실행될 쓰레드를 선정하는데, 만약 스케줄러가 안 좋은 선택을 한다면 실행되는 스케줄러는 회전을 하면서 대기
   - 또는 CPU를 즉시 양보해야 함
   - 두 방법 모두 낭비 여지가 있고 쓰레드가 굶주리게 되는 상황을 막지 못함

2. 어떤 쓰레드가 다음으로 락을 획득할지 명시적으로 제어할 수 있어야 함
   - 이를 위해서는 운영체제로부터 적절한 지원과 큐를 이용한 대기 쓰레드들의 관리가 필요

3. 간단한 설명을 위해 Solaris 방식 사용
   - 두 개의 호출문이 존재
   - park() : 호출하는 쓰레드를 잠재우는 함수
   - unpark(threadID) : threadID로 명시된 특정 쓰레드를 깨우는 함수
   - 이 두 루틴은 이미 사용 중인 락을 요청하는 프로세스를 재우고, 해당 락이 해제되면 꺠우도록 하는 락을 제작하는데 앞 뒤로 사용할 수 있음

4. 코드를 사용한 기법의 사용 예
<div align="center">
<img src="https://github.com/user-attachments/assets/964ecd7b-7daa-4aa1-9f97-8f6a9a8044c4">
</div>

   - Test-And-Set 개념을 락 대기자 전용 큐와 함께 사용하여 좀 더 효율적인 락을 만들 수 있음
   - 큐를 사용하여 다음으로 락을 획득할 대상을 제어하여 기아 현상을 피할 수 있음
   - guard 변수를 사용하여 flag와 큐의 삽입과 삭제 동작을 스핀 락으로 보호하는 데 사용 (다만 회전 대기를 완전히 배제하지는 못함)
   - 이 쓰레드는 락을 획득하거나 해제하는 과정에서 인터럽트에 걸릴 수 있음
     + 다른 쓰레드는 락의 해제를 기다리며 회전 대기
     + 하지만, 회전 대기의 시간은 꽤 짧으며, 사용자가 지정한 임계 영역에 진입하는 것이 아니라 락과 언락 코드 내 몇 개의 명령어만 수행하면 되므로 합리적

   - lock() 내 추가된 동작이 존재
     + lock()을 호출했는데, 다른 쓰레드가 이미 락을 보유했기 때문에 자신은 락을 획득할 수 없다면, gettid()를 호출하여 현재 실행 중인 쓰레드 ID를 얻고, 락 소유자의 큐에 자기 자신을 추가하고 guard 변수를 0으로 변경한 후 CPU를 양보

   - 💡 다른 쓰레드가 깨어났을 때 flag 변수가 0으로 설정되지 않음
     + 쓰레드가 깨어날 때 마치 쓰레드가 park()에서 리턴하는 것 처럼 보임
     + 하지만 그 시점에서는 guard 락을 획득한 상태가 아니므로 flag 변수의 값을 1로 변경하는 것을 시도조차 할 수 없음
     + 그렇기 때문에 락을 획득하려는 다음 쓰레드로 직접 전달하며, 그 사이에 flag는 0으로 변경되지 않음

   - park() 직전에 경쟁 조건이 발생함
     + 한 쓰레드는 락이 사용 중이라 park() 문을 수행하려고 함
     + 그 직전에 락 소유자한테 CPU가 할당된다면 문제가 발생할 수 있음
     + 예를 들어, 락을 보유한 쓰레드가 그 락을 해제했다고 가정
       * 쓰레드가 자기 차례에 park()를 수행하면 (잠재적으로) 깨어날 방법이 없음
       * 이 문제는 깨우기 / 대기 경쟁(Wakeup / Waiting race)이라고 불림

5. 깨우기 / 대기 경쟁을 해결하기 위해 Solaris는 세 번째 시스템 콜인 setpark()를 추가하여 해결
   - 이 루틴은 park()를 호출하기 직전이라는 것을 표시
   - 만약, 그 때 인터럽트가 수행되고, park()가 실제 호출되기 전 다른 쓰레드가 unpark()를 먼저 호출한다면, 추후 park() 문은 잠을 자는 대신 바로 리턴
```c
1 queue_add(m−>q 났 gettid());
2 setpark(); // 새로운 코드
3 m−>guard = 0;
```

6. guard 변수의 역할을 커널에서 담당하는 것도 하나의 방법
   - 그런 경우, 커널은 락 해제와 실행 중인 쓰레드를 큐에서 제거하는 동작을 원자적으로 처리하기 위해 주의해야 함
