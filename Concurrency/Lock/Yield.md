-----
### 간단한 접근법 : 양보
-----
1. 문맥 교환이 되어 쓰레드가 실행되었지만, 이전 쓰레드가 인터럽트에 걸리기 전 락을 이미 획득한 상태라서 그 쓰레드가 락을 해제하기를 기다리며 스핀만 무한히 하는 경우
2. 해결 방법 : 락이 해제되기를 기다리며 스핀해야 하는 경우 자신에게 할당된 CPU를 다른 쓰레드에게 양보
<div align="center">
<img src="https://github.com/user-attachments/assets/7f1d5812-8641-408a-bc8a-ebec4fb305f2">
</div>

   - 운영체제에 자신이 할당받은 CPU 시간을 포기하고 다른 쓰레드가 실행될 수 있도록 하는 yield() 기법이 있다고 가정
   - 하나의 쓰레드는 실행 중(Running), 준비(Ready), 막힘(Blocked) 이라는 세 가지 상태 존재
   - 양보(Yield)라는 시스템 콜은 호출 쓰레드 상태를 실행 중(Running) 상태에서 준비(Ready) 상태로 변환하여 다른 쓰레드가 실행 중 상태로 전이하도록 함
   - 결과적으로 양보 동작은 스케줄 대상에서 자신을 빼는 것 (Deschedule)

3. 단일 CPU 시스템에서 두 개의 쓰레드를 실행하는 예는 양보를 기반으로 한 기법은 잘 동작
   - 만약 쓰레드가 lock()을 호출하였지만 다른 쓰레드가 락을 보유한 상황이었다면, 이 쓰레드가 갖고 있던 CPU 시간을 단순히 양보하여 먼저 쓰레드가 동작하여 임계 영역 밖으로 나올 수 있도록 하는 것

4. 100개 정도의 쓰레드들이 락을 획득하기 위해 경쟁하는 경우
   - 한 쓰레드가 락을 획득하고 선점
   - 이 때 나머지 99개 쓰레드가 각자 lock()을 호출하고 다른 쓰레드가 락을 보유하고 있기에 CPU를 양보
   - 라운드 로빈(Round-Robin) 스케줄러를 사용하는 경우라면 락을 갖고 있는 쓰레드가 다시 실행되기까지 99개 쓰레드가 실행하고 양보하는(Run-And-Yield) 패턴으로 동작
   - 99개 시간 간격을 낭비하게 되는 회전 방식보다 좀 더 좋기하지만, 비용은 만만치 않음 (즉, 문맥 교환 비용이 상당하며 낭비가 많음)
   - 더 안 좋은 것은 굶주림 문제는 전혀 고려하지 않음
