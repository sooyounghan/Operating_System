-----
### 락 : 기본 개념
-----
1. 다음과 같은 임계 영역이 존재한다고 가정 (고전적인 공유 변수 갱신)
```c
balance = balance + 1;
```

2. 연결 리스트에 노드를 삽입한다거나 공유 구조에 복잡한 갱신과 같은 다른 임계 영역을 사용할 수 있지만, 간단한 예제를 사용할 예정
   - 락 사용을 위해 락으로 임계 영역을 다음과 같이 설정
```c
1 lock_t mutex; // 글로벌 변수로 선언된 락
2 ...
3 lock(&mutex);
4 balance = balance + 1;
5 unlock(&mutex);
```
   - 락은 하나의 변수이므로 떄문에 락을 사용하기 위해서는 락 변수를 먼저 선언해야 함(mutex)
   - 이 락 변수는(또는 짧게 락은) 락의 상태를 나타냄
     + 이 락은 사용 가능(Available) 상태이거나(해제(Unlocked) 또는 Free), 즉 어느 쓰레드도 락을 갖고 있지 않거나, 사용 중(Acquired), 즉 임계 영역에서 정확히 하나의 쓰레드가 락을 획득한 상태
     + 이 락 자료 구조에 락을 보유한 쓰레드에 대한 정보나 락을 대기하는 쓰레드들에 대한 정보를 저장할 수 있음
     + 물론, 이러한 정보는 락 사용자는 알 수 없음

3. lock()과 unlock() 루틴의 의미
   - lock() 루틴 호출을 통해 락 획득을 시도하며, 만약 어떤 쓰레드도 락을 갖고 있지 않으면 그 쓰레드는 락을 획득하여 임계 영역 내로 진입
   - 이렇게 진입한 쓰레드를 락 소유자(Owner)라고 부름
   - 만약 다른 쓰레드가 lock()을 호출한다면(이 예제에서는 mutex)에 해당 사용 중인 동안에는 lock() 함수가 리턴하지 않음
   - 이와 같은 방식으로 락을 보유한 쓰레드가 임계 영역에 진입한 상태에는 다른 쓰레드들이 임계 영역 안으로 진입할 수 없음
   - 락 소유자가 unlock()을 호출한다면 락은 이제 다시 사용 가능한 상태가 됨
   - 어떤 쓰레드도 이 락을 대기하고 있지 않았다면(어떤 쓰레드도 lock)을 호출하여 멈춰잇는 상태가 아니라면) 락의 상태는 사용 가능으로 유지
   - 만약에 대기 중이던 쓰레드가 있었다면(lock()으로 인해 멈춘), 락의 상태가 변경되었다는 것을 인지하고 (또는 정보를 받아) 락을 획득하여 임계 영역 내로 진입

4. 락은 프로그래머에게 스케줄링에 대한 최소한의 제어권을 제공
   - 일반적으로 쓰레드는 프로그래머가 생성하고 운영체제가 제어
   - 락은 쓰레드에 대한 제어권을 일부 이양받을 수 있도록 해주며, 락으로 코드를 감싸서 프로그래머는 그 코드내에서 하나의 쓰레드만 동작하도록 보장할 수 있음
   - 락을 통해 프로세스들의 혼란스런 실행 순서에 어느 정도 질서를 부여할 수 있음
