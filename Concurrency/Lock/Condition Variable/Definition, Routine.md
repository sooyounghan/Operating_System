-----
### 조건 변수의 정의와 루틴
-----
1. 조건이 참이 될 때까지 기다리기 위해 컨디션 변수(Condition Variable)를 활용 가능
2. 컨디션 일종의 큐 자료 구조로서, 어떤 실행의 상태(또는 어떤 조건)가 원하는 것과 다를 때 참이 되기를 기다리며 쓰레드가 대기할 수 있는 큐
   - 다른 쓰레드가 상태를 변경하였을 때, 대기 중이던 쓰레드(하나 이상의 쓰레드가 깨어날 수 있음)를 깨우고(조건에 따라 시그널을 보냄), 계속 진행할 수 있도록 함
   - 이 개념은 Dijkstra가 Private Semahore라는 개념을 사용했을 때부터 쓰였음

3. pthread_cond_t c; 와 같이 사용하여 c가 컨디션 변수가 되도록 선언 (적절한 초기화 과정이 필요 주의)
   - 컨디션 변수에는 wait()와 signal()이 존재
   - wait() : 쓰레드가 스스로 잠재우기 위해 호출
   - signal() : 쓰레드가 무엇인가 변경했을 때 조건이 참이 되길 기다리며 잠자고 있던 쓰레드를 깨울 때 호출
   - POSIX 사용 예
```
pthread_cond_wait(pthread_cond_t *c , pthread_mutex_t *m);
pthread_cond_signal(pthread_cond_t *c);
```

   - wait()는 mutex를 매개변수로 사용한다는 것
     + wait()가 호출될 때 mutex는 잠겨있다고 가정
     + 즉, wait()의 역할은 락을 해제하고 호출한 쓰레드를 재우는 것
     + 💡 어떤 다른 쓰레드가 시그널을 보내어 쓰레드가 꺠어나면, wait()에서 리턴하기 전 락을 재획득하여야 함
     + 💡 즉, wait()에서 리턴할 때 락을 재획득해야함 (즉, 조건이 만족되어 잠에서 깨어났더라도, 락을 획득 못하면 다시 Sleep 상태로 돌아감)
     + 이는 쓰레드가 스스로 재우려고 할 떄, 경쟁 조건 발생을 방지하기 위함

4. join() 문제의 해법
<div align="center">
<img src="https://github.com/user-attachments/assets/05209307-8480-4e8d-baad-d0796270188d">
</div>

   - 첫 번쨰 경우 : 부모 쓰레드가 자식 쓰레드를 생성 → 계속 실행하여 부모 쓰레드가 thr_join()을 호출하여 잠들고, 자식 쓰레드가 끝나기를 기다리는 경우
     + 부모 쓰레드가 락을 획득하고 자식이 끝났는지 검사 (즉, done = 1인지 확인)
     + 자식이 끝나지 않았으므로, wait()를 호출해 스스로 잠재움 (그리고, 자신의 락을 해제)
     + 자식 쓰레드가 추후에 실행되어 'child' 메세지를 출력하고, thr_exit()을 호출하여 부모 쓰레드를 깨움
     + 이 코드는 락을 획득한 후 상태 변수를 done으로 설정하고 부모 쓰레드에 시그널을 보내어 꺠어나도록 함
     + 마지막으로, 호출했던 wait()에서 락을 획득한 채로 리턴하여 부모 쓰레드가 실행될 것이고, 락을 해제하고 'parent : end' 메세지 출력

   - 두 번쨰 경우 : 자식 쓰레드가 생성되면서 즉시 실행 → done 변수를 1로 설정 → 자고 있는 쓰레드를 깨우기 위해 시그널을 보냄
     + 하지만 자고 있는 쓰레드가 없으므로 단순히 리턴 (아무것도 없으므로 헛 수고)
     + 그 후 부모 쓰레드가 실행되고 thr_join()을 호출하고 done 변수가 1인 것을 알게 됨
     + done이 1이므로 대기 없이 바로 리턴

   - 💡 부모 쓰레드가 조건을 검사할 때 (done 값) if문이 아닌 while문을 사용

5. 컨디션 변수의 필요성 (여기서는 done 변수)
<div align="center">
<img src="https://github.com/user-attachments/assets/25e486b3-af27-48e9-a7e7-31c82a8f331b">
</div>

   - 이 방법은 자식 쓰레드가 생성된 시점에 즉시 실행되어 thr_exit()를 호출하는 경우를 생각하면, 자식 프로세스는 시그널을 보내겠지만 깨워야 할 쓰레드가 없음
   - 부모 쓰레드가 실행되면 wait()를 호출하고 거기서 멈춰 있을 것
   - 즉, 어떤 쓰레드도 부모 쓰레드를 깨우지 않음
   - 따라서, 다른 쓰레드들이 알고자 하는 정보를 기록할 때는 done이라는 상태 변수가 필요함
   - 즉, 잠자고, 깨우고, 락을 설정하는 것이 done이라는 상태 변수 중심으로 구현

6. 시그널을 주거나 대기할 때 락을 획득할 필요가 없다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/3fbb8c31-4e58-4741-97ce-f393eb7362b7">
</div>

   - 경쟁 조건이 발생
   - 만약 부모 쓰레드가 thr_join()을 호출하고나서 done 변수의 값이 0인 것을 확인 후 잠자려고 하는데, wait() 호출 직전에 부모 쓰레드가 인터럽트에 걸려 자식 쓰레드가 실행이 되었다고 가정
   - 자식 쓰레드는 상태 변수 done 값을 1로 변경하고 시그널을 보냄
   - 하지만 대기 중인 쓰레드가 없음
   - 부모 쓰레드가 다시 실행되면 wait()를 호출하고 잠들게 됨
   - 문제는 잠든 부모 쓰레드를 깨워줄 쓰레드가 없음

7. 참고 : 시그널을 보내기 전 항상 락을 획득할 것
   - 모든 경우에 꼭 락을 획득할 필요가 없지만, 컨디션 변수를 사용할 때는 락을 획득한 후 시그널을 보내는 것이 가장 간단하고 최선의 방법
   - wait()를 호출할 때 락을 확득하는 것은 wait() 정의상 무조건 해야 함
     + wait()는 항상 wait()를 호출했을 때 락을 가지고 있다고 가정
     + 호출자를 잠들게 할 떄 락을 해제
     + 리턴하기 직전 락을 획득
