-----
### 생산자-소비자 문제(Producer-Consumer Problem, 유한 버퍼 문제(Bounded Buffer Problem))
-----
1. Dijkstra와 그의 동료들이 락이나 컨디션 변수를 대신하여 사용할 수 있는 일반 세마포어를 발견하게 된 이유
2. 여러 개의 생산자 쓰레드와 소비자 쓰레드가 있다고 가정
   - 생산자는 데이터를 만들어 버퍼에 넣음
   - 소비자는 버퍼에서 데이터를 꺼내어 사용
   - 이러한 관계는 실제 시스템에서 자주 사용 : 예를 들어, 멀티 쓰레드 웹 서버의 경우 생산자는 HTTP 요청을 작업 큐(즉, 유한 버퍼)에 넣고, 소비자 쓰레드는 이 큐에서 요청을 꺼내어 처리
   - 예) grep foo file.txt | wc -l과 같은 명령어
     + 파이프(Pipe) 명령으로 한 프로그램의 결과를 다른 프로그램에게 전달할 때 유한 버퍼 사용
     + 이 예제는 두 개의 프로세스가 병행 실행
     + grep 명령어 : file.txt에서 foo라는 문자열이 포함된 줄만 찾아 표준 출력(Standard Output, STDOUT)에 쓰며, UNIX 쉘은 출력 결과를 UNIX 파이프(시스템 콜인 파이프(Pipe)에 의해 생성)라는 곳으로 전송(Redirect)
     + 파이프의 한쪽 끝에는 wc 프로세스의 표준 입력과 연결되어 있으며, grep 프로세스가 생산자 / wc 프로세스가 소비자가 됨
     + 이 둘 사이에는 커널 내부에 있는 유한 버퍼가 있음

3. 유한 버퍼는 공유 자원이며, 경쟁 조건 발생을 방지하기 위한 동기화가 필요
4. 먼저, 생산자는 넣고 소비자는 꺼내어 쓸 수 있는 공유 버퍼 하나가 필요
   - 한 개의 정수를 사용(물론, 이곳에 다른 구조체를 가리키는 포인터를 넣을 수 있음)하고, 공유 버퍼에 값을 넣는 루틴과 값을 꺼내는 루틴 존재한다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/dbd1076e-807f-4279-abbd-86f7a3153fa9">
</div>

   - put() 루틴은 버퍼가 비어있다고 가정(assert()문으로 확인) : 값을 공유 버퍼에 넣은 후에 count를 1로 설정하여 가득찼다고 표시
   - get() 루틴은 그 반대로 동작하는데, 버퍼가 찼는지 확인 : 값을 꺼낸 후 버퍼가 비었다고 설정 (count를 0으로 설정) 한 뒤, 읽은 값을 리턴
   - 버퍼에 데이터를 넣거나 버퍼의 데이터를 꺼내도 괜찮은지 판단하는 루틴 : 버퍼의 count가 0이면(즉, 버퍼가 비어 있다면) 데이터를 넣고, count가 1일 때만(즉, 버퍼가 가득 찼을 때만) 버퍼에서 데이터를 꺼냄
   - 만약, 생산자가 가득 찬 버퍼에 데이터를 넣고, 소비자가 비어 있는 버퍼에서 데이터를 꺼내는 동기화 코드를 작성하면 잘못 작성한 것
   - 이 작업은 두 종류의 쓰레드에 의해 수행 : 하나는 생산자 쓰레드들, 하나는 소비자 쓰레드들
<div align="center">
<img src="https://github.com/user-attachments/assets/5da8478f-0188-48b2-9e41-e612867eb06a">
</div>

   - 생산자가 loop 횟수 만큼 공유 버퍼에 정수를 넣고, 소비자는 (무한히) 데이터를 공유 버퍼에서 꺼내는 코드를 나타냄
   - 소비자 쓰레드는 데이터를 공유 버퍼에서 꺼낼 때 그 값을 매번 출력 (하지만 이 코드는 제대로 동작하지 않음)

5. 불완전한 코드
   - 생산자와 소비자가 각 하나씩 있다고 가정
   - 당연히 put()과 get() 루틴에는 임계 영역이 있으며, put()은 버퍼를 갱신하고 get()은 버퍼에서 읽음
<div align="center">
<img src="https://github.com/user-attachments/assets/f11680f5-02df-42e8-938e-d720e8c60d3b">
</div>

  - cond 컨디션 변수 하나와 이와 연결된 mutex 락을 사용
  - 생산자와 소비자 사이에 시그널을 보내는 과정
    + 생산자는 버퍼가 비어있을 때까지 기다림 (p1 ~ p3)
    + 소비자도 버퍼가 차기를 기다림 (c1 ~ c3)

6. 두 개 이상의 같은 쓰레드가 존재할 경우 문제점 발생 : 첫 번째, 대기 명령 전 if문과 관련
  - $T_{c1}$, $T_{c2}$라는 두 개의 소비자가 있고, $T_{p}$라는 생산자가 하나 있다고 가정
    + 소비자 $T_{c1}$가 먼저 실행되어, 락(c1)을 획득하고 버퍼를 소비할 수 있는지 검사(c2)
    + 그리고 비어있음을 확인 후 대기하며(c3) 락 해제
    + 그리고 생산자 $T_{p}$가 실행되며, 락(p1) 획득 후 버퍼가 비어있는지 확인 (p2)
    + 비었음을 발견하고, 버퍼를 채움 (p4)
    + 생산자는 버퍼가 가득 찼다는 시그널을 보내고(p5), 대기 중인 첫째 소비자($T_{c1}$)가 깨어나 준비 큐(Ready Queue)로 이동
    + $T_{c1}$는 이제 실행할 수 있는 상태이지만 아직 실행 상태는 아니며, 생산자는 실행을 계속함
    + 버퍼가 차 있으므로 대기 상태로 전이 (p6, p1 ~ p3)

  - 다른 소비자 $T_{c2}$가 끼어들어서 실행하면서 버퍼 값을 소비 (c1, c2, c4, c5, c6 수행 / c3은 버퍼가 가득 찼으므로 건너뜀)
    + $T_{c1}$이 실행된다고 가정하면, 대기에서 리턴하기 전에 락을 획득
    + 그리고 get()을 호출했지만(c4), 버퍼는 비어있으므로, 코드가 의도한 대로 기능하지 못함

  - 즉, 생산자가 버퍼에 넣어둔 값을 $T_{c2}$가 끼어들어서 소비하였으므로 $T_{c1}$이 비어 있는 버퍼를 읽는 행위를 막아야함

  - 각 쓰레드의 동작과 스케줄러의 상태(준비 / 실행 / 대기)를 시간에 따라 상황정리
<div align="center">
<img src="https://github.com/user-attachments/assets/a734f1a5-77a0-49c6-9db0-13e9507861bd">
</div>

  - 문제의 원인은 $T_{c1}$이 깨어나서 실행되기까지 사이에 유한 버퍼 상태가 변경되었기 때문임
    + 시그널은 쓰레드를 꺠우기만 하며, 상태가 변경되었을 수 있다는 일종의 힌트에 불과
    + 깨어난 쓰레드가 실제 실행되는 시점에도 그 상태가 유지된다는 보장이 없음
    + 이런식으로 시그널을 정의하는 것을 Mesa Semantic이며, 이와 대비되는 개념을 Hoare Semantic이라고 함 (구현이 더 어려우나, 꺠어난 즉시 쓰레드가 실행되는 것을 보장)
    + 대부분의 시스템은 Mesa Semantic 채용

7. if문 대신 while문 사용
<div align="center">
<img src="https://github.com/user-attachments/assets/2f22070a-04f9-4dea-a6ca-251d68434c09">
</div>

   - 위 문제 해결 방법으로는 if문 대신 while문을 사용하면 됨
   - 소비자 $T_{c1}$이 깨어나서(락을 획득), 즉시 공유 변수 상태를 재확인(c2)
   - 만약 이 시점에 버퍼가 비어있다면, 소비자는 대기 상태로 돌아감(c3)
   - 생산자에서도 if문이 while문으로 변경(p2)
   - 💡 Mesa Semantic의 컨디션 변수에서 가장 기본적 법칙은 언제나 while문을 사용하는 것
     + 떄로는 조건을 재확인하지 않아도 되지만, 항상 검사하는 것이 안전

   - 조건 검사에 while문을 사용하는 것은 거짓으로 깨운 경우(Spurious Wakeup)에 대처할 수 있도롣 해줌 : 어떤 쓰레드 패키지는 구현상 문제로 하나의 시그널에 의해 두 개의 쓰레드가 깨어나는 것이 가능한데, 쓰레드가 조건을 재검사하는 이유는 바로 이러한 거짓으로 깨운 경우가 있기 때문임

8. 컨디션 변수가 하나뿐인 문제
<div align="center">
<img src="https://github.com/user-attachments/assets/47478a4f-1236-48b5-81d3-9260f41362ea">
</div>

   - 소비자 $T_{c1}$, $T_{c2}$가 먼저 실행한 후 둘 다 대기 상태에 있을 때 발생 (c3)
   - 생산자가 실행되어 버퍼에 값을 넣고 대기 중인 쓰레드 하나를 깨우고($T_{c1}$를 꺠웠다고 가정), 자신은 대기
   - 하나의 소비자($T_{c1}$)가 실행할 준비가 되었고 조건에 의해 $T_{c2}$와 $T_{p}$는 대기 중
   - 소비자 $T_{c1}$이 wait()에서 리턴을 받아 깨어나고(c3), 조건을 재확인(c2)
   - 버퍼가 차있다는 것을 발견하고 값을 소비(c4)
   - 이 소비자는 시그널을 전송(c5)하여 대기 중인 쓰레드 중 하나를 깨움
   - 이 때, 소비자가 버퍼를 비웠기 때문에 당연히 생산자를 깨우는 것이 맞지만, 만약 소비자가 $T_{c2}$를 깨운다면(대기 큐 관리 방법에 따라 당연히 발생 가능) 문제가 발생
   - 소비자 $T_{c2}$가 꺠어나면 버퍼가 비어있다는 것을 발견 후(c2) 다시 대기 상태로 진입(c3)
   - 버퍼에 값을 넣어야 하는 생산자 $T_{p}$는 대기 중이며, 다른 쓰레드 $T_{c1}$ 역시 대기 상태로 진입
   - 세 개의 쓰레드가 모두 대기중인 상태
   - 시그널을 보내는 것은 꼭 필요하지만, 대상이 명확해야 하며, 소비자는 다른 소비자를 깨울 수 없고 생산자만 깨워야 하며, 반대로 생산자 경우도 마찬가지

9. 단일 버퍼 생산자 / 소비자 해법
    - 두 개의 컨디션 변수를 사용해 시스템 상태가 변경되었을 때 깨워야 하는 쓰레드에게만 시그널을 제대로 전달해야 함
<div align="center">
<img src="https://github.com/user-attachments/assets/c1aa3e34-6333-4de3-b335-fed9e852beb2">
</div>

   - 생산자 쓰레드가 empty 조건 변수에서 대기하고 fill에 대해서 시그널을 발생
   - 정반대로 소비자 쓰레드는 fill에 대해서 대기하고 empty에 대해서 시그널을 발생
   - 그렇게 함으로써, 두 번쨰 문제가 발생하는 것을 피함
   - 소비자가 실수로 다른 소비자를 절대로 깨울 수 없도록 하고, 생산자도 다른 생산자를 꺠우는 일이 없도록 함

10. 최종적인 생산자 / 소비자 해법
   - 버퍼 공간을 추가하여 대기 상태에 들어가기 전 여러 값들이 생산될 수 있도록 하는 것, 그리고 마찬가지로 여러 개의 값이 대기 상태 전에 소비될 수 있도록 하는 것
   - 하나의 생산자와 소비자의 경우 버퍼가 커지면 쓰레드 간 문맥 교환이 줄어드므로 더 효율적이 됨
   - 멀티 생산자의 경우 또는 멀티 소비자의 경우 (또는 둘 다)가 되면 생산과 소비가 병행이 될 수 있으므로 병행성이 좋아짐
   - 첫 번째 : 버퍼 구조, put(), get()을 변경 (생산자와 소비자가 대기 상태에 되는지에 대한 여부를 결정하는 조건도 변경)
<div align="center">
<img src="https://github.com/user-attachments/assets/807523af-91cf-40db-9ead-fdc9cd19b1af">
</div>

   - 두 번째 : 최종적 대기와 시그널에 대한 논리
<div align="center">
<img src="https://github.com/user-attachments/assets/d72fa456-5efb-4db6-bff9-5a886eec63b5">
</div>

   - 생산자는 모든 버퍼가 현재 가득차있다면 대기 상태에 들어가고(p2), 마찬가지로 소비자도 모든 버퍼가 비어있다면 대기에 들어감(c2)
