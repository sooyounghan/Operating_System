-----
### 병행 연결 리스트
-----
1. 기본 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/6c060b85-5a10-416f-859d-237c6b7cd4ea">
</div>

   - 삽입 연산을 시작하기 전 락을 획득하고 리턴 직전에 해제

2. 삽입 연산이 병행하여 진행되는 상황에서 실패를 하더라도 락 해제를 호출하지 않으면서 삽입과 검색이 올바르게 동작하는 방법
   - 삽입 코드에서 임계 영역을 처리하는 부분만 락으로 감싸도록 코드 순서를 변경하고, 검색 코드의 종료는 검색과 삽입 모두 동일한 코드 패스 사용
   - 이유는 검색 코드의 일부는 사실 락이 필요 없음 : malloc() 자체가 쓰레드 안전하다면 쓰레드는 언제든지 경쟁 조건과 다른 병행성 관련 버그를 걱정하지 않으면서 검색 가능
   - 공유 리스트 갱신때만 락을 획득하면 됨
<div align="center">
<img src="https://github.com/user-attachments/assets/fbfd8282-85c4-4e05-813f-b8579feae3eb">
</div>

   - 검색 루틴의 while문 안에 break를 삽입하여 검색이 성공하면 바로 빠져나오게 수정
   - 이렇게 하면 검색 성공이나 실패의 경우 모두 동일 리턴 코드 실행

3. 확장성 있는 연결 리스트
   - 병행이 가능한 연결 리스트를 갖게 되었지만, 확장성이 좋지 않다는 문제 발생
   - 개선 방법 중 하나 : Hand-Over-Hand Locking(Lock Coupling)
     + 전체 리스트에 하나의 락이 있는 것이 아니라 개별 노드마다 락을 추가하는 것
     + 리스트를 순회할 때 다음 노드의 락을 먼저 획득하고 지금 노드의 락을 해제하도록 함
     + 개념적으로는, 리스트 연산에 병행성이 높아지므로 괜찮은 것처럼 보이지만, 실제로는 간단한 락 방법(락 하나를 두는)에 비해 속도 개선을 기대하기가 쉽지 않음
     + 리스트를 순회할 때 각 노드에 락을 획득하고 해제하는 오버헤드가 매우 크기 때문임
     + 아주 큰 리스트를 굉장히 많은 수의 쓰레드가 병행적으로 순회하더라도, 락을 하나만 사용하는 것보다 빠르기 어려움
     + 차라리 일정 개수의 노드를 처리할 때마다 하나의 새로운 락을 획득하는 방법이 더 괜찮을 수 있음

4. 참고 : 병행성이 늘어난다고 더 빠른 것은 아님
   - 락 획득 / 해제와 같이 부하가 큰 연산을 추가하여 자료 구조를 설계했다면, 병행성 자체가 좋아졌다는 것은 큰 의미가 없음
   - 오히려 부하가 큰 루틴은 사용하지 않는 간단한 방법이 좋음
   - 락을 많이 추가하고 복잡도가 증하가하면 큰 단점이 됨
