-----
### 병행 카운터
-----
1. 카운터는 가장 간단한 자료 구조 중 하나이며, 보편적으로 사용되는 구조이면서 인터페이스가 간단
2. 병행이 불가능한 카운터와 병행이 가능한 카운터
<div align="center">
<img src="https://github.com/user-attachments/assets/fce8f3c8-6117-4bfd-a7af-f288e9ecd16d">
</div>

   - 간단하지만 확장성이 없음
     + 동기화되지 않은 카운터는 평범한 자료 구조

<div align="center">
<img src="https://github.com/user-attachments/assets/90ac9729-c515-4863-a0c7-aa4c9ae4fcca">
</div>

   - 병행이 가능한 카운터는 간단하지만 정확하게 동작하며, 가장 간단하고 기본적인 병행 자료 구조의 보편적 디자인 패턴을 따름
     + 자료 구조를 조작하는 루틴을 호출할 때, 락을 추가하였고, 그 호출문이 리턴될 때 락이 해제되도록 함
     + 이 방식은 모니터(Monitor)를 사용하여 만든 자료 구조와 유사 : 모니터 기법은 객체에 대한 메소드를 호출하고 리턴할 때 자동적으로 락을 획득하고 해제

   - 성능 확인
     + 각 쓰레드가 특정 횟수만큼 공유 카운터를 증가시키는 벤치마크 실행 및 쓰레드 개수를 증가
     + 하나에서 네 개의 쓰레드를 사용하여 카운터를 백만 번 증가시켰을 때 총 걸린 시간 : 더 많은 CPU가 동작할 수록 단위 시간 당 총 수행량이 늘어날 것으로 기대
<div align="center">
<img src="https://github.com/user-attachments/assets/349c38a0-b05f-4b8c-b576-42df7878978b">
</div>

   - 범례에 precise 표시된 선에서 동기화된 카운터의 확장성이 떨어지는 것을 볼 수 있음
   - 단일 쓰레드로 카운터를 백만 번 갱신하는데 대략 0.03초가 걸렸으며, 두 개의 쓰레드로 카운트 값을 백만 번 갱신하는데 약 5초 이상 걸림
   - 이상적으로는 하나의 쓰레드가 하나의 CPU에서 작업을 끝내는 것처럼 멀티프로세서에서 실행되는 쓰레드들도 빠르게 작업을 처리하고 싶을 것 : 이와 같이 동작하는 것을 완벽한 확장성(Perfect Scaling)이라고 함
     + 완벽한 확장성은 더 많은 작업을 처리하더라도 각 작업이 병렬적으로 처리되어 완료 시간이 늘어나지 않는다는 것을 말함

3. 확장성 있는 카운팅
   - 확장 가능한 카운터가 없으면 Linux의 몇몇 작업은 멀티코어 기기에서 심각한 확장성 문제를 겪을 수 있음
   - 엉성한 카운터(Sloppy Counter) 기법
     + 하나의 논리적 카운터로 표현되는데, CPU 코어마다 존재하는 하나의 물리적 지역 카운터와 하나의 전역 카운터로 구성
     + 어떤 기기가 네 개의 CPU를 갖고 있다면, 그 시스템은 네 개의 지역 카운터와 하나의 전역 카운터를 갖고 있음
     + 이 카운터들 외에 지역 카운터를 위한 락들과 전역 카운터들 사이에 락이 존재

   - 엉성한 카운터의 기본 개념
     + 쓰레드는 지역 카운터를 증가시킴
     + 이 지역 카운터는 지역 락에 의해 보호되며, 각 CPU는 저마다 지역 카운터를 가지므로 CPU들에 분산되어 있는 쓰레드들은 지역 카운터를 경쟁 없이 갱신 가능할 수 있으므로, 카운터 갱신은 확장성이 있음
     + 쓰레드가 카운터의 값을 읽을 수 있으므로 전역 카운터를 최신으로 갱신해야 함
     + 최신 값으로 갱신하기 위헤서는 지역 카운터의 값은 주기적으로 전역 카운터로 전달되는데, 이 때 전역 락을 사용하여 지역 카운터의 값을 전역 카운터 값에 더하고, 그 지역 카운터 값은 0으로 초기화
     + 지역에서 전역으로 값을 전달하는 빈도는 정해 놓은 S(Sloppiness) 값에 의해 결정 : S의 값이 작을수록 확장성이 없는 카운터처럼 동작하며, 커질수록 전역 카운터의 값은 실제 값과 차이가 있게 됨
       * 정확한 카운터 값을 얻기 위해 모든 지역 락과 전역 락을 획득한 후 계산하면 되지만 확장성이 없게 됨
       * 이 경우에, 지역 락을 획득하는 순서를 적절히 제어하지 않으면 교착 상태 발생

     + 예제
<div align="center">
<img src="https://github.com/user-attachments/assets/6994fe1d-833d-4308-ae1b-90c319869144">
</div>

   - 한계치를 5로 설정하였고, 네 개의 CPU에 각각 지역 카운터 $L_{1}, ..., L_{4}$를 갱신하는 쓰레드 존재
   - 전역 카운터의 값(G)도 같이 나타나있으며, 만약 지역 카운터 한계치 S에 도달하면 지역 값은 전역 카운터에 반영되고, 지역 카운터의 값은 초기화

<div align="center">
<img src="https://github.com/user-attachments/assets/349c38a0-b05f-4b8c-b576-42df7878978b">
</div>

   - 위 그림에서 범례에 Sloppy라고 적힌 아래 선이 S 값을 1024로 했을 때 엉성한 카운터의 성능으로 탁월한 성능을 보여줌
   - 네 개의 프로세서에서 카운터 값을 4백만 번 갱신하는데 걸린 시간이 하나의 프로세서에서 백만 번 갱신하는 시간에 비해 그리 크지 않음


   - 4개의 CPU에서 4개의 쓰레드가 각각 백만 번 카운터의 값을 증가하는 경우 한계치 S의 설정이 중요한지 보여주는 그래프
<div align="center">
<img src="https://github.com/user-attachments/assets/c19a9628-a5d1-4d59-b14b-0092ee017c42">
</div>

   - S의 값이 낮다면 성능이 낮은 대신 전역 카운터 값이 매우 정확해짐
   - S의 값이 매우 크다면 성능은 탁월해지지만, 전역 카운터 값은 CPU 개수의 S의 곱 만큼 뒤쳐지게 됨
   - 엉성한 카운터는 정확도와 성능의 균형을 조절할 수 있음

4. 엉성한 카운터의 대략적인 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/143ab96b-3b23-4b1e-90af-5d9f07bcbedd">
</div>
