-----
### 인터럽트 제어
-----
1. 초창기 단일 프로세스 시스템에서는 상호 배제 지원을 위해 임계 영역 내 인터럽트를 비활성화하는 방법 사용
```c
1 void lock() {
2 DisableInterrupts();
3 }
4 void unlock() {
5 EnableInterrupts();
6 }
```
  - 임계 영역에 진입하기 전 특별한 하드웨어 명령어를 사용하여 인터럽트를 막는다면 임계 영역 내 코드에서는 인터럽트가 발생할 수 없으므로 원자적 실행 가능
  - 모든 동작이 끝난 후에 다시 하드웨어 명령어를 사용하여 인터럽트를 사용 가능하도록 하여 프로그램이 이전처럼 진행할 수 있도록 함

2. 장점
   - 단순함 : 인터럽트가 발생하지 않으면, 코드가 실행 중 다른 쓰레드가 중간에 끼어들지 않는다는 것을 보장할 수 있음

3. 단점
   - 이 요청을 하는 쓰레드가 인터럽트를 활성 / 비활성화하는 특권(Privilged) 연산을 실행할 수 있도록 허가해야 함
   - 또, 이를 다른 목적으로 사용하지 않음을 신뢰할 수 있어야 함
     + 탐욕적(Greedy) 기법을 사용한 프로그램이 시작과 동시에 lock()을 호출하여 프로세서를 독점하여 사용할 수 있음
     + 오류가 있거나 악의적인 프로그램이 lock()을 호출하고 무한 반복문에 들어갈 수 있음 (이런 경우, 운영체제는 시스템 제어권을 다시 얻을 수 없음)
     + 동기화를 위해 인터럽트를 비활성화 시키는 방법은 응용 프로그램을 너무 많이 신뢰해야 한다는 문제 존재

   - 멀티프로세서에서는 적용할 수 없음
     + 여러 쓰레드가 여러 CPU에서 실행 중이라면 각 쓰레드가 동일한 임계 영역을 진입하려고 시도할 수 있음
     + 이 때 특정 프로세서에서의 인터럽트 비활성화는 다른 프로세서에서 실행 중인 프로그램에는 전혀 영향을 주지 않음
     + 결과적으로는 임계 영역에 진입할 수 있다는 의미이므로, 해결법이 더 정교해야 함

   - 장시간 동안 인터럽트를 중지시키는 것은 중요 인터럽트 시점을 놓칠 수 있음
     + 이는 시스템에 심각한 문제를 가져올 수 있음

   - 비효율적
     + 일반적인 명령어 실행에 비해 인터럽트를 비호라성화시키는 코드들은 최신의 CPU들에서는 느리게 실행되는 경향 존재

4. 따라서, 상호 배제를 위해 비활성화하는 것은 제한된 범위에서 사용되어야 함
   - 예를 들어, 운영체제가 내부 자료 구조에 대한 원자적 연산을 위해 인터럽트를 비활성화할 수 있음
   - 또는, 적어도 복잡하게 보이는 인터럽트 발생을 방지하기 위해 운영체제가 인터럽트를 비활성화할 수 있음
   - 운영체제 내부에서는 신뢰라는 문제가 사라지기 때문에 운영체제가 특혜 받은 동작을 어떤 방식으로 처리하든 인터럽트를 비활성화하더라도 용인 가능

-----
### Dekker와 Peterson의 알고리즘
-----
1. Dekker의 알고리즘은 load와 store 명령어만을 사용해 원자적으로 동작하도록 가정 (실제 초창기 하드웨어에서는 이 명령어들이 원자적 동작)
2. Dekker의 알고리즘은 Peterson에 의해 개선 : load와 store가 동일하게 사용되었으나, 임계 영역에 두 개의 쓰레드가 절대로 동시에 들어가지 못하도록 보장하는 개념 추가
   - 두 개의 쓰레드를 위한 Peterson의 알고리즘
```c
1 int flag[2];
2 int turn;
3
4 void init() {
5     flag[0] = flag[1] = 0; // 1 -> 쓰레드가 락을 획득하길 원함
6     turn = 0; // 누구 차례? (쓰레드 0 또는 1)
7 }
8 void lock() {
9     flag[self] = 1; // self : 호출한 쓰레드의 ID
10     turn = 1 − self; // 다른 쓰레드 차례가 되도록 만듦
11     while ((flag[1−self] == 1) && (turn == 1 − self))
12         ; // 회전
13 }
14 void unlock() {
15     flag[self] = 0; // 원래 의도를 취소
16 }
```
