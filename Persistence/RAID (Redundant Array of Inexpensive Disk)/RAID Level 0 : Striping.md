-----
### RAID 레벨 0 : 스트라이핑
-----
1. 첫 번째 RAID 레벨은 사실 중복 저장을 하지 않으므로, RAID 레벨이 결코 아니지만, RAID 레벨 0 또는 스트라이핑(Striping)이라고 알려진 방식은 성능과 용량에 대한 훌륭한 상한 기준을 나타냄
2. 가장 간단한 스트라이핑 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/7226995d-58f6-43f7-832f-26ab333adb91">
</div>

  - 네 개의 디스크 배열을 사용한다고 가정
  - 디스크 배열의 블럭들을 라운드 로빈 방식으로 디스크를 가로질러 펼침 : 이 접근법은 배열의 연속적인 청크(예) 크기가 큰 순차 읽기처럼)에 대해 요청을 받았을 때 병렬성을 가장 잘 활용할 수 있도록 설계
  - 같은 행에 있는 블럭들을 스트라이프(Stripe)라고 부름 : 따라서 블럭 0, 1, 2 그리고 3은 같은 스트라이프에 존재
  - 단순하게 하나의 블럭(4KB 단위의 크기)만이 다음 디스크로 넘어가기 전에 현재 디스크에 배치된다고 가정

3. 각 디스크마다 두 개의 4KB 블럭을 배치한 후 다음 디스크로 넘어가는 예
<div align="center">
<img src="https://github.com/user-attachments/assets/0918ba90-119b-4d81-a155-7e1b95d4fbb3">
</div>

   - RAID 배열의 청크는 8KB이며, 스트라이프는 4개의 청크 또는 32 KB 크기의 데이터를 저장

4. 청크 크기
   - 청크 크기는 RAID 성능에 큰 영향을 줌
   - 작은 청크 크기가 의미하는 것은 많은 파일들이 여러 디스크에 걸쳐서 스트라이프된다는 말이며, 하나의 파일을 읽고 쓰는데 병렬성이 증가
     + 💡 하지만, 블럭의 위치를 여러 디스크에서 찾아야 하므로 위치 찾기 시간이 늘어남 : 요청 처리 시간은 여러 디스크에 걸친 요청들 중 가장 오래걸린 찾기 시간에 의해 결정
   - 반면, 큰 청크 크기의 경우 파일 내 병렬성은 줄어들고 따라서 높은 처리 성능을 얻으려면 여러 요청을 병행하게 실행해야 함
     + 하지만 큰 청크 크기의 경우 위치 찾기 시간이 줄어듬
     + 예를 들어, 파일이 작아서 단일 청크에 저장이 된다면, 이 파일을 읽는데 요구되는 위치 찾기 시간은 한 디스크에서 그 위치를 찾는 시간과 동일하게 됨

   - 최적의 청크 크기를 정하는 것은 디스크 시스템이 처리할 워크로드에 대한 심도 있는 이해를 필요로 함

5. RAID-0 분석
   - 스트라이프 방식의 용량 측면에서는 완벽 : N개의 디스크에서 스트라이핑은 N * B개의 디스크 용량만큼 유효 용량을 가짐
   - 신뢰성 측면 : 나쁜 의미로 완벽 (어느 디스크라도 고장나면 전체 데이터 손실)
   - 성능 : 훌륭함 (병렬로 사용자의 I/O 요청을 처리할 수 있으므로 모든 디스크가 활용)

6. RAID 성능 평가
   - 두 가지 다른 성능 척도 : 단일 요청의 지연 시간과 RAID 정상 상태(Steady State)에서의 처리 성능(Throughput)
   - 단일 요청의 지연 시간
     + 하나의 I/O를 처리하는 데 걸리는 RAID의 지연 시간에 대한 이해는 한 번의 놀리적 I/O 동작을 처리할 때 병렬성 정도를 파악하는데 도움

   - RAID 정상 상태(Steady State)에서의 처리 성능(Throughput)
     + 고성능을 요하는 환경에서 RAID가 주로 사용되므로 안정(Stable) 상태에서 대역폭은 매우 중요하며 분석의 주요 초점

   - 순차와 랜덤 워크로드 두 가지 유형이 있다고 가정
     + 순차 워크로드에서는 연속된 큰 청크의 형태로 RAID에 요청
       * 예를 들어, 1MB의 데이터를 접근하는 요청(또는 연속적인 요청들)이 블럭 B에서 시작하여 B + 1MB에서 끝난다면 순차적이라고 봄
       * 여러 환경에서 순차 워크로드는 (큰 파일에서 키워드를 찾는 경우처럼) 흔히 발생하므로 중요하게 생각

     + 랜덤 워크로드는 크기가 작은 요청이며 또한 디스크의 여러 불특정 위치를 접근한다고 가정
       * 예를 들면, 논리 주소 10에서 첫 번쨰 4KB에 접근하고 다음으로 논리 주소 550,000 그리고 20, 100 등의 위치로 이동하여 접근하는 경우
       * 데이터베이스 시스템의 트랜잭션과 같은 일부 중요한 워크로드는 이와 같은 접근 패턴을 보이므로 중요 워크로드로 여김

     + 물론 실제 워크로드는 그렇게 단순하지 않으며, 순차와 랜덤 성질이 섞여있으므로 특성도 어중간하게 나타남
     + 순차와 랜덤 워크로드는 디스크로부터 큰 성능 차이를 만들어냄
     + 순차 접근의 경우 디스크가 가장 효율적으로 동작 : 탐색과 회전 지연이 짧아 대부분의 시간을 데이터 전송에 사용
     + 랜덤 접근의 경우 그 반대 : 대부분의 시간을 탐색과 회전을 기다리는 데 사용되고 상대적으로 적은 시간이 데이터 전송에 사용
     + 분석에서 그 차이를 나타내기 위해 디스크가 순차 워크로드 일 경우 S MB/s, 랜덤 워크로드에서는 R MB/s의 속도로 전송한다고 가정 (일반적으로는 S가 R보다 매우 큼 (S ≥ R)

   - 예제 : 평균적으로 10MB 크기를 순차적으로 전송하고, 평균적으로 10 KB의 크기를 임의의 방식으로 전송한다고 가정
   - 디스크의 특성은 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/73ef96ea-1b83-4e05-aa34-7de68324781b">
</div>

   - S를 계산하기 위해 10MB를 전송하는 데 걸리는 시간 : 탐색에 7ms, 회전에 3ms 사용
     + 마침내 전송이 시작되면 10 MB / 50 MB/s = 1 / 5 초 = 200 ms가 전송에 소요
     + 그러므로, 10MB마다 전송을 완료하는데 210(200 + 10 ms)이 걸리므로, S는 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/136938cb-6e05-4e92-b3c0-510347fd5c42">
</div>

   - 보는 바와 같이 데이터 전송하는데 많은 시간을 쓰므로 S의 값은 디스크의 최대 대역폭에 근접 (탐색과 지연 시간 비용은 전체 시간이 길어짐에 따라 영향이 줄어듬)
   - R도 비슷하게 계산 가능 : 탐색과 회전 지연은 동일하며, 전송하는 데 걸리는 시간을 계산하면 10 KB / 50 MB/s = 0.195 ms가 걸림
<div align="center">
<img src="https://github.com/user-attachments/assets/acc1d135-313c-4841-b60b-9bf7daba537a">
</div>

   - 보는 바와 같이 R은 1 MB 이하이며, S / R은 거의 50

7. RAID-O 분석
   - 단순 스트라이핑의 성능 : 전반적으로 괜찮음
   - 예를 들어, 지연 시간 측면에서 한 블럭에 대한 요청의 지연 시간은 하나의 디스크에 대한 요청의 지연 시간과 거의 동일
   - 결국, RAID-0은 받은 요청을 디스크 중 하나에게 전달되는 것 뿐이기 때문임
   - 정상 상태에서의 대역폭 측면에서 시스템 최대 대역폭을 기대할 수 있음
   - 그러므로 처리 성능은 N(디스크 수) * S(디스크 하나의 순차 접근 대역폭)와 같음
   - 랜덤 I/O의 경우에도 모든 디스크를 사용할 수 있으므로 N * B MB/s를 얻을 수 있음
   - 즉, 다른 RAID 레벨들과 비교할 때 상한치로 사용될 수 있음

-----
### RAID 매핑 문제
-----
1. 모든 RAID 배열에 대해 논리 블럭에 대한 읽기와 쓰기를 할 때 RAID는 어떻게 해당 물리 디스크와 오프셋을 정확하게 그 위치에 접근 시킬 수 있는가?
2. 간단한 RAID 레벨의 경우에는 물리 위치와 논리 블럭을 정확하게 연결하기 위해 다음과 같이 계산
   - 첫 번쨰 스트라이핑 예제(청크 크기 = 1 블럭 = 4KB)로 가정
   - 논리 블럭 주소가 A라고 할 때 RAID는 다음과 같은 수식으로 원하는 디스크와 오프셋 계산 가능
<div align="center">
<img src="https://github.com/user-attachments/assets/0b32a83d-f02a-4f82-86ca-a7688bd23703">
</div>

   - 💡 이 계산은 정수 계산이라는 것에 유의

3. 첫 번쨰 RAID의 경우 14번 블럭에 대한 요청을 받았다고 가정
   - 네 개의 디스크가 있다고 가정
   - 디스크 : 14 % 4 = 2로, 디스크 2번 (디스크는 0부터 시작하여 디스크 2번)으로 세 번쨰 디스크
   - 블럭 : 14 / 4 = 3로, 3번 블럭
   - 즉, 2번 디스크와 3번 블럭으로 계산되어 실제 그곳에 있는 것 확인 가능
