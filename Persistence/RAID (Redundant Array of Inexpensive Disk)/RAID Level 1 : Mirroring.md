-----
### RAID 레벨 1 : 미러링
-----
1. 스트라이핑 이후 첫 번째 RAID 레벨은 RAID 레벨 1 또는 미러링
2. 미러링을 사용하는 시스템에서는 각 블럭에 대해 하나 이상 사본을 둠
   - 각 사본은 당연히 서로 다른 디스크에 저장됨으로써 디스크 고장에 대처할 수 있음
   - 일반적인 미러링 시스템에서 RAID는 각 논리 블럭에 대해 두 개의 물리적 사본을 둔다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/ddd53a63-3e10-407d-9c60-4a8f63e0353b">
</div>

   - 디스크 0과 디스크 1이 동일한 값을 갖고 디스크 2와 디스크 3이 동일한 값을 가짐
   - 데이터는 미러링된 쌍들에 대해 스트라이핑을 적용
   - 위에서 보인 방식은 일반적인 방법으로 RAID-10 또는 RAID-1+0이라고 불림
     + 미러링(RAID-1)을 적용한 것을 스트라이핑(RAID-0)하기 때문임

   - 또 다른 구성은 RAID-01 또는 RAID-0+1로서 배열을 RAID-0으로 스트라이핑 한 후 이 배열을 RAID-1으로 미러링 하는 방식

3. 미러링된 배열에서 블럭을 읽을 때는 RAID는 원본을 읽을 것인지, 사본을 읽을 것인지 선택 가능
   - 예를 들면, 논리 블럭 5번을 RAID에서 읽도록 요청하면 디스크 2에서 또는 디스크 3에서 읽을 수 있음
   - 반면에 블럭을 쓰는 경우 그렇게 선택 불가 : RAID는 신뢰성을 유지하므로 두 범위 데이터를 모두 갱신해야 함
   - 단, 이러한 쓰기 요청은 병렬적으로 처리될 수 있음 (예를 들어, 논리 블럭 5번에 쓰는 요청은 디스크 2와 3에서 동시에 처리될 수 있음)

4. RAID-1 분석
   - 용량 측면 : RAID-1은 비용이 많이듬
     + 미러링 레벨이 2라면 최대 사용 가능한 용량의 반만 사용 가능 : 그러므로 B개의 블럭을 가진 N개의 디스크 배열의 유효 용량은 (N * B) / 2

   - 신뢰성 측면 : 괜찮음
     + 디스크 중 어느 것에서 고장이 발생하여도 감내 가능
     + 위 그림에서 디스크 0과 디스크 2에서 모두 고장이 발생했다고 가정 : 데이터를 잃어버리지 않음
     + 일반적으로 미러링 시스템(미러링 레벨 2)의 경우 한 개의 디스크 고장은 확실히 감내 가능하며, 어떤 디스크가 고장났느냐에 따라 N/2개의 결함까지 감내 가능

   - 성능 측면 : 단일 읽기 요청의 지연 시간은 단일 디스크에서 읽는 경우와 지연 시간이 동일
     + RAID-1이 하는 일은 두 벌의 사본 중 하나의 디스크로 요청을 전달하는 것이기 때문임
     + 쓰기의 경우에는 쓰기 요청이 완료하기 위해서 두 개의 디스크로 전달된 쓰기가 모두 종료되어야 함
     + 이 두개의 쓰기는 병렬적으로 이루어져야 하므로 하나의 쓰기에 소요되는 시간과 거의 동일할 것
     + 하지만 RAID-1에 요청된 쓰기는 물리적으로 두 개의 쓰기 연산이 종료될 떄까지 대기해야 하므로, 그 지연 시간은 두 개의 요청 중 최악의 탐색과 회전 지연 시간에 의해 결정
     + 평균적으로 하나의 디스크에 쓰는 시간보다는 조금 더 길어짐

   - 순차 워크로드로 정상 상태의 처리성능에 대한 분석
     + 디스크에 순차적으로 쓰기를 할 때 각 논리 쓰기는 항상 두 번의 물리 쓰기가 필요
     + 예를 들어, 논리 블럭 0번에 쓴다고 할 때, RAID는 내부에서 디스크 0번과 디스크 1번에 모두 기록해야 하므로, 미러링된 배열에 순차 쓰기를 하는 경우 ($\frac{N}{2}$ * $S$) 또는 최대 대역폭의 절반의 대역폭을 얻을 수 있음
     + 순차 읽기 상황에서도 동일한 성능을 얻음
       * 순차 읽기의 경우에 두 벌의 사본 중 하나만 읽으면 되므로 좀 더 잘할 수 있을 것 같으나 실제로는 아님
       * 예를 들어, 읽어야 할 블럭이 0, 1, 2, 3, 4, 5, 6, 7번이라고 가정할 때, 0번은 디스크 0번에서 읽고, 1번 블럭은 디스크 2번에서, 그리고 2번 블럭은 디스크 1번에서, 3번 블럭은 디스크 3번에서 읽도록 명령하면, 모든 디스크를 다 사용할 수 있으므로 배열의 전체 대역폭을 얻을 수 있다고 생각할 수 있음
       * 하지만, 하나의 디스크(0번)가 받는 요청을 살펴보면, 먼저 0번에 대한 요청을 받고, 두 블럭 떨어진 위치의 블럭 4번에 대한 요청을 받을 경우(2번 블럭을 건너뜀), 각 디스크는 하나씩 건너 뛴 블럭에 대한 요청을 받음
       * 건너 뛴 블럭 위를 회전하는 동안 사용자에게 유용한 대역폭이 제공되지 않으며, 그러므로 각 디스크 자신이 낼 수 있는 최대 대역폭의 반만 쓸 수 있으므로, 순차 읽기 대역폭도 ($\frac{N}{2}$ * $S$) MB/s

   - 랜덤 읽기가 미러링된 RAID에서는 최고의 워크로드
     + 모든 디스크에 읽기를 다 요청할 수 있기 떄문에 얻을 수 있는 최대 대역폭을 얻을 수 있음
     + 그러므로 랜덤 읽기의 경우 RAID-1은 N * R MB/s를 보임
     + 랜덤 쓰기의 경우에는 ($\frac{N}{2}$ * $R$) MB/s를 가짐 : 각 논리 쓰기는 두 번의 물리 쓰기로 바뀌어야 하므로 모든 디스크가 사용되더라도 사용자는 모든 대역폭의 반만 얻을 수 있음
     + 논리 블럭 x에 대해 두 개의 다른 물리 디스크로 나뉘어서 쓰기가 진행된다 하더라도 작은 크기의 쓰기 요청에 대한 대역폭은 스트라이핑의 경우 절반만 얻을 수 있음

5. RAID의 일관성 있는 갱신 문제
   - 쓰기 요청으로 인한 하나의 논리 작업을 위해 여러 개 디스크를 갱신해야 하는 모든 RAID에서 일어날 수 있음
   - 미러링된 디스크 배열을 가정
   - RAID에 쓰기가 요청되고 RAID는 디스크 0번과 1번에 기록된다고 가정
     + RAID는 디스크 0에 쓰기를 요청하고나서 디스크 1번에 요청하기 직전 전력 손실(또는 시스템 멈춤)이 발생했을 경우, 디스크 0의 요청은 완료가 되었다고 가정 (디스크 1번 요청은 요청조차 없었으므로, 갱신하지 않았음)
     + 따라서, 두 벌의 블럭 내용이 불일치 상태가 되며, 디스크 0번의 사본은 새 버전이며, 디스크 1번의 사본은 예전 것
     + 따라서 두 디스크에 대한 상태 갱신이 원자적으로 수행되어야 함
     + 즉, 두 디스크 값이 모두 새로운 값으로 변경되거나 아무것도 변경되지 않아야 함
     + 이 문제를 해결하는 일반적인 방법 : Write-Ahead 로그의 일종으로 RAID가 수행하려는 동작(즉, 특정 값으로 두 디스크 갱신)을 먼저 기록한 후 실제 동작을 수행하는 것
       * 이러한 접근법을 사용하면 시스템이 크러쉬되더라도 제대로 된 결과를 얻을 수 있도록 보장
       * RAID에 대기 중 모든 트랜잭션을 재실행하는 복구 절차를 수행하여 어떤 두 벌의 사본(RAID-1의 경우)도 일치한다는 것을 보장할 수 없음
     + 모든 쓰기에 대해 디스크로 로깅하는 것은 비용이 비싸므로 대부분의 RAID 하드웨어는 작은 크기의 비휘발성 RAM에 로그를 남기므로, 비싼 방식을 사용하지 않고도 일관성 유지 갱신 수행 가능
