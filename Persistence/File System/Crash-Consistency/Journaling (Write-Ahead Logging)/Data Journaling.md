-----
### 데이터 저널링
-----
1. 간단한 예제) Linux EXT3 파일 시스템에서 제공하는 저널 모드 중 하나인 데이터 저널링
   - 아이노드(I[v2])와 비트맵(B[v2]) 그리고 데이터 블럭(Db)를 갱신하는 평범한 파일 시스템 연산
   - 디스크의 최종 위치에 각 기록하기 전 로그(또는 저널)에 이들을 먼저 씀
<div align="center">
<img src="https://github.com/user-attachments/assets/5e0bc407-fb27-4666-bfdc-280991710ea6">
</div>

   - 다섯 개의 블록을 기록
   - 트랜잭션의 시작 블럭(TxB)은 연산에 대한 정보들을 기록
     + 시작 블럭에 기록되는 정보로 갱신될 블럭들에 대한 정보(예) I[v2]와 B[v2] 그리고 Db의 최종 주소)와 트랜잭션 식별자(TID)와 같은 것 존재

   - 디스크 상 최종 위치에 기록될 내용들이 가운데 세 개 블럭에 그대로 기록
   - 갱신해야 할 물리적 내용을 저널에 기록하기 떄문에 물리 로깅이라고도 불림 (대안으로는 갱신에 명령어 자체를 저장하는 논리 로깅도 존재 : 예) 이 갱신은 파일 X의 데이터 블럭 Db에 데이터를 덧붙이려고 한다.와 같은 내용이 로그에 기록)
   - 마지막으로 트랜잭션 종료 블럭(TxE)은 이 트랜잭션의 종료를 알리며 TID를 포함
   - 트랜잭션 종료 블럭이 로그에 기록되면 트랜잭션은 커밋(Commit)되었다고 말함

2. 트랜잭션이 디스크에 안전히 기록된 후, 파일 시스템 상 자료구조들은 이제 갱신될 수 있음
   - 저널에 기록된 내용을 실제 위치에 반영하는 과정을 체크포인팅이라고 부름
   - 파일 시스템 체크포인트 시(즉, 파일 시스템의 상태를 저널에 기록되어 있는 갱신 정보에 따라 최신으로 만드는 것) 디스크 원래의 위치에 I[v2]와 B[v2] 그리고 Db를 쓰도록 요청
   - 이 쓰기 요청이 완료되면 파일 시스템을 성공적으로 체크포인팅 한 것이고, 모든 동작이 끝난 것과 마찬가지
   - 작업의 순서는 다음과 같음
     + 저널에 기록한 직후 바로 체크포인트를 진행하지 않음
     + 저널 기록 : 트랜잭션을 저널에 기록 (구체적으로 트랜잭션 시작 블럭, 갱신될 데이터블럭과 메타데이터 블럭, 그리고 트랜잭션 종료 블럭을 로그에 기록하며, 이 블럭들이 디스크에 안전하게 기록될 때까지 대기)
     + 체크포인트 : 갱신된 메타데이터와 데이터 블럭들을 해당 위치에 반영

   - 예제에서는 TxB와 I[v2]와 B[v2]와 Db, TxE를 저널에 기록
   - 각 쓰기가 완료되면 I[v2]와 B[v2] 그리고 Db를 각각의 디스크의 최종 위치에 체크포인팅하여 갱신 과정 종료

3. 저널에 기록하는 도중에 크래시가 발생할 경우
   - 트랜잭션(예) TxB, I[v2], B[v2], Db, TxE)에 속한 블럭 집합을 디스크에 쓰려고 함
   - 달성하는 간단한 방법은 하나씩 요청을 디스크에 전달하고 각 완료되기를 기다렸다가 다음을 요청 (이 방법은 느림)
   - 이상적인 상황은 다섯 개의 요청을 한 꺼번에 전송해서 디스크가 이들을 차례로 순차 쓰기 하는 것
   - 매우 효율적이지만 문제 존재 : 한 번에 많은 양을 쓰고자 할 경우, 디스크가 스케줄링을 통해 임의로 이들을 작은 단위로 나누어 기록할 가능성이 존재하며, 완료 순서는 디스크에 의해 결정되며, 파일 시스템이 의도했던 순서와 완전히 다를 수 있음
   - 예를 들어, 디스크 내부적으로 (1) TxB, I[v2], B[v2] 그리고 TxE를 쓰고, (2) 나중에 Db를 쓸 수 있으므로, 불행하게도 디스크 전원이 (1)과 (2) 중간에서 차단되면 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/67baa200-7ec2-4ec6-bf35-95d75e653f40">
</div>

   - 저널링에서 트랜잭션 종료 블럭은 매우 중요한 역할
     + 트랜잭션 종료 블럭이 기록되면, 트랜잭션의 성공적 종료를 의미
     + 데이터 블럭이 저널에 기록되지 않았음에도 불구하고 트랜잭션이 성공적으로 정상 종료된 것처럼 보인다는 것을 의미 (시작과 끝에 동일한 식별자 순서 번호를 가지고 있음)
     + 즉, 저널의 네 번째 블럭 내용을 파일 시스템이 정상적 내용인지 아닌지를 알 수 없음
     + 비트맵이나 아이노드 블럭은 그 내용들을 살펴보면 의미가 있는 값인지 아닌지를 대략이라도 예상할 수 있지만, 저널 트래잭션 네 번째 블럭 위치에서 파일 데이터 기록되어야 하지만, 알 수 없으므로 블럭의 내용을 읽어도 잘못된 블럭인지 아닌지 알 수 없음
     + 시스템 재부팅을 하여 복구를 수행하고, 로그 영역을 검사하여, 저널에 기록된 내용들을 제 위치에 체크 포인트 할 것이며, 위의 경우에는 '??'라고 쓰여진 쓰레기 Db 블럭에 실제 위치에 그대로 복사하게 됨
     + 사용자의 데이터 일 떄도 문제지만, 슈퍼블럭과 같이 파일 시스템의 핵심 자료 구조가 이런 식으로 잘못 복구되면 마운트 조차 불가능하게 됨

4. 이러한 문제 발생을 방지하기 위해 파일 시스템은 트랜잭션을 두 단계로 나누어야 함
   - 먼저 TxE를 제외한 모든 블럭을 한 번의 쓰기 요청을 저널에 쓰며, 완료되면 다음과 같음 (덧붙이는 워크로드였다고 가정)
<div align="center">
<img src="https://github.com/user-attachments/assets/8c9106bc-1128-49dc-9662-e2de3cf652b2">
</div>

   - 이 쓰기가 오나료되면 파일 시스템은 TxE 블럭에 대한 쓰기를 요청하여 저널을 최종적으로 안전한 상태로 만듬
<div align="center">
<img src="https://github.com/user-attachments/assets/3b1c3531-c97a-4e20-a245-ee70cea636a9">
</div>

   - 단, 디스크 쓰기 연산의 원자성이라는 중요한 조건이 충족되어야 함
     + 트랜잭션 종료 블럭(TxE)는 무조건 원자적으로 기록되어야 함
     + 디스크는 섹터단위(512 Byte) 크기의 쓰기에 대한 원잔성은 보장하며, 하드디스크에 한 섹터, 즉 512 Byte를 기록할 경우, 512 Byte 중 첫 256 Byte는 기록되고, 뒤 256 Byte는 누락되는 이런 경우는 발생하지 않음
     + TxE 쓰기의 원자성을 보장하기 위해서는 하나의 512 Byte 블럭에 들어가도록 해야 함

   - 즉, 다음과 같이 정리
     + 저널 쓰기 : 트랜잭션 내용을 로그에 씀 (TxB와 메타데이터 그리고 데이터를 포함). 그리고 이 쓰기가 완료되길 기다림
     + 저널 커밋 : 트랜잭션 커밋 블럭을 로그에 씀(TxE 포함), 트랜잭션은 커밋됨이라고 함
     + 체크포인트 : 갱신(메타데이터와 데이터)한 내용을 디스크 상 최종 위치에 씀

5. 참고 : 디스크에 강제로 쓰기
   - 두 번의 디스크 쓰기 간의 순서 보장을 위해 현대 파일 시스템은 복잡한 방법 사용
   - 과거 : A와 B로 이루어진 두 번의 쓰기 순서를 보장하는 일은 어렵지 않았음 : 디스크에 A를 쓰기 요청하고 완료되면 운영체제 인터럽트를 걸어 B에 대한 쓰기 요청
   - 디스크 내 쓰기 캐시 사용이 늘어나면서 상황이 좀 더 복잡해짐
     + 쓰기 버퍼링이 동작 중이면(때로는 즉시 보고(Immediate Reporting)라고도 불림) 데이터는 디스크의 메모리 캐시에만 있고 디스크에는 다 쓰여지지 않았음에도 운영체제가 쓰기를 완료했다고 알림
       * 이 때, 두 번째 쓰기를 운영체제가 요청하면 첫 번째 쓰기 다음에 두 번째 쓰기가 디스크에 도달한다고 보장할 수 없으므로 쓰기 간의 순서는 보존이 안 됨
       * 한 가지 방법은 쓰기 버퍼링을 끄는 것임
     + 하지만, 최신의 시스템은 명시적으로 쓰기 배리어(Write Barrior)를 요청
       * 배리어 요청이 완료되었을 경우 어떤 쓰기 요청이든 배리어 이전에 요청된 것들은 배리어 요청 이후에 쓰기 요청을 받은 것들보다 먼저 디스크에 도달

   - 위 모든 기술 들은 디스크가 제대로 동작한다는 가정으로 시작
   - 하지만, 최근 연구에 따르면 몇 디스크 제조사들은 명시적으로 쓰기 배리어 요청을 하더라도 더 빠른 성능을 위해 그 명령을 무시하여 마치 디스크가 빠르게 동작하는 것처럼 보임

6. 참고 : 로그 쓰기의 최적화
   - 파일 시스템은 명시적으로 트랜잭션 시작 블럭을 쓰고 트랜잭션의 내용을 쓴 후에야 트랜잭션 끝 블럭을 디스크에 씀
   - 트랜잭션 시작과 끝 블럭에 저널 내용에 대한 체크섬을 포함하도록 하고, 파일 시스템이 전체 트랜잭션을 기다리지 않고 한 번에 쓸 수 있도록 해주며, 복구 시에 파일 시스템이 계산한 트랜잭션의 체크섬과 기록되어 있는 체크섬이 불일치한다면 트랜잭션 기록 중 크래시가 있었다고 결론을 내릴 수 있음
   - 따라서, 파일 시스템을 갱신하지 않도록 할 수 있으므로, 쓰기 규약과 복구 시스템을 약간 변경하면 파일 시스템은 일반적인 경우들에서도 빠른 성능을 얻을 수 있음
   - 더 나아가 저널의 내용을 읽을 때도 체크섬으로 보호를 받지 않으므로 파일 시스템은 신뢰성을 갖게 됨
   - 이 간단한 수정은 차세대 Linux 파일 시스템인 Linux EXT4에 적용
   
