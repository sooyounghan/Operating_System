-----
### 예제
-----
1. 저널링을 이해하기 위한 예제 : 디스크 상에서 여러 개의 자료 구조를 갱신하는 연산
   - 워크로드는 기존 파일에 블록을 하나 추가하는 연산
   - 파일을 열고 lseek()로 파일의 끝으로 오프셋을 이동한 후 4KB를 쓰고, 파일을 닫음
   - 간단한 파일 시스템 자료 구조 가정
     + 아이노드 비트맵(아이노드당 하나씩, 8비트 크기)
     + 데이터 비트맵(데이터 블럭당 하나씩, 8비트 크기)
     + 아이노드(총 8개, 0부터 7의 번호를 갖고 4개의 블럭 사용)
     + 데이터 블록(총 8개, 0부터 7의 번호를 가짐)
<div align="center">
<img src="https://github.com/user-attachments/assets/b1f28ee0-97b3-4762-a86f-3928676108c8">
</div>

2. 아이노드 테이블을 보면 2번 아이노드가 할당되어 있음
   - 아이노드 비트맵에 세 번째 비트가 설정(아이노드 번호 2)
   - 이 파일은 4번째 데이터 블럭을 사용 (데이터 비트맵의 4번째 비트가 사용 중으로 표시)
   - 아이노드는 첫 번쨰 버전이므로 Ⅰ[v1]으로 표기
   - 아이노드의 구조 (Ⅰ[v1] 내부)
```
owner : remzi
permissions : read−write
size : 1
pointer : 4
pointer : null
pointer : null
pointer : null
```
   - 파일의 크기는 1이고 (한 블럭이 할당됨) 첫 번째 직접 포인터는 4번 블럭을 가리키며 (파일의 첫 번쨰 데이터 블럭은 Da), 나머지 직접 포인터들은 NULL로 설정 (사용하고 있지 않음 표시)
   - 물론, 실제 아이노드는 더 많은 정보 포함

3. 이 파일의 끝에 내용을 추가한다는 것은 새로운 데이터 블럭을 추가하는 것
   - 세 개의 디스크 자료 구조를 갱신해야 함
     + 아이노드 (새로운 데이터 블럭을 가리켜야 할 뿐만 아니라 추가로 인해 더 커진 크기를 반영해야 하기 위함)
     + 새로운 데이터 블럭 Db
     + 데이터 비트맵 B[v2]
     + 새로운 블럭은 사용 중
     + 메모리에는 디스크 기록할 세 개의 블럭 존재 : 갱신된 아이노드(아이노드 버전 2 또는 Ⅰ[v2]) 내부
```
owner : remzi
permissions : read−write
size : 2
pointer : 4
pointer : 5
pointer : null
pointer : null
```
   - 데이터 비트맵(B[v2])은 00001100으로 갱신
   - 사용자의 내용이 저장된 데이터 블럭(Db)이 있으며, 이들이 디스크에 성공적으로 기록되면 디스크 모습은 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/87c4a399-7d74-4b46-9df8-7b0ca2fd8b5c">
</div>

   - 파일 시스템은 세 번의 쓰기를 수행해야 함
     + 하나는 아이노드(Ⅰ[v2])
     + 하나는 비트맵(B[v2])
     + 데이터 블럭(Db)
    
   - write()의 결과는 디스크에 즉시 반영되지 않고, 대신 변경된 아이노드와 비트맵 그리고 새로운 데이터는 일정 기간 동안 메인 메모리 상에 존재하다가 (페이지 캐시나 버퍼 캐시에) 파일 시스템이 실제로 디스크를 실행할 때(5초나 30초 이후 정도) 기록
   - 하지만 크래시 발생으로 인해 디스크 기록 과정이 엉망이 될 수 있음
