-----
### 실행 흐름 : 읽기와 쓰기
-----
1. 파일 시스템은 마운트되었고, 슈퍼블럭은 메모리 상 위치한다고 가정하며, 다른 모든 것(예) 아이노드, 디렉터리)들은 디스크에 존재하며, 메모리에 아직 탑재되지 않음
2. 디스크에서 파일 열기
   - 단순히 파일을 열고(예) /foo/bar), 읽고, 읽은 후에 닫는 상황 가정 (파일은 4KB 크기(1개의 블럭)을 가지고 있다고 가정)
   - open('/foo/bar', O_RDONLY) 시스템 콜을 하면 파일 시스템은 먼저 파일 bar에 대한 아이노드를 찾아 파일에 대한 기본적인 정보 획득 (권한 정보, 파일 크기 등)
     + 파일 시스템은 아이노노드를 찾아야 하며, 파일에 대한 전체 경로명을 가지고 있음
     + 파일 시스템은 경로명을 따라가서(Traverse) 원하는 아이노드를 찾아야 함
     + 경로명을 따라가는 것은 항상 파일 시스템의 루트에서 시작하며, 루트 디렉토리(Root Directory)는 /로 표기
     + 파일 시스템이 디스크에서 가장 먼저 읽을 것은 루트 디렉토리의 아이노드 : 아이노드를 찾기 위해서 I-Number를 알아야 하며, 일반적으로 어떤 파일이나 디렉토리의 I-Number는 부모 디렉토리에서 찾을 수 있음
     + 하지만, 루트 디렉토리는 부모가 없으며(정의상 없음), 루트 I-Number는 따라서 잘 알려진 것이어야 하는데, 이는 파일 시스템이 마운트될 때 이 값을 결정
     + 대부분의 UNIX 파일 시스템에서 루트 디렉토리 아이노드 번호는 2번이므로, 파일 시스템은 아이노드 번호 2번을 포함하는 블럭을 읽음 (첫 번째 아이노드 블럭)

   - 파일 시스템은 읽어들인 아이노드에서 데이터 블럭의 포인터를 추출
    + 포인터가 가리키는 블럭에는 루트 드렉터리의 내용이 존재
    + 디렉터리에 많은 파일이 들어있을 수 있으며, 파일 시스템은 이 포인터들을 사용하여 디렉토리 정보를 읽고, foo라는 항목을 찾음
    + 예를 들어, 3000개의 경우 모든 항목을 하나의 블럭에 저장할 수 없으므로, 하나의 디렉터리를 표현하기 위해 다수의 블럭을 사용
    + 하나 또는 그 이상의 디렉토리 데이터 블럭을 읽어서 foo에 대한 항목을 찾을 수 있음
    + foo 파일의 디렉토리 항목을 찾아서 foo의 아이노드 번호(44라고 가정)를 파악하며, 이 아이노드(44번 아이노드)가 필요
  
   - 경로명을 따라가서 원하는 아이노드를 찾음
     + 파일 시스템은 foo의 아이노드가 있는 블럭과 그에 대한 디렉토리 데이터를 읽은 후 마침내 bar에 대한 아이노드 번호를 찾아냄
     + 마지막 단계의 open()은 bar에 대한 아이노드를 메모리로 읽어들임
     + 파일 시스템은 최종적으로 해당 파일에 대한 접근 권한을 확인하고, 이 프로세스의 Open-File Table에서 파일 디스크럽터를 할당받아 사용자에게 리턴

   - open() 이후에는 read() 시스템 콜을 통해 파일을 읽음
     + 첫 번쨰 읽기(lseek()가 호출되지 않았다면 오프셋 0)는 아이노드를 통해 해당 블럭의 디스크 상 위치를 파악한 후 해당 블럭을 읽음
     + 첫 번쨰 읽기 작업이므로 첫 번째 블럭을 읽게 될 것이고(파일 오프셋이 일 경우), 파일을 읽은 후 파일을 마지막으로 읽은 시간을 아이 노드에 기록
     + 파일 오프셋은 파일을 읽거나 쓸 때, 해당 작업을 수행할 위치를 저장하는 변수
     + read()는 Open-File Table에서 해당 파일 디스크럽터에 대한 오프셋을 갱신하며, 다음에 읽기 작업을 수행할 때, 이전에 읽었던 다음 위치부터(파일의 두 번쨰 블럭) 읽고돌 갛 것

   - 어느 시점이 되면 그 파일을 닫아야 함
     + 할당된 파일 디스크럽터를 해제하면 됨
     + 디스크 I/O는 발생하지 않음

<div align="center">
<img src="https://github.com/user-attachments/assets/41d3aa6d-867e-4459-a0fa-0f6d306a092a">
</div>

3. I/O 발생 횟수는 경로의 길이에 비례하는 것에 유의
   - 경로가 하나 추가될 때마다 아이노드와 해당하는 데이터를 읽어야 함
   - 디렉토리 수가 많아지면 상황은 더 악화될 것
   - 디렉토리가 크다면 항목을 찾기 위해 많은 데이터 블럭을 읽어야 함

-----
### 디스크에 쓰기
-----
1. 파일을 연 뒤, 그 후에 응용 프로그램은 write()를 호출하여 새로운 내용으로 파일 갱신한 후, 최종적으로 파일을 닫음
2. 읽기와 다르게 파일 쓰기는 블럭 할당을 필요로 할 수 있음 (기존 블럭 내용이 갱신되는 것이 아닐 경우)
   - 새로운 파일을 쓸 때에는 각 write)는 데이터를 디스크에 기록해야 할 뿐만 아니라 파일에 어느 블럭을 할당할지 결정해야 하며 그에 따라 디스크에 다른 자료 구조들을 갱신해야 함(예) 데이터 비트맵과 아이노드)
   - 그러므로 파일에 대한 쓰기 요청은 논리적으로 다섯 번의 I/O 발생
     + 하나는 데이터 비트맵을 읽음 (이후 블럭이 사용됨에 따라 새롭게 할당된 블럭을 사용 중으로 표시하기 위해 갱신)
     + 하나는 비트맵을 쓰기 위해 사용 (새로운 블럭 위치 반영)
     + 두 개는 아이노드를 얻고 쓰기 위함 (새로운 블럭 위치 반영하기 위함)
     + 마지막으로 실제 블럭을 기록하기 위해 I/O 발생

3. 파일 생성과 같은 단순 작업에서 꽤 많은 양의 쓰기가 발생
   - 파일 생성 시, 아이노드를 할당하고, 새로운 파일을 위한 디렉토리 항목을 할당해야 함
   - 이 과정을 위한 전체 I/O 발생 횟수는 상당
     + 하나는 아이노드 비트맵을 얻기 위함 (프리 아이노드를 찾기 위함)
     + 하나는 아이노드 비트맵에 쓰기 위함 (할당되었다는 것을 표시)
     + 또 다른 하나는 새로운 아이노드 자체를 쓰기 위함 (초기화)
     + 다른 하나는 디렉토리의 데이터 블럭에 쓰기 위함 (아이노드 이름과 상위 수준 이름 연결 목적)
     + 그리고 한 번의 읽기와 쓰기는 디렉토리 아이노드를 읽고 갱신하기 위해 I/O가 발생

   - 만약, 새로운 파일을 저장하기 위해 디렉토리 크기가 증가하게 되면, I/O(데이터 비트맵과 새로운 디렉터리 블럭을 위해)가 추가
  
4. 구체적인 예) /foo/bar를 생성하고 그 안에 세 개의 블럭을 쓰는 예
<div align="center">
<img src="https://github.com/user-attachments/assets/04955846-eaac-4fcb-8d48-a5941c0dae47">
</div>

  - open()을 호출하여 세 개의 4KB 쓰기를 하는 동안 일어나는 일
  - 시스템 콜 별로 읽기와 쓰기를 그룹지어놓음
  - 경로명을 따라가서 파일을 생성하기까지 10번의 I/O가 발생
  - 각 write()는 5번의 I/O를 발생하였으며, write()는 새로운 파일 블럭을 필요로 함 (이를 Allocating-Write)
  - 아이노드를 읽고 쓰기, 데이터 비트맵을 읽고 쓰기, 그리고 끝으로 데이터 쓰기 총 5버

5. 참고 : 읽기는 할당 자료 구조를 접근하지 않음
   - 비트맵과 같은 할당 자료 구조는 할당할 때만 접근할 필요가 있으며, 파일을 읽을 땐 사용하지 않음
   - 아이노드와 디렉터리 그리고 간접 블럭들은 읽기 요청을 완료하는 데 필요한 모든 정보를 갖고 있음
   - 아이노드가 이미 블럭을 가리키고 있다면 그 블럭이 할당되었는지 알아볼 필요는 있음
