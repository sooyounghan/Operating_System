-----
### 캐싱과 버퍼링
-----
1. 파일을 읽고 쓰는 것은 많은 I/O를 발생시키며, 컴퓨터의 전체 성능에 중요 영향을 미침
   - 성능 개선을 위해 대부분의 파일 시스템들은 자주 사용되는 블럭들을 메모리(DRAM)에 캐싱

2. 앞의 예제에서 파일을 여는 과정을 생각
   - 캐싱을 하지 않는다면, 파일을 여는 동작은 디렉토리 마다 최소한 2번 읽기 필요 (디렉토리 아이노드 읽기와 디렉터리 데이터 읽기)
   - 경로가 많은 수의 디렉토리로 구성된 경우(예) 1/2/3/.../100/file.txt) 파일 시스템은 파일을 여는데 문자 그대로 수백 번의 읽기 수행

3. 초기의 파일 시스템에서는 자주 사용되는 블럭들을 도입하기 위해 캐시 도입
   - 가상 메모리에서 논의했듯 LRU와 기타 다른 캐시 교체 정책들이 캐시에 어떤 블럭들을 남길지 결정해야 했음
   - 이 고정 크키 캐시는 일반적으로 부팅 시 할당이 되며 전체 메모리의 약 10% 차지

4. 메모리의 정적 기법은 낭비가 심함
   - 고정 크기 방식을 사용하면 파일 캐시에서 사용되지 않은 페이지들은 다른 목적을 갖도록 용도 변경을 할 수 없으므로 낭비

5. 그에 비해 현대의 시스템은 동적 파티션 방식 사용
   - 현대의 많은 운영체제는 가상 메모리 페이지들과 파일 시스템 페이지들을 통합하여 일원화된 페이지 캐시(Unified Page Cache)를 만듬
   - 어느 한 시점에 어느 부분에 더 많은 메모리가 필요하냐에 따라 파일 시스템과 가상 메모리에 좀 더 융통성 있게 메모리 할당 가능

6. 캐싱을 하는 경우 파일 열기
   - 첫 번째 열기는 디렉토리 아이노드와 데이터로 인해 많은 I/O를 발생시키지만, 그 뒤로 같은 파일(또는 같은 디렉토리 파일들)에 대한 파일 열기의 경우 캐시에서 히트가 되므로 추가 I/O가 필요 없음

7. 쓰기 캐싱에 대한 영향력
   - 캐시가 충분히 크면 대부분의 읽기 I/O를 제거할 수 있음
   - 쓰기는 영속성 유지를 위해 해당 블럭들을 디스크로 내려야 함
   - 쓰기의 경우 캐시가 읽기에서와 같은 필터 역할을 할 수 없으므로, 쓰기 시점을 연기(Delay)하는 역할을 해야 하는데, 이를 쓰기 버퍼링(Write Buffering)이라 함
   - 쓰기 버퍼링을 통해 얻을 수 있는 성능 이득
     + 쓰기 요청을 지연시켜 다수의 쓰기 작업들을 적은 수의 I/O로 일괄처리(Batch) 가능 (예) 파일이 생성될 때 아이노드 비트맵이 갱신되었다고 가정, 잠시 후 다른 파일이 또 생성되면서 아이노드 비트맵은 다시 갱신된 경우, 파일 시스템은 첫 번째 갱신에 대한 쓰기를 연기하고, 두 번째 아이노드 비트맵에 대한 연산과 병합함으로 I/O를 1개 줄일 수 있음)
     + 여러 개의 쓰기 요청을 모아둠으로써 다수의 I/O들을 스케줄하여 성능 개선 가능
     + 지연시키는 것을 통해 쓰기 자체를 피할 수 있음 (예) 응용 프로그램이 파일을 생성한 후 즉시 삭제한다고 했을 때, 컴파일러는 컴파일 과정에서 수많은 임시파이을 생성하고 삭제하는데, 이 경우 쓰기를 지연하면 애초에 디스크에서 파일을 생성할 필요가 없음)

   - 대부분 파일 시스템들은 쓰기 요청을 메모리에 약 5초 ~ 30초 동안 버퍼링
     + 단, 쓰기 요청들이 디스크에 기록되기 전 시스템이 크래시되면 내용이 손실
     + 메모리 쓰기 내용을 오래 유지함으로써, 일괄처리 / 스케줄링을 통해 성능을 개선할 수 있지만, 때로는 쓰기 자체가 필요 없어지기도 함

8. 어떤 응용 프로그램(예) 데이터베이스 등) 버퍼링으로 인해 발생하는 문제를 용납할 숭 없음
   - 예금을 했는데, 전원 차단이 되어 통장 잔고에 반영되지 않고 돈이 손실된다면, 이는 쓰기 버퍼링으로 인한 예기치 않은 데이터 유실이므로 이를 피하기 위해 fsync() 사용
   - 이를 호출하면 갱신된 내용이 디스크에 강제 기록이 되며, 캐시를 사용하지 않도록 Direct I/O 인터페이스를 사용하거나 디스크(Raw Disk) 인터페이스를 사용하여 파일 시스템을 건너뛰고 직접 디스크에 기록하는 경우도 존재
   - 대부분 응용 프로그램은 파일 시스템이 제공하는 버퍼링 기능을 사용하지만, 원치 않을 경우 시스템을 원하는 식으로 설정하는 충분한 제어 기능들 존재

-----
### 정적 대 동적 파티션
----
1. 정적 방식은 고정된 크기로 자원을 한 번만 나눔
   - 예를 들어, 메모리를 사용할 수 있는 두 사용자가 있다고 가정
   - 한 사용자에게 메모리의 고정된 일부를 준 후 나머지 모두를 다른 사용자에게 줄 수 있음

2. 동적 방식은 유동적이므로 때에 따라 다른 양의 자원을 나눠줄 수 있음
   - 예를 들어, 한 사용자가 일정 시간 동안 높은 퍼센트로 디스크 대역폭을 쓰고 있다고 가정
   - 잠시 후 시스템은 사용 가능한 디스크 대역폭 중 많은 부분을 다른 사용자에게 할당하기로 결정 가능

3. 각 접근법은 각자의 장점 존재
   - 정적 파티션 : 각 사용자가 자원의 일부를 나누어쓰도록 하므로 일반적으로 예상 가능한 성능을 얻을 수 있고, 구현하기도 대체적으로 쉬움
   - 동적 파티션 : 활용률 측면에서는 더 좋긴 하지만(자원을 많이 써야 하는 사용자가 남는 자원을 쓰는 것이므로), 구현하기에 복잡할 수 있음
   - 또한, 사용자가 가지고 있던 자원을 다른 사용자에게 줬지만, 실제 필요로 할때는 돌려받기 위해 오랜 시간이 걸릴 수 있으므로, 자원을 제공한 사용자 입장에서는 성능이 나빠지게 됨
   
