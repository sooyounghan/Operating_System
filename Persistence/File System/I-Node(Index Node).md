-----
### 파일 구성 : 아이노드
-----
1. 파일 시스템의 디스크 자료 구조 중 가장 중요한 것은 아이노드(I-Node)
2. 아이노드는 인덱스 노드(Index Node)의 줄임말로서, 역사적으로 UNIX 창시자인 Ken Thompson이 처음 사용
   - 이 노드들은 원래는 배열로 되어 있는데, 각 배열은 특정 아이노드를 접근하기 위해 탐색

3. 자료 구조 - 아이노드
   - 파일 메타데이터를 저장하기 위한 자료 구조로서 많은 파일 시스템들이 아이노드(I-Node)라는 일반적인 이름을 사용
   - 이 자료구조는 파일 크기, 접근 권한, 그리고 파일 블럭들의 위치 정보를 가지고 있음
   - 디스크 상 아이노드의 배열의 인덱스로 아이노드 번호를 사용하던 것에서 기안
   - D-Node, F-Node 등으로도 불림

4. 각 아이노드는 숫자(아이넘버(I-Number))로 표현되며, 파일의 저수준 이름(Low-Level Name)이라고도 불림
   - VSFS에서는 아이넘버를 사용해서 해당 아이노드가 디스크 상 어디에 있는지 직접 계산 가능
   - 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/c37620ab-12ba-4787-8bb7-4ec0def6e48a">
</div>

   - 크기가 20KB이고(4KB 블럭 5개), 80개의 아이노드(각 아이노드는 256Bytes)로 이루어져있음 (슈퍼블럭은 0KB에 위치에서 시작)
   - 아이노드 비트맵 주소는 4KB에서부터, 데이터 비트맵은 8KB에서부터 시작하며, 아이노드 테이블은 그 바로 직후에 있음
   - VSFS 파일 시스템 파티션의 시작 부분은 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/c37620ab-12ba-4787-8bb7-4ec0def6e48a">
</div>

5. 32번 아이노드를 읽기 위해 파일 시스템은 아이노드 영역에서의 오프셋 계산 : 32 * sizeof(inode) 또는 8192)
   - 그 후, 아이노드 테이블의 시작 위치를 더하면(inodeStartAddr = 12KB), 원하는 아이노드 블럭의 정확한 바이트 주소를 구할 수 있음(20KB)
   - 💡 디스크는 바이트 단위로는 접근이 불가능하여 대신에 대체적으로 512 바이트 크기를 갖는 섹터(Sector)로 이루어짐
   - 32번 아이노드가 존재하는 블럭을 가져오기 위해서는 파일 시스템은 섹터 주소 $\frac {20 × 1024}{512}$ 또는 40에 대한 읽기 요청을 해당 아이노드 블럭을 가져옴
   - 아이노드 블럭의 섹터 주소 iaddr은 다음과 같이 계산 가능
```c
blk = (inumber * sizeof(inode_t)) / blockSize;
sector = ((blk * blockSize) + inodeStartAddr) / sectorSize;
```

6. 아이노드에는 파일에 대한 정보가 다 들어있으며, 파일의 종류(예) 일반 파일, 디렉터리 등), 크기, 할당된 블럭 수, 보호 정보(파일의 소유, 접근 권한 등), 시간 정보와 더불어 데이터 블럭이 디스크 어디에 존재하는지 (예) 포인터의 일종)와 같은 정보들이 담겨 있음
   - 이와 같은 파일에 대한 정보들을 메타데이터(Metadata)라고 하며, 사용자 데이터가 아닌 기타 정보를 통틀어 메타데이터라 부름
   - EXT2의 아이노드 예
<div align="center">
<img src="https://github.com/user-attachments/assets/97728369-9e0f-46ac-adf7-6fbb751d4d4d">
</div>

7. 아이노드 설계 시 가장 중요한 결정 중 하나는 데이터 블럭의 위치를 표현하는 방법
   - 간단한 방법은 아이노드 내 여러 개의 직접 포인터(Direct Pointer, 디스크 주소)를 두는 것
   - 각 포인터는 파일의 디스크 블럭 하나를 가리킴
   - 이 방법은 제약이 많음 : 파일 크기의 제한이 있으며, 파일 크기가 (포인터의 개수) * (블럭 크기)로 제한

-----
### 멀티 레벨 인덱스 (Multi-Level Index)
-----
1. 큰 파일을 지원하기 위해서 파일 시스템 개발자들은 아이노드 내 다른 자료 구조를 추가해야 함
2. 일반적으로 사용되는 방법 중 하나는 간접 포인터(Indirect Pointer)라는 특수한 포인터 사용
   - 간접 포인터는 데이터 블럭을 가리키지 않고, 가리키는 블럭에는 데이터 블럭을 가리키는 포인터들이 저장
   - 직접 포인터와 간접 포인터를 결합해서 사용할 수 있음
   - 아이노드에는 정해진 수의 직접 포인터(예) 12개), 그리고 하나의 간접 포인터가 있음
   - 큰 파일에 대해서는 간접 블럭이 할당되고(디스크 데이터 블럭 영역 에서), 아이노드의 간접 포인터는 이 간접 블럭을 가리킴
   - 블럭이 4KB이고, 디스크 주소가 4바이트라고 하면, 1024개 포인터들을 추가로 할 수 있음
   - 최대 파일 크기 : (12 + 1024) * 4KB 또는 4414 KB

3. 4414KB는 큰 파일은 아니므로, 더 큰 파일을 저장하고 싶을 때, 아이노드에 이중 간접 포인터(Double Indirect Pointer)를 추가
    - 이중 간접 포인터가 가리키는 블럭에는 간접 포인터들이 저장되어 있음
    - 각 간접 블럭은 데이터 블럭을 가리키는 포인터들을 가리키고 있음
    - 이중 간접 블럭을 사용하면 파일은 4KB * 1024 * 1024, 약 백만개의 4KByte 블럭을 가질 수 있음 (즉, 4GB가 넘는 크기의 파일을 지원할 수 있게 됨)
   
4. 더 큰 파일을 표현해야 한다면, 삼중 간접 포인터(Triple Indirect Pointer)를 사용

5. 디스크 블럭들은 일종의 트리 형태로 구성되어 하나의 파일을 이룸
   - 약간 한쪽으로 치우쳐진 형태의 트리로, 이런 구성방식을 멀티 레벨 인덱스 기법이라 부름
   - 열 두개의 직접 포인터와 하나의 간접 블럭과 이중 간접 블럭을 사용하는 예
     + 블럭 크기가 4KB라고 하고, 각 포인터 크기가 4바이트라고 하면, 구조에서 파일은 4GB가 조금 넘는 크기를 가질 수 있음((12 + 1024 + $1024^{2}$) × 4KB)

6. 일반적으로 사용되는 파일 시스템인 EXT2, EXT3 / NetApp의 WAFL을 포함하여, 많은 파일 시스템들이 멀티 레벨 인덱스 사용
7. SGI의 XFS와 Linux의 EXT4와 같은 파일 시스템들은 간단한 포인터를 사용하는 대신 익스텐트 사용
   - 익스텐트(Extent) 기반의 동작 방법
     + 단순히 디스크 포인터와 길이(블럭 단위)로 구성
     + 파일의 모든 블럭에 대해서 포인터를 써야 하는 대신 디스크 상 한 파일의 위치를 가리키기 위해 하나의 포인터와 길이만 표현하면 됨
     + 디스크 상 충분히 크고 연속적인 비어 있는 공간을 찾는 것이 어려울 수 있으므로, 하나의 익스텐트만을 갖는 것은 제한적일 수 있음
     + 따라서, 익스텐트 기반 파일 시스템은 하나 이상의 익스텐트를 갖는 것을 허용하여 파일을 할당할 때 좀 더 자유도가 높아질 수 있도록 함
     + 두 기법을 비교하면, 포인터 기반 접근법은 가장 자유도가 높지만 각 파일당 많은 양의 메타데이터를 사용(특히, 큰 파일들의 경우), 익스텐트 기반의 접근법은 자유도가 낮은 대신 좀 더 집약되어 있음
     + 특히, 디스크에 여유 공간이 충분히 있고, 파일들을 연속적으로 배치할 수 있을 때 잘 동작

8. 트리의 형태가 편향적
   - 파일의 시작 부분을 이루는 블럭들은 한 번의 포인터로 접근이 가능하지만, 큰 파일의 경우 파일의 끝 부분에 있는 블럭들은 포인터를 세 번 따라가야 실제 블럭을 읽을 수 있음
   - 대부분의 파일 크기가 작기 때문에, 비대칭적 트리형태를 채용한 것
   - 대부분의 파일들이 작다면, 작은 파일을 빨리 읽고 쓸 수 있도록 직접 포인터(대체적으로 12개)를 갖고 있으며, 큰 파일들을 위해서 하나(또는 그 이상)의 간접 블럭이 필요

9. 파일은 위 방식 말고도 다양한 방식으로 구성 가능
    - 아이노드는 자료 구조이며, 데이터와 관련 내용들을 효율적으로 읽고 쓸 수 있다면, 어떤 방식으로든 사용 가능
    - 파일 시스템 소프트웨어는 손쉽게 변경이 가능
