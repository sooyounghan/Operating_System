-----
### 아이노드 찾기
-----
1. LFS에서 아이노드의 위치를 파악하는 방법
   - FFS와 같은 파일 시스템이나 그보다 오래된 UNIX 파일 시스템에서 아이노드를 찾는 것은 간단 : 정해진 위치에 배열로 배치되어 있기 때문임
   - 전통적인 파일 시스템에서는 각 아이노드의 위치가 정해져 있음
     + 아이노드 번호와 시작 주소가 주어지면, 특정 아이노드의 위치는 아이노드 번호에 아이노드 크기로 곱하고 배열의 시작 주소에 더하면 구할 수 있음
     + 배열을 사용하면 아이노드 위치를 빠르고 간단하게 찾을 수 있음

2. FFS에서 아이노드 번호를 사용하여 아이노드를 찾는 것은 좀 더 복잡합
   - FFS는 아이노드 테이블을 분할하여 실린더 그룹마다 아이노드 그룹에 넣어둠
   - 분할된 테이블 크기를 알아야 하며, 각 시작 주소를 알아야 함
   - 위치 계산은 배열 기반과 유사하며 마찬가지로 간단함

3. LFS의 경우 좀 더 복잡한데, 아이노드가 디스크 전역에 흩어져 있음
   - 뿐만 아니라 원 위치에 덮어쓰기를 하지 않으므로, 최신 아이노드 위치(즉, 우리가 원하는)가 계속 변하기 때문임

-----
### 간접 계층을 이용한 해법 : 아이노드 맵
-----
1. 계속적으로 이동하는 아이노드 위치를 파악하기 위해 LFS 설계자들은 아이노드 맵(I-Node Map, imap)이라는 자료 구조 개발
2. imap 자료 구조는 아이노드 번호를 입력으로 하여 가장 최신 아이노드의 디스크 위치를 구함
   - 이 구조는 각 항목당 4바이트(디스크 포인터)를 갖는 간단한 배열로 구현될 수 있음
   - 디스크에 아이노드가 기록될 때 imap은 새로운 위치를 가리키도록 갱신

3. imap은 안전하게 보관되어야 함(즉, 디스크에 써져야 함)
   - 그래야 LFS에 크래시가 발생하더라도 아이노드의 위치를 파악할 수 있음
   - imap을 디스크의 고정된 위치에 배치하는 방법이 있는데, imap은 자주 갱신되므로 파일 시스템의 내용이 변경될 경우, imap을 새로 기록해야 함
   - 잦은 갱신으로 인해, 성능이 저하될 수 있음 (즉, 각 쓰기의 위치와 imap 간 디스크 탐색이 더 많아지게 됨)
   - LFS에서는 아이노드 맵을 새로이 기록된 데이터와 아이노드들 옆에 함께 기록됨
     + 파일 k에 데이터 블럭을 추가할 때, LFS는 새로운 데이터 블럭과 해당 아이노드 그리고 아이노드 맵의 일부분을 연속하여 디스크에 기록
<div align="center">
<img src="https://github.com/user-attachments/assets/b1bf9127-bec1-4ca5-995c-e2ae0ae160fb">
</div>

3. blk[0]는 A0는 첫 번째 블럭 주소가 A0라는 뜻
4. I[K]는 K번쨰 아이노드를 나타냄
5. map[K]는 A1은 K번째 아이노드가 A1에 위치해있다는 뜻으로, 이 그림에서는 imap이라고 표기된 블럭에 저장되어 있는 아이맵 일부가 아이노드 k는 디스크 주소 A1에 있다고 나타내고 잇음
6. 이 아이노드는 데이터 블럭 D가 주소 A0에서 시작한다는 정보를 가지고 있음
