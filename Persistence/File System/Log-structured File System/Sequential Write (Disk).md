-----
### 디스크에 순차적으로 쓰기
-----
1. 파일 시스템을 변경하는 모든 쓰기 작업을 어떻게 순차 쓰기로 디스크에 보낼 수 있는가?
2. 예제) 파일에 데이터 블럭 D를 쓴다고 가정
   - 데이터 블럭을 디스크에 쓰게 되면 디스크 상의 배치는 다음과 같으며, 디스크의 주소 A0에 D가 쓰임
<div align="center">
<img src="https://github.com/user-attachments/assets/35fe3f1d-cf86-447c-84b4-fb18bb0888f2">
</div>

   - 데이터 블럭을 기록하면 데이터 갱신뿐만 아니라 메타데이터도 같이 갱신되어야 함
   - 이 경우, 해당 파일의 아이노드(I)도 디스크에 기록하고, 아이노드가 데이터 블럭 D를 가리키도록 해야 함
   - 데이터 블럭과 아이노드를 디스크에 함께 기록하면 다음과 같이 됨 (실제로 그렇지 않지만, 아이노드가 데이터 블럭만큼 크게 보이는 것에 유의. 대부분 시스템에서는 데이터 블럭은 4KB 크기를 갖고 아이노드는 그보다 훨씬 작은 128 Byte의 크기를 가짐)
<div align="center">
<img src="https://github.com/user-attachments/assets/cd99a860-93be-47e3-8460-3a2dda711bbd">
</div>

3. 모든 갱신(데이터 블럭과 아이노드 등)을 디스크에 순차적으로 기록하는 것이 LFS에 핵심

-----
### 순차적이면서 효율적으로 쓰기
-----
1. 디스크에 순차적으로 쓰는 것(만)으로는 효율적 쓰기 보장 불가
2. 예를 들어, 시간 T에 A 위치에 하나의 블럭을 썼다고 가정
   - 잠시 기다렸다가 T + δ시간에 디스크의 주소 A + 1(순차적 순서에 따른 다음 블럭 주소)에 쓰기 실시
   - 불행하게도 첫 쓰기와 두 번쨰 쓰기 사이에 디스크는 회전을 실시
   - 두 번째 쓰기의 경우, 디스크에 기록이 행해지기 전에 플래터를 회전시켜야 함(구체적으로, 만약 회전이 $T_{rotation}$만큼의 시간이 걸렸다면, 디스크 표면에 두 번째 쓰기를 실행하기 전까지 $T_{rotation} - δ$의 시간을 기다려야 함)
   - 순차적인 순서로 쓰는 것만으로는 디스크의 최대 성능을 달성하기 어려우며, 다수의 순차쓰기를 (또는 하나의 큰 크기의 쓰기) 한 번에 디스크에 내려 보내야 빠른 쓰기 성능을 얻을 수 있음

3. 이를 위해 LFS는 쓰기 버퍼링이라는 고전적 기법 사용
   - 세그먼트가 컴퓨터 시스템에서는 너무 자주 사용되지만, 여기서는 LFS가 단일 집합으로 묶어서 쓰기 위해 사용하는 쓰기 단위
   - 디스크에 데이터를 기록할 때, 쓰기 내용들을 세그먼트 버퍼에 유지하고, 세그먼트가 차면 세그먼트 버퍼의 한 번의 쓰기 연산을 통해 디스크에 기록
   - 세그먼트가 충분히 크면, 쓰기 연산은 효율적

4. LFS가 두 개의 갱신 내용을 하나의 세그먼트 버퍼에 넣는 예제
   - 실제 세그먼트는 이보다 더 크다는 것을 참고(몇 MB 단위)
   - 첫 번째 추가된 갱신의 내용은 파일 j에 4개의 블럭을 쓰는 것이고, 두 번째 갱신된 것은 파일 k에 한 개의 블럭을 추가하는 것
   - LFS는 일곱개의 블럭으로 이루어진 세그먼트 전체를 디스크로 한 번에 커밋
   - 최종적으로 디스크 상의 블럭들의 배치
<div align="center">
<img src="https://github.com/user-attachments/assets/21272fc9-5b8b-47f0-bf2f-59d8d2c0fe70">
</div>
