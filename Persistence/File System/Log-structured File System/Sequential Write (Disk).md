-----
### 디스크에 순차적으로 쓰기
-----
1. 파일 시스템을 변경하는 모든 쓰기 작업을 어떻게 순차 쓰기로 디스크에 보낼 수 있는가?
2. 예제) 파일에 데이터 블럭 D를 쓴다고 가정
   - 데이터 블럭을 디스크에 쓰게 되면 디스크 상의 배치는 다음과 같으며, 디스크의 주소 A0에 D가 쓰임
<div align="center">
<img src="https://github.com/user-attachments/assets/35fe3f1d-cf86-447c-84b4-fb18bb0888f2">
</div>

   - 데이터 블럭을 기록하면 데이터 갱신뿐만 아니라 메타데이터도 같이 갱신되어야 함
   - 이 경우, 해당 파일의 아이노드(I)도 디스크에 기록하고, 아이노드가 데이터 블럭 D를 가리키도록 해야 함
   - 데이터 블럭과 아이노드를 디스크에 함께 기록하면 다음과 같이 됨 (실제로 그렇지 않지만, 아이노드가 데이터 블럭만큼 크게 보이는 것에 유의. 대부분 시스템에서는 데이터 블럭은 4KB 크기를 갖고 아이노드는 그보다 훨씬 작은 128 Byte의 크기를 가짐)
<div align="center">
<img src="https://github.com/user-attachments/assets/cd99a860-93be-47e3-8460-3a2dda711bbd">
</div>

3. 모든 갱신(데이터 블럭과 아이노드 등)을 디스크에 순차적으로 기록하는 것이 LFS에 핵심

-----
### 순차적이면서 효율적으로 쓰기
-----
1. 디스크에 순차적으로 쓰는 것(만)으로는 효율적 쓰기 보장 불가
2. 예를 들어, 시간 T에 A 위치에 하나의 블럭을 썼다고 가정
   - 잠시 기다렸다가 T + δ시간에 디스크의 주소 A + 1(순차적 순서에 따른 다음 블럭 주소)에 쓰기 실시
   - 불행하게도 첫 쓰기와 두 번쨰 쓰기 사이에 디스크는 회전을 실시
   - 두 번째 쓰기의 경우, 디스크에 기록이 행해지기 전에 플래터를 회전시켜야 함(구체적으로, 만약 회전이 $T_{rotation}$만큼의 시간이 걸렸다면, 디스크 표면에 두 번째 쓰기를 실행하기 전까지 $T_{rotation} - δ$의 시간을 기다려야 함)
   - 순차적인 순서로 쓰는 것만으로는 디스크의 최대 성능을 달성하기 어려우며, 다수의 순차쓰기를 (또는 하나의 큰 크기의 쓰기) 한 번에 디스크에 내려 보내야 빠른 쓰기 성능을 얻을 수 있음

3. 이를 위해 LFS는 쓰기 버퍼링이라는 고전적 기법 사용
   - 세그먼트가 컴퓨터 시스템에서는 너무 자주 사용되지만, 여기서는 LFS가 단일 집합으로 묶어서 쓰기 위해 사용하는 쓰기 단위
   - 디스크에 데이터를 기록할 때, 쓰기 내용들을 세그먼트 버퍼에 유지하고, 세그먼트가 차면 세그먼트 버퍼의 한 번의 쓰기 연산을 통해 디스크에 기록
   - 세그먼트가 충분히 크면, 쓰기 연산은 효율적

4. LFS가 두 개의 갱신 내용을 하나의 세그먼트 버퍼에 넣는 예제
   - 실제 세그먼트는 이보다 더 크다는 것을 참고(몇 MB 단위)
   - 첫 번째 추가된 갱신의 내용은 파일 j에 4개의 블럭을 쓰는 것이고, 두 번째 갱신된 것은 파일 k에 한 개의 블럭을 추가하는 것
   - LFS는 일곱개의 블럭으로 이루어진 세그먼트 전체를 디스크로 한 번에 커밋
   - 최종적으로 디스크 상의 블럭들의 배치
<div align="center">
<img src="https://github.com/user-attachments/assets/21272fc9-5b8b-47f0-bf2f-59d8d2c0fe70">
</div>

-----
### 적절한 버퍼의 크기
-----
1. 디스크에 실제 쓰기 전 LFS는 몇 개의 쓰기 내용으 세그먼트 버퍼에 가지고 있어야 하는가?
    - 디스크의 물리적 특성에 의해 변함 : 전송 속도 대비 위치 잡기 오버헤드가 얼마나 큰지에 따라 달라짐

2. 예를 들어, 쓰기 시 발생하는 위치 잡기(즉, 회전과 탐색 오버헤드)에 드는 시간이 $T_{position}$초가 걸린다고 가정하며, 디스크 전송 속도는 $R_{peak}$ MB/s라고 가정할 때, 적절한 세그먼트의 크기
   - 매번 쓰기 시 디스크 헤드를 이동하는데 일정 시간이 소요된다고 가정
   - 위치 잡기 비용을 상쇄(Amortize)하기 위해서는 클수록 좋으며, 최대 대역폭에 더 근접할 수 있음
   - D MB 크기를 쓴다고 가정하며, 이 데이터 청크를 쓰는데 소요되는 시간($T_{write}$)은 위치 잡기 시간($T_{position}$)에 D를 전송하는 시간($\frac{D}{R_{peak}}$)을 더한 것으로 즉,
<div align="center">
<img src="https://github.com/user-attachments/assets/2fd0d6f5-80c8-44f9-bfb3-f9d36a807435">
</div>

   - 실제 쓰기 속도는 $R_{effective}$이며, 다음과 식과 같이 쓰인 데이터의 총량을 해당 데이터를 쓰는데 소요된 총 시간으로 나눈 것
<div align="center">
<img src="https://github.com/user-attachments/assets/84f0fd00-38fc-4469-b690-c1ec17f3dca3">
</div>

   - 최대 속도에 근접하도록 유효 속도($R_{effective}$)를 구하고자 할때, 유효 속도가 최대 속도의 특정 비율(F)가 되도록 하는 것
     + F는 0 < F < 1의 값을 가지며(대체로 F는 최대 속도의 0.9 또는 90%), 수학적으로는 $R_{effective} = F × R_{peak}$ 식에 해당
   - D에 대해서 식을 정리하면,
<div align="center">
<img src="https://github.com/user-attachments/assets/5111a102-b7f8-4bad-9008-7c2997253b06">
</div>

<div align="center">
<img src="https://github.com/user-attachments/assets/25fe850c-a502-47e0-8752-c669835ee4c5">
</div>


3. 예제) 디스크 헤드 이동 시간(위치잡기 시간)이 10ms이고, 최대 전송 속도가 100MB/s
   - 유효 대역폭이 최대 속도의 90%(F = 0.9)가 되기를 원한다고 가정
   - 이 경우, 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/7562066a-851e-4b9b-a49f-be6e1f4fdd39">
</div>

   
