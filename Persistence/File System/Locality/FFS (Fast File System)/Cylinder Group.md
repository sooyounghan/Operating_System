-----
### 파일 시스템 구조 : 실린더 그룹
-----
1. 첫 번째 단계는 디스크에 적합하게 파일 시스템을 구성을 수정하는 것
   - FFS는 디스크를 여러 개의 실린더 그룹(Cylinder Group, 현대의 Linux의 Ext2와 Ext3에서는 블럭 그룹(Block Group)으로 부르기도 함)으로 분할
   - 실린더 그룹이 10개 있는 디스크
<div align="center">
<img src="https://github.com/user-attachments/assets/f13e5333-437e-4957-89f6-4fb4c9adda6e">
</div>

2. 실린더 그룹은 FFS 핵심 중 핵심
   - 두 개의 파일을 같은 그룹에 배치시켜서, 한 파일을 읽고, 다음의 파일에 접근할 때는 디스크 전역에 걸친 긴 탐색이 발생하지 않도록 함
   - FFS는 파일과 그 파일이 속한 디렉토리 블럭을 같은 그룹에 할당
   - 물론, 그룹이 꽉 차면 밀려나는 경우도 존재
<div align="center">
<img src="https://github.com/user-attachments/assets/00c9778b-648d-45f5-8f21-e76bfae16f14">
</div>

3. 실린더 그룹의 구성 요소
   - 슈퍼블럭의 복사본(S)이 각 그룹마다 존재 (예) 하나가 훼손되더라도 다른 것을 사용해 파일 시스템을 마운트하고 접근 가능)
   - 각 그룹 내에서 아이노드와 데이터 블럭들의 할당 여부를 알 수 있어야 함 : 그룹별로 아이노드 비트맵(ib)과 데이터 비트맵(db)이 존재
     + 각 그룹이 아이노드와 데이터 블럭의 할당 정보를 나타냄
     + 비트맵은 파일 시스템의 빈 영역을 나타내는 훌륭한 방법으로, 큰 크기의 연속된 빈 공간을 쉽게 찾을 수 있음
     + 프리 리스트 사용 시 발생하는 파일 시스템의 단편화 문제도 어느정도 피할 수 있음

  - 마지막으로 아이노드와 데이터 블럭 영역은 단순한 파일 시스템에서 봤던 것과 동일하며, 각 실린더 그룹의 대부분도 마찬가지로 데이터 블럭으로 구성

4. 참고 : FFS에서 파일 생성
   - 파일이 생성될 때 어떠한 자료구조들이 변경되어야 하는지 확인
   - 사용자가 /foo/bar.txt라는 파일을 생성하고 블럭 하나 크기(4KB)라고 가정
     + 새로운 파일이므로 새로운 아이노드가 필요 : 아이노드 비트맵과 새로 할당받은 아이노드가 디스크에 기록
     + 파일에는 데이터도 있으므로 데이터 비트맵과 데이터 블럭도 자연스럽게 디스크에 기록
     + 최소한 4번의 쓰기가 현재 실린더 그룹에서 발생
     + 추가적으로, 파일 생성을 구체적으로 살펴보면 파일을 파일 시스템 계층에 저장하여야 하므로 디렉터리도 같이 갱신되어야 함
     + 여기서는 bar.txt에 대한 항목을 추가하기 위해 부모 디렉토리 foo가 갱신되어야 함
     + 이 갱신은 foo가 있는 데이터 블럭에 같이 기록될 수 있고, 새로운 블럭을 할당받아야 할 수 있음 (해당하는 데이터 비트맵과 함께)
     + 변경된 디렉터리 크기와 갱신 시간 필드(마지막 변경 시간과 같은)를 반영하기 위해 foo의 아이노드 역시 갱신되어야 함
       
