-----
### 예제 : 간단한 디스크 드라이브
-----
1. 하나의 트랙으로만 이루어진 간단한 디스크
<div align="center">
<img src="https://github.com/user-attachments/assets/151a4d19-9d33-42f6-acad-b612995a300d">
</div>

   - 이 트랙에는 12개의 섹터가 존재
   - 각 섹터는 512 Byte 크기를 갖고 있음 (섹터의 일반적 크기) : 0부터 11까지 이루어져 있음
   - 모터에 연결된 회전축을 중심으로 플래터가 회전

2. 디스크 앞에 붙어 있는 디스크 헤더
<div align="center">
<img src="https://github.com/user-attachments/assets/4e52b03c-c716-4692-acad-6f9ebceb1c8c">
</div>

  - 디스크 헤드는 디스크 암의 끝에 붙어 있으며, 섹터 6번 위에 위치
  - 표면은 시계 반대 방향으로 회전

3. 단일 트랙 지연 시간 : 회전 지연
   - 트랙이 하나 뿐인 간단한 디스크에서 요청이 처리되기 위해서 블럭 0번을 읽는다고 가정
   - 디스크 헤더 아래 원하는 섹터가 위치하기를 기다림 (이러한 기다림은 현대 드라이브에서도 흔하게 발생하여 I/O 서비스 시간에 중요 요소이므로, 회전형 지연(Rotational Delay) 또는 회전 지연(Rotation Delay)라고 함)
   - 예제에서 만약 한 바퀴를 회전 하는데 걸리는 시간이 R이라고 하면, 디스크 (6에서 시작한 경우) 읽거나 쓰려는 디스크 헤드가 0에 위치하기 위해 $\frac{R}{2}$이 필요
   - 트랙이 하나 있을 때 최악의 경우는 섹터 5번에 있을 때이며, 거의 한바퀴를 돌아야 요청을 처리할 수 있음

4. 멀티 트랙 : 탐색 시간
   - 현대 디스크들은 수백만개의 트랙을 가짐
   - 트랙이 세 개 있는 경우
<div align="center">
<img src="https://github.com/user-attachments/assets/5f6f6273-63c3-4af7-aff6-a07fec5fcf31">
</div>

  - 이 그림에서 헤드는 가장 안쪽 트랙(섹터 24 ~ 35번)에 위치하고 있으며, 그 다음 트랙은 다음 섹터 집합(섹터 12 ~ 23번)에 위치, 가장 바깥쪽의 트랙에는 선두 섹터(섹터 0 ~ 11번)이 존재
  - 드라이브가 지정된 섹터들을 접근하는 방식을 이해하기 위한 예시) 섹터 11번을 읽는 경우처럼 멀리 떨어진 섹터에 대한 요청을 받을 때
    + 이 읽기 요청을 처리하기 위해서는 디스크 암을 먼저 올바른 트랙 위에 위치 (이 경우 가장 바깥쪽 트랙) : 이 과정을 탐색(Seek)
    + 회전과 더불어서 탐색은 가장 비싼 디스크 동작 중 하나

  - 탐색은 여러 단계로 나누어짐
    + 첫 번째는 가속 단계로 디스크 암이 움직이기 시작
    + 디스크 암이 최고 속도로 움직이는 활주 단계를 지남
    + 디스크 암의 속도가 줄어드는 감속 단계 이후 안정화 단계에서 정확한 트랙 위에 조심스럽게 위치
    + 드라이브가 정확한 트랙 위에 위치했는지 확실하게 해야하므로 안정화 시간(Setting Time)이 매우 중요하며, 0.5 ~ 2 ms 정도로 오래 걸림

  - 탐색 이후에 디스크 암은 올바른 트랙 위에 헤드를 위치시킴
  - 탐색 과정에서 암이 원하는 트랙 위로 이동하는 동안 당연히 플래터 역시 회전하며, 이 경우 3개의 섹터만큼 이동 : 섹터 9번이 디스크 헤드 아래로 막 지나가고 있으므로 약간의 회전 지연 후 전송이 완료됨
  - 섹터 11번이 디스크 헤드를 지나가게 되면 I/O의 마지막 단계인 전송이 이루어지며, 표면 위의 데이터를 읽거나 쓰게 됨

5. 그 외 세부사항
   - 많은 드라이브는 트랙 비틀림 (Track Skew)이라 불리는 기술을 채용해 트랙의 경계를 지나서 순차적으로 존재하는 섹터들을 올바르게 읽을 수 있게 됨
<div align="center">
<img src="https://github.com/user-attachments/assets/a52c8ead-8a4d-4378-8982-0e99659de8e2">
</div>

  - 한 트랙에서 다른 트랙으로 전환되는 경우, 바로 인접한 트랙으로 전환되는 경우에도, 디스크와 헤드를 다시 위치시키기 위한 시간이 필요
  - 이와 같은 비틀림이 없다면 헤드가 다음 트랙으로 넘어갔을 때 다음에 읽어야 하는 블럭이 이미 헤드를 지나쳤을 수도 있으므로 다음 블럭을 접근하기 위해 거의 한 바퀴 회전하는 회전 지연을 감수해야함
  - 또 다른 상황은 바깥 측 공간이 더 많다는 구조적 이유로 바깥 측 트랙들에는 안쪽 트랙들보다 더 많은 섹터들을 가지고 있음 : 이러한 트랙들을 흔히 멀티구역(Multi-Zoned) 디스크 드라이브라고 부름
    + 디스크들은 여러 구역으로 나뉘어 있으며, 한 구역은 표면 위에 연속적으로 존재하는 트랙들의 집합
    + 각 구역 내 트랙은 같은 수 섹터들을 포함하고 있으며, 바깥쪽 구역 트랙에는 안쪽 구역 트랙보다 많은 수 섹터를 가지고 있음

  - 현대 디스크 드라이브에서 가장 중요한 부분은 캐시(Cache)로, 때로는 트랙 버퍼(Track Buffer)라고 부름
    + 이 캐시는 일반적으로 8 또는 16 MB 정도의 작은 크기의 메모리로 드라이브가 디스크에서 읽거나 쓴 데이터를 보관하는데 사용
    + 예를 들어, 디스크에서 하나의 섹터를 읽을 때 드라이브가 그 트랙 위의 모든 섹터를 다 읽어 캐시에 저장할 수 있으며, 같은 트랙 섹터에 대한 이후 요청을 빠르게 응답 가능

  - 쓰기의 경우 드라이브는 선택할 수 있음
    + Write-Back 캐싱(즉시 보고(Immediate Reporting)) : 메모리에 데이터가 기록된 시점에 쓰기가 완료
    + Write-Through 캐싱 : 디스크에 실제 기록되었을 때 완료
    + 때로는 Write-Back 캐싱이 더 빠른 것 처럼 보이지만, 위험할 수 있음 : 만약 파일 시스템이나 응용 프로그램이 정확함을 위해 특정 순서로 디스크에 기록해야 한다고 할때, 문제 발생

-----
### 참고 : 차원 분석
-----
1. 컴퓨터 시스템 분석에서 사용 예시
   - 디스크가 한 번 회전하는데 걸리는 시간을 ms로 계산 (디스크의 RPM 또는 분당 회전수만 알고 있는 상황)
   - 10 K RPM 디스크(분당 10,000번 회전)를 예시로 가정
     + 먼저 식의 좌변에 원하는 단위를 기록 ($\frac{Time (ms)}{1 Rotation}$) 하되, 상쇄할 수 있는 것들은 찾아 상쇄
     + 좌변에 회전을 분모로 해놓은 것처럼 우변에도 똑같이 설정 ($\frac{Time (1 minute)}{10,000 Rotation}$) 후, 분을 초로 바꾼 뒤 (($\frac{60 seconds}{1 minute}$), 다시 msec로 바꾸어 ($\frac{1000 ms}{1 second}$)라고 씀
     + 최종 결과
<div align="center">
<img src="https://github.com/user-attachments/assets/bd668062-3405-45d1-ab1e-1e64dd6f5fe8">
</div>

2. 차원 분석은 직관적인 것처럼 보이는 과정을 간단한 반복 과정으로 변경
3. RPM 계산 외에도 I/O 분석에 자주 유용하게 활용
   - 예를 들어, 디스크 전송 속도가 100 MB / s와 같이 주어졌을 때, 512 KB 블럭을 전송하는데 걸리는 시간 (msec)
<div align="center">
<img src="https://github.com/user-attachments/assets/1d5332a1-e35f-44d9-9003-3d08340d75a5">
</div>
