-----
### 다른 스케줄링 쟁점들
-----
1. 디스크 스케줄링은 현대 시스템에서 어느 부분이 담당해야 하는가?
   - 예전 시스템의 경우 운영체제가 모든 스케줄 결정
     + 대기 중인 요청들의 집합을 살펴보고 운영체제가 최선의 요청을 선택하여 디스크에게 명령을 내렸음
     + 요청 처리가 완료되면 다음 요청을 다시 선택하는 식이었음

   - 현대 시스템에서는 디스크는 대기 중인 여러 개의 요청을 수용할 수 있으며 복잡한 내부 스케줄러를 자체적으로 가지고 있음 (이 스케줄러는 디스크 컨트롤러 내부에 있으므로 헤드의 정확한 위치도 알 수 있을 뿐만 아니라 그 외 필요한 정보들도 알 숭 ㅣㅆ음)
     + 따라서 SPTF 방식을 정밀하게 구현 가능
     + 따라서, 운영체제의 스케줄러는 최선이라고 보이는 몇 개의 요청을 선택해 모두 디스크에 내려보내며, 디스크는 상세한 트랙 배치 정보와 헤드의 위치에 대한 내부 지식을 활용해 최선의 (SPTF) 수서로 정렬

2. 디스크 스케줄러가 수행하는 중요한 또 다른 관련 작업 : I/O 병합 (I/O Merging)
<div align="center">
<img src="https://github.com/user-attachments/assets/aeddae7d-b378-4cd5-9962-bee4f230741b">
</div>

  - 블럭 33번, 8번, 그리고 34번을 읽는 연속된 요청이 있다고 가정
  - 이런 경우, 스케줄러는 블럭 33번과 34번 요청을 병합하여 두 블럭 길이의 요청으로 만듬
  - 병합된 요청을 반영하기 위해 스케줄러는 해당 요청들을 재배치하며, 디스크로 내려보내는 요청의 개수를 줄이면 오버헤드를 줄일 수 있어, 운영체제에서 병합은 특히 중요

3. 디스크로 I/O로 내려보내기 전 시스템은 얼마나 기다려야 하는가?
   - 처리할 요청이 있는 디스크는 유휴 상태가 되지 않도록 작업 보전(Work-Conserving) 방식을 사용해야 함
   - 하지만 예측 디스크 스케줄링(Anticipatory Disk Scheduling) 연구에 따르면 잠시 기다리는 것이 더 좋으며, 이를 작업 비보전(Non Work-Conserving) 방식이라 함
   - 즉, 기다리다 보면 새로운 좀 더 좋은 요청이 디스크에 도달할 수 있으므로 전체 효율이 좋아지게 될 수 있음 (하지만, 언제 기다리고 얼마나 기다리는 것을 결정하는 것은 까다로울 수 있음)
