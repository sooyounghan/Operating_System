-----
### 파일의 읽기와 쓰기
-----
1. 파일이 있으면, 그 파일들을 읽고나 쓰고 싶을 것
2. 커맨드 라인을 사용 중이면 cat이라는 프로그램을 사용해 파일 내용을 화면에 Dump 가능
```bash
prompt> echo hello > foo
prompt> cat foo
hello
prompt>
```

   - 이 코드에서는 echo의 출력을 foo로 전송(Redirect)하여 그 파일에 "hello"를 저장하도록 함
   - 그런 후 cat 명령어로 파일 내용 확인

3. Linux의 strace (Mac OS X에서는 dtruss 등)를 활용한 시스템 콜 추적을 통한 확인
   - strace는 프로그램이 실행되는 동안 호출된 모든 시스템 콜을 추적하고, 그 결과를 화면에 보여줌
     + 즉, strace를 실행하면 프로그램이 호출하는 시스템 콜들은 무엇이며, 사용하는 인자와 리턴 코드는 무엇인지 추적할 수 있으며, 프로그램이 무엇을 하고 있는지 확인 가능
     + 인자 : -f를 사용하면 fork된 자식 프로세스 추적 가능 / -t를 사용하면 호출 시각 / -e trace=open,close,read,write라고 하면 시스템 콜은 무시하고 해당 시스템 콜만 추적

4. 다음의 예를 통해 strace를 사용해 cat 동작 확인
```bash
prompt> strace cat foo
...

open(“foo”, O_RDONLY|O_LARGEFILE) = 3
read(3, “hello\n ”, 4096) = 6
write(1, “hello\n ”, 6) = 6
hello
read(3, “ ”, 4096) = 0
close(3) = 0

...

prompt>
```
  - cat이 가장 먼저 하는 것은 파일을 읽기 위해 여는 것
    + 파일은 O_RDONLY라는 플래그 사용 : 읽을 수만 있도록 염 (쓸 수 없음)
    + O_LARGEFILE 플래그 사용 : 64 bit 오프셋이 사용되도록 설정
    + open()이 성공한 이후 3이라는 값을 파일 디스크럽터로 리턴

  - 리턴값 3의 의미
    + 프로세스가 이미 3개의 파일을 열어놓았기 때문임
    + 세 개의 파일은 표준 입력(0), 표준 출력(1), 오류 메세지를 기록할 수 있는 표준 에러(2)로 표현
    + 다른 파일을 처음으로 열개 되면, 대부분은 파일 디스크립터 반환값이 3

  - 파일 열기가 성공하면 cat은 read() 시스템 콜을 사용해 파일에서 몇 바이트씩 반복적으로 읽음
    + read()의 첫 번째 인자 : 파일 디스크트럽터로서 파일 시스템에서 어떤 파일을 읽을 것인지 알려줌 (프로세스는 동시에 여러 파일을 열 수 있으므로, 디스크럽터는 운영체제가 read 명령이 읽어야 할 팔일을 알 수 있게 해줌)
    + read()의 두 번째 인자 : read() 결과를 저장할 버퍼를 가리킴 (위 예에서는 결과인 hello를 두 번째 인자 위치에 표시)
    + read()의 세 번쨰 인자 : 버퍼의 크기로서, 여기서는 4KB
    + read()가 성공적으로 리턴하여 읽은 바이트 수를 반환 (hello의 5개 문자와 줄의 끝을 표시하는 문자 하나를 포함한 6 반환)

  - write()에 대해 strace의 결과를 보면, 대상 파일로 파일 디스크럽터 1번을 사용
    + 즉, 표준 출력(STDOUT)으로서 hello라는 단어를 화면에 나타내기 위해 사용하고, cat하기로 되어 있는 작업
    + cat 프로그램이 write()를 직접 호출하는 것임 (그렇지 않다면 cat은 라이브러리 루틴 printf()를 호출했을 것(내부적으로 printf()는 전달받은 문자열에 적절한 포맷을 적용한 후 결과를 표준 출력을 대상으로 write()를 호출해 화면에 출력))
  
  - 출력 이후 cat 프로그램은 파일의 내용을 더 읽으려고 시도하고, 파일에 남은 바이트가 없으므로 read()는 0을 반환
    + 프로그램은 리턴 값으로 파일의 끝까지 다 읽었음을 알게 됨
    + 그런 후 프로그램은 해당 파일 디스크럽터를 인자로 close()를 추출하여 foo라는 파일에서 할 일이 끝났음을 표시
    + 파일이 이제 닫혔으므로 읽기 작업 완료

  - 파일에 쓰는 것도 비슷한 단계를 거침
    + 파일을 쓰기 위해 열고 write() 시스템 호출
    + 파일의 큰 경우 write() 시스템 콜을 반복적 호출 가능
    + 그 이후 close() 호출
