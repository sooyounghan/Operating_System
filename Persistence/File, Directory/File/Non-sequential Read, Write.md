-----
### 비 순차적 읽기와 쓰기
-----
1. 순차적 읽기와 쓰기 : 처음부터 파일을 끝까지 읽고, 쓸 때도 처음부터 끝까지 기록
2. 때로는 파일의 특정 오프셋부터 읽거나 쓰는 것이 유용할 때가 있음
   - 예를 들어, 문서의 인덱스를 만들고 특정 단어를 찾는다고 가정 : 문서 내 임의의 오프셋에서 읽기를 수행해야 함
   - 이를 위해 lseek()이라는 시스템 콜 사용
```c
off_t lseek(int fildes , off_t offset , int whence);
```
   - 첫 번째 인자 : 파일 디스크럽터
   - 두 번쨰 인자 : offset으로 특정 파일 위치(File Offest)
   - 세 번쨰 인자 : whence라고 부르며, 탐색 방식 결정
<div align="center">
<img src="https://github.com/user-attachments/assets/dacf1809-4cd6-44b4-b1f3-6818da5bddaf">
</div>

3. 프로세스가 open()한 각 파일에 대해 운영체제는 현재 오프셋을 추적하여 다음 읽기 또는 쓰기 위치 결정
   - 열린 파일의 개념에는 현재 오프셋이 포함
   - 오프셋은 두 가지 중 하나의 방법으로 갱신
     + N 바이트를 읽거나 쓸 때 현재 오프셋에 N이 더해짐 : 따라서 각 읽기 또는 쓰기는 암묵적으로 오프셋을 갱신
     + lseek로 명시적으로 오프셋 변경

4. 💡 lseek()는 디스크 암을 이동시키는 디스크 탐색(Seek) 작업과 아무런 관계가 없음
   - lseek() 호출은 커널 내부 변수의 값을 변경
   - I/O를 처리할 때 디스크 헤드가 어디에 있는지 따라서 요청을 처리하기 위해 실제 디스크 암을 이동하는 탐색 과정을 수행할 수 있고, 그렇지 않을 수 있음
   - 즉, lseek()을 호출한다고 디스크 탐색을 항상 하는 것은 아님
     + 다음 번의 읽기 또는 쓰기의 시작 위치를 변경하기 위해 lseek()는 단순히 특정 프로세스를 위해 운영체제가 관리하는 메모리 내 변수를 변경하는 역할을 함
     + 디스크 탐색은 디스크에 요청된 읽기 또는 쓰기가 직전에 수행했던 읽기 또는 쓰기와 같은 트랙이 아닌 경우에만 수행
     + 그래서 디스크 탐색은 헤드의 이동을 수반
     + 💡 파일의 임의의 부분을 읽고 쓸 때 실제 많은 디스크 탐색이 발생하지만, lseek()을 호출하는 것은 다음 번의 읽기와 쓰기를 위한 탐색 유도이긴 하지만, 그렇다고해서 실제로 I/O가 발생하는 것은 아님
       
