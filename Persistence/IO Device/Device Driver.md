-----
### 디바이스 드라이버
-----
1. 서로 다른 인터페이스를 갖는 장치들과 운영체제를 연결시키는 가능한 일반적인 방법
   - 예) 파일 시스템 : SCSI 디스크와 IDE 디스크, USD 이동식 드라이브와 같은 기기 위에서 동작하는 파일 시스템을 만들고 싶다고 가정
   - 하지만, 파일 시스템이 각 장치들의 구체적 입출력 명령어 형식에 종속되지 않도록 만들고 싶음
   - 추상화(Abstraction)라는 고전적 방법을 사용해 문제 해결 가능
     + 운영체제 최하위 계층 일부 소프트웨어는 장치의 동작 방식을 반드시 알고 있어야 함
     + 이 소프트웨어를 우리는 디바이스 드라이버(Device Driver)라고 부르며, 장치와의 상세한 상호작용은 그 안에 캡슐화되어 있음
    
2. Linux의 파일 시스템 소프트웨어 계층
   - 대략적인 Linux 소프트웨어 구조
<div align="center">
<img src="https://github.com/user-attachments/assets/09a81e2f-b234-417b-87f2-5f585459483d">
</div>

   - 파일 시스템(그 위의 응용 프로그램 포함)은 어떤 디스크 종류를 사용하는지 전혀 알지 못함
   - 파일 시스템은 범용 블럭 계층(Generic Block Layer)에 블럭 Read / Write를 요청할 뿐임
   - 범용 블럭 계층은 적절한 디바이스 드라이버로 받은 요청을 전달하며, 디바이스 드라이버는 특정 요청을 장치에 내리기 위해 필요한 일들을 처리

3. 단점
   - 예를 들어, 특수 기능을 많이 갖고 있는 어떤 장치가 있다고 할 때, 커널이 범용적인 인터페이스만을 제공할 수 밖에 없다면 그 많은 특수 기능들은 사용할 수 없게 됨 (Linux의 SCSI 장치들에서 볼 수 있음)
     + 다른 블럭 장치들(예) ATA/IDE)은 단순히 에러 처리만을 지원하므로 상위 소프트웨어 계층에서 받을 수 있는 정보로 범용 EIO(Generic IO Error) 에러 코드 이상 받을 수 없음
     + 따라서, SCSI가 제공하는 추가정보는 파일 시스템에 전달하지 못하고 사라지게 됨

   - 어떤 장치를 시스템에 연결하든 디바이스 드라이버가 필요하므로 시간의 흐름에 따라 디바이스 드라이버 코드가 커널 코드 대부분을 차지하게 됨
     + Linux 커널에 대한 연구에 따르면, 70% 이상 운영체제 코드가 디바이스 드라이버를 위한 코드
